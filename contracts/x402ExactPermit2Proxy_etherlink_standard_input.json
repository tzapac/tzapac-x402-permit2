{
  "language": "Solidity",
  "sources": {
    "x402ExactPermit2Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {x402BasePermit2Proxy} from \"./x402BasePermit2Proxy.sol\";\nimport {ISignatureTransfer} from \"./interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title x402ExactPermit2Proxy\n * @notice Trustless proxy for x402 payments using Permit2 with exact amount transfers\n *\n * @dev This contract acts as the authorized spender in Permit2 signatures.\n *      It uses the \"witness\" pattern to cryptographically bind the payment destination,\n *      preventing facilitators from redirecting funds.\n *\n *      Unlike x402UptoPermit2Proxy, this contract always transfers the EXACT permitted\n *      amount, similar to EIP-3009's transferWithAuthorization behavior.\n *\n * @author x402 Protocol\n */\ncontract x402ExactPermit2Proxy is x402BasePermit2Proxy {\n    /**\n     * @notice Settles a payment using a Permit2 signature\n     * @dev This is the standard settlement path when user has already approved Permit2.\n     *      Always transfers the exact permitted amount.\n     * @param permit The Permit2 transfer authorization\n     * @param owner The token owner (payer)\n     * @param witness The witness data containing destination and validity window\n     * @param signature The payer's signature over the permit and witness\n     */\n    function settle(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address owner,\n        Witness calldata witness,\n        bytes calldata signature\n    ) external nonReentrant {\n        _settle(permit, permit.permitted.amount, owner, witness, signature);\n        emit Settled();\n    }\n\n    /**\n     * @notice Settles a payment using both EIP-2612 permit and Permit2 signature\n     * @dev Enables fully gasless flow for tokens supporting EIP-2612.\n     *      First submits the EIP-2612 permit to approve Permit2, then settles.\n     *      Always transfers the exact permitted amount.\n     * @param permit2612 The EIP-2612 permit parameters\n     * @param permit The Permit2 transfer authorization\n     * @param owner The token owner (payer)\n     * @param witness The witness data containing destination and validity window\n     * @param signature The payer's signature over the permit and witness\n     *\n     * @dev This function will succeed even if the EIP-2612 permit fails,\n     *      as long as the Permit2 approval already exists\n     */\n    function settleWithPermit(\n        EIP2612Permit calldata permit2612,\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address owner,\n        Witness calldata witness,\n        bytes calldata signature\n    ) external nonReentrant {\n        _executePermit(permit.permitted.token, owner, permit2612);\n        _settle(permit, permit.permitted.amount, owner, witness, signature);\n        emit SettledWithPermit();\n    }\n}\n"
    },
    "x402BasePermit2Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {ISignatureTransfer} from \"./interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title x402BasePermit2Proxy\n * @notice Abstract base contract for x402 payments using Permit2\n *\n * @dev This contract provides the shared logic for x402 payment proxies.\n *      It acts as the authorized spender in Permit2 signatures and uses the\n *      \"witness\" pattern to cryptographically bind the payment destination,\n *      preventing facilitators from redirecting funds.\n *\n *      The contract uses an initializer pattern instead of constructor parameters\n *      to ensure the same CREATE2 address across all EVM chains, regardless of\n *      the chain's Permit2 deployment address.\n *\n * @author x402 Protocol\n */\nabstract contract x402BasePermit2Proxy is ReentrancyGuard {\n    /// @notice The Permit2 contract address (set via initialize)\n    ISignatureTransfer public PERMIT2;\n\n    /// @notice Whether the contract has been initialized\n    bool private _initialized;\n\n    /// @notice EIP-712 type string for witness data\n    /// @dev Must match the exact format expected by Permit2\n    /// Types must be in ALPHABETICAL order after the primary type (TokenPermissions < Witness)\n    string public constant WITNESS_TYPE_STRING =\n        \"Witness witness)TokenPermissions(address token,uint256 amount)Witness(address to,uint256 validAfter,bytes extra)\";\n\n    /// @notice EIP-712 typehash for witness struct\n    bytes32 public constant WITNESS_TYPEHASH = keccak256(\"Witness(address to,uint256 validAfter,bytes extra)\");\n\n    /// @notice Emitted when settle() completes successfully\n    event Settled();\n\n    /// @notice Emitted when settleWithPermit() completes successfully\n    event SettledWithPermit();\n\n    /// @notice Thrown when Permit2 address is zero\n    error InvalidPermit2Address();\n\n    /// @notice Thrown when initialize is called more than once\n    error AlreadyInitialized();\n\n    /// @notice Thrown when destination address is zero\n    error InvalidDestination();\n\n    /// @notice Thrown when payment is attempted before validAfter timestamp\n    error PaymentTooEarly();\n\n    /// @notice Thrown when owner address is zero\n    error InvalidOwner();\n\n    /**\n     * @notice Witness data structure for payment authorization\n     * @param to Destination address (immutable once signed)\n     * @param validAfter Earliest timestamp when payment can be settled\n     * @param extra Extensibility field for future use\n     * @dev The upper time bound is enforced by Permit2's deadline field\n     */\n    struct Witness {\n        address to;\n        uint256 validAfter;\n        bytes extra;\n    }\n\n    /**\n     * @notice EIP-2612 permit parameters grouped to reduce stack depth\n     * @param value Approval amount for Permit2\n     * @param deadline Permit expiration timestamp\n     * @param r ECDSA signature parameter\n     * @param s ECDSA signature parameter\n     * @param v ECDSA signature parameter\n     */\n    struct EIP2612Permit {\n        uint256 value;\n        uint256 deadline;\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    /**\n     * @notice Initializes the proxy with the Permit2 contract address\n     * @param _permit2 Address of the Permit2 contract for this chain\n     * @dev Can only be called once. Should be called immediately after deployment.\n     *      Reverts if _permit2 is the zero address or if already initialized.\n     */\n    function initialize(\n        address _permit2\n    ) external {\n        if (_initialized) revert AlreadyInitialized();\n        if (_permit2 == address(0)) revert InvalidPermit2Address();\n        _initialized = true;\n        PERMIT2 = ISignatureTransfer(_permit2);\n    }\n\n    /**\n     * @notice Internal settlement logic shared by all settlement functions\n     * @dev Validates all parameters and executes the Permit2 transfer\n     * @param permit The Permit2 transfer authorization\n     * @param amount The amount to transfer\n     * @param owner The token owner (payer)\n     * @param witness The witness data containing destination and validity window\n     * @param signature The payer's signature\n     */\n    function _settle(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        uint256 amount,\n        address owner,\n        Witness calldata witness,\n        bytes calldata signature\n    ) internal {\n        // Validate addresses\n        if (owner == address(0)) revert InvalidOwner();\n        if (witness.to == address(0)) revert InvalidDestination();\n\n        // Validate time window (upper bound enforced by Permit2's deadline)\n        if (block.timestamp < witness.validAfter) revert PaymentTooEarly();\n\n        // Prepare transfer details with destination from witness\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n            ISignatureTransfer.SignatureTransferDetails({to: witness.to, requestedAmount: amount});\n\n        // Reconstruct witness hash to enforce integrity\n        bytes32 witnessHash =\n            keccak256(abi.encode(WITNESS_TYPEHASH, witness.to, witness.validAfter, keccak256(witness.extra)));\n\n        // Execute transfer via Permit2\n        PERMIT2.permitWitnessTransferFrom(permit, transferDetails, owner, witnessHash, WITNESS_TYPE_STRING, signature);\n    }\n\n    /**\n     * @notice Attempts to execute an EIP-2612 permit to approve Permit2\n     * @dev Does not revert on failure because the approval might already exist\n     *      or the token might not support EIP-2612\n     * @param token The token address\n     * @param owner The token owner\n     * @param permit2612 The EIP-2612 permit parameters\n     */\n    function _executePermit(address token, address owner, EIP2612Permit calldata permit2612) internal {\n        try IERC20Permit(token).permit(\n            owner, address(PERMIT2), permit2612.value, permit2612.deadline, permit2612.v, permit2612.r, permit2612.s\n        ) {\n            // EIP-2612 permit succeeded\n        } catch {\n            // Permit2 settlement will fail if approval doesn't exist\n        }\n    }\n}\n"
    },
    "interfaces/ISignatureTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ISignatureTransfer\n * @notice Interface for Permit2's SignatureTransfer functionality\n * @dev Based on Uniswap's canonical Permit2 contract\n */\ninterface ISignatureTransfer {\n    /**\n     * @notice The token and amount details for a transfer signed in the permit transfer signature\n     */\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /**\n     * @notice The signed permit message for a single token transfer\n     */\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /**\n     * @notice Specifies the recipient address and amount for batched transfers.\n     * @dev Recipients and amounts correspond to the index of the signed token permissions array.\n     * @dev Reverts if the requested amount is greater than the permitted signed amount.\n     */\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /**\n     * @notice A map from token owner address and a caller specified word\n     *         index to a bitmap. Used to set bits in the bitmap to prevent\n     *         against signature replay protection\n     * @dev Uses unordered nonces so that permit messages do not need to be\n     *      spent in a certain order\n     * @dev The mapping is indexed first by the token owner, then by an\n     *      index specified in the nonce\n     * @dev It returns a uint256 bitmap\n     * @dev The index, or wordPosition is capped at type(uint248).max\n     */\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /**\n     * @notice Transfers a token using a signed permit message\n     * @dev Reverts if the requested amount is greater than the permitted signed amount\n     * @param permit The permit data signed over by the owner\n     * @param owner The owner of the tokens to transfer\n     * @param transferDetails The spender's requested transfer details for the permitted token\n     * @param signature The signature to verify\n     */\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Transfers a token using a signed permit message\n     * @notice Includes extra data provided by the caller to verify\n     *         signature over\n     * @dev The witness type string must follow EIP712 ordering of nested\n     *      structs and must include the TokenPermissions type definition\n     * @dev Reverts if the requested amount is greater than the permitted\n     *      signed amount\n     * @param permit The permit data signed over by the owner\n     * @param transferDetails The spender's requested transfer details for\n     *        the permitted token\n     * @param owner The owner of the tokens to transfer\n     * @param witness Extra data to include when checking the user signature\n     * @param witnessTypeString The EIP-712 type definition for remaining\n     *        string stub of the typehash\n     * @param signature The signature to verify\n     */\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * IMPORTANT: Deprecated. This storage-based reentrancy guard will be removed and replaced\n * by the {ReentrancyGuardTransient} variant in v6.0.\n *\n * @custom:stateless\n */\nabstract contract ReentrancyGuard {\n    using StorageSlot for bytes32;\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    /**\n     * @dev A `view` only version of {nonReentrant}. Use to block view functions\n     * from being called, preventing reading from inconsistent contract state.\n     *\n     * CAUTION: This is a \"view\" modifier and does not change the reentrancy\n     * status. Use it only on view functions. For payable or non-payable functions,\n     * use the standard {nonReentrant} modifier instead.\n     */\n    modifier nonReentrantView() {\n        _nonReentrantBeforeView();\n        _;\n    }\n\n    function _nonReentrantBeforeView() private view {\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        _nonReentrantBeforeView();\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyGuardStorageSlot().getUint256Slot().value = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _reentrancyGuardStorageSlot().getUint256Slot().value == ENTERED;\n    }\n\n    function _reentrancyGuardStorageSlot() internal pure virtual returns (bytes32) {\n        return REENTRANCY_GUARD_STORAGE;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also applies here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "forge-std/=lib/forge-std/src/",
      "permit2/=lib/permit2/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false
  }
}
diff --git a/PROOF_OF_CONCEPT.md b/PROOF_OF_CONCEPT.md
index 755864f..5613fae 100644
--- a/PROOF_OF_CONCEPT.md
+++ b/PROOF_OF_CONCEPT.md
@@ -11,19 +11,19 @@
 | Component | Status | Notes |
 |-----------|--------|-------|
 | HTTP 402 Challenge | **VERIFIED** | Server returns proper `X-PAYMENT-REQUIRED` header |
-| EIP-712 Permit Signing | **VERIFIED** | Client creates valid BBT permit signature |
+| Permit2 Signing | **VERIFIED** | Client creates valid Permit2 signature |
 | Payment Header Exchange | **VERIFIED** | `X-PAYMENT` header accepted by server |
 | Server â†’ Facilitator `/settle` | **VERIFIED** | Server forwards payment to facilitator |
-| Facilitator Signature Validation | **BLOCKED** | Signature format mismatch (see below) |
-| On-Chain Settlement | **BLOCKED** | Cannot proceed due to signature issue |
+| Facilitator Permit2 Validation | **VERIFIED** | Permit2 flow accepted |
+| On-Chain Settlement | **VERIFIED** | Payment settles on Etherlink |
 
-**Conclusion:** The x402 HTTP protocol flow works on Etherlink. On-chain settlement is BLOCKED due to EIP-712 signature format mismatch between client (EIP-2612 Permit) and facilitator (EIP-3009 TransferWithAuthorization).
+**Conclusion:** The x402 HTTP protocol flow and on-chain settlement work on Etherlink using Permit2.
 
 ---
 
 ## Component Receipts
 
-### 1. Facilitator (ub1: 100.112.150.8:8080)
+### 1. Facilitator (ub1: 100.112.150.8:9090)
 
 **Endpoint:** `/api/supported`  
 **Response:**
@@ -33,26 +33,25 @@
     {
       "network": "eip155:42793",
       "scheme": "exact",
-      "x402Version": 1
+      "x402Version": 2
     }
   ]
 }
 ```
 
-**Container:** `x402-facilitator-etherlink`  
-**Image:** `ukstv/x402-facilitator:etherlink`  
-**Status:** Running
+**Binary:** `~/x402-facilitator-debug`  
+**Status:** Running on port 9090
 
 ---
 
-### 2. MVP Server (localhost:8000)
+### 2. MVP Server (localhost:8001)
 
-**File:** `mvp_server.py`
+**File:** `bbt_mvp_server.py`
 
 **Request 1 - No Payment:**
 ```
 GET /api/weather HTTP/1.1
-Host: localhost:8000
+Host: localhost:8001
 ```
 
 **Response 1 - 402 Payment Required:**
@@ -67,16 +66,16 @@ Content-Type: application/json
 **Decoded X-PAYMENT-REQUIRED:**
 ```json
 {
-  "x402Version": 1,
+  "x402Version": 2,
   "accepts": [
     {
       "scheme": "exact",
       "network": "eip155:42793",
-      "maxAmountRequired": "10000000000000000",
-      "resource": "http://localhost:8000/api/weather",
+      "amount": "10000000000000000",
+      "resource": "http://localhost:8001/api/weather",
       "description": "Weather data access",
       "mimeType": "application/json",
-      "payTo": "0x81C54CB7690016b2b0c3017a4991783964601bd9",
+      "payTo": "0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9",
       "maxTimeoutSeconds": 60,
       "asset": "eip155:42793/erc20:0x7EfE4bdd11237610bcFca478937658bE39F8dfd6",
       "extra": {
@@ -93,41 +92,46 @@ Content-Type: application/json
 
 ### 3. MVP Client Payment
 
-**File:** `mvp_client.py`
+**File:** `bbt_mvp_client.py`
 
-**Client Wallet:** `0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F`
+**Client Wallet:** `0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9`
 
 **EIP-712 Permit Parameters:**
 | Field | Value |
 |-------|-------|
 | Token | `0x7EfE4bdd11237610bcFca478937658bE39F8dfd6` (BBT) |
-| Owner | `0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F` |
-| Spender | `0x81C54CB7690016b2b0c3017a4991783964601bd9` |
+| Owner | `0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9` |
+| Spender | `0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9` |
 | Value | `10000000000000000` (0.01 BBT) |
-| Deadline | `1770018036` (Unix timestamp) |
-| Nonce | `0` |
+| Deadline | `1770042190` (Unix timestamp) |
+| Nonce | `7` |
 | Chain ID | `42793` |
 
 **Generated Signature:**
 ```
-c0aaa2cfdf2d10652a33d3fbfc5ce5b4d2210e76a4ca99f0f07ecfd7bca22ace2b6382c7b6973fc6dfa34e9906ddae949b703d12f2dd6998200c81240e14dff21b
+996ba799657fae8f25e411ae5962dbad6553ee4ceda7ac59b3fdb1c6789f4a5969264479d735f4767c7d15b1fc8f58e71530621188e797dffc35646e2f74d99b1b
 ```
 
 **X-PAYMENT Header Payload:**
 ```json
 {
-  "x402Version": 1,
+  "x402Version": 2,
   "scheme": "exact",
   "network": "eip155:42793",
   "payload": {
-    "signature": "c0aaa2cfdf2d10652a33d3fbfc5ce5b4d2210e76a4ca99f0f07ecfd7bca22ace2b6382c7b6973fc6dfa34e9906ddae949b703d12f2dd6998200c81240e14dff21b",
-    "authorization": {
-      "from": "0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F",
-      "to": "0x81C54CB7690016b2b0c3017a4991783964601bd9",
-      "value": "10000000000000000",
-      "validAfter": "0",
-      "validBefore": "1770018036",
-      "nonce": "0"
+    "permit2": {
+      "owner": "0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9",
+      "permitSingle": {
+        "details": {
+          "token": "0x7EfE4bdd11237610bcFca478937658bE39F8dfd6",
+          "amount": 10000000000000000,
+          "expiration": 1770042190,
+          "nonce": 7
+        },
+        "spender": "0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9",
+        "sigDeadline": 1770042190
+      },
+      "signature": "996ba799657fae8f25e411ae5962dbad6553ee4ceda7ac59b3fdb1c6789f4a5969264479d735f4767c7d15b1fc8f58e71530621188e797dffc35646e2f74d99b1b"
     }
   }
 }
@@ -140,7 +144,7 @@ c0aaa2cfdf2d10652a33d3fbfc5ce5b4d2210e76a4ca99f0f07ecfd7bca22ace2b6382c7b6973fc6
 **Request 2 - With Payment:**
 ```
 GET /api/weather HTTP/1.1
-Host: localhost:8000
+Host: localhost:8001
 X-PAYMENT: eyJ4NDAyVmVyc2lvbiI6IDEsICJzY2hlbWUiOiAiZXhhY3Qi...
 ```
 
@@ -153,61 +157,31 @@ Content-Type: application/json
   "weather": "sunny",
   "temperature": 25,
   "location": "Etherlink",
-  "payment_received": true,
-  "payment_scheme": "exact"
+  "payment_settled": true,
+  "txHash": "0x0476d3bcfccf6a83644d12c5abcaf598a6fc1ac7ee1377bff35fda5b828590e1",
+  "explorer": "https://explorer.etherlink.com/tx/0x0476d3bcfccf6a83644d12c5abcaf598a6fc1ac7ee1377bff35fda5b828590e1"
 }
 ```
 
 ---
 
-## On-Chain Settlement Attempt
+## On-Chain Settlement
 
 ### What We Implemented
 The MVP server now calls the facilitator `/settle` endpoint with the payment signature.
 
 ### Facilitator Response
 ```
-Settlement failed
-error: Invalid signature: Address mismatch
-  recovered: 0xBB29d3eAaF085D8D70904D9D91Ae56b66eA4EA7c
-  expected:  0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F
+{"success": true, "transaction": "0x0476d3bcfccf6a83644d12c5abcaf598a6fc1ac7ee1377bff35fda5b828590e1", "network": "eip155:42793"}
 ```
 
-### Root Cause: EIP-712 Type Mismatch
-
-The x402-rs facilitator expects **EIP-3009 TransferWithAuthorization** signatures:
-```solidity
-TransferWithAuthorization(
-  address from,
-  address to,
-  uint256 value,
-  uint256 validAfter,
-  uint256 validBefore,
-  bytes32 nonce
-)
-```
-
-But BBT token on Etherlink only supports **EIP-2612 Permit**:
-```solidity
-Permit(
-  address owner,
-  address spender,
-  uint256 value,
-  uint256 nonce,
-  uint256 deadline
-)
-```
-
-These have different EIP-712 typed data structures, so the signature that validates against Permit will NOT validate against TransferWithAuthorization.
-
 ### Solutions to Unblock
 
 | Option | Effort | Description |
 |--------|--------|-------------|
-| **A. Deploy EIP-3009 token** | Medium | Deploy a token with `transferWithAuthorization` on Etherlink |
-| **B. Modify x402-rs facilitator** | High | Add EIP-2612 Permit support alongside EIP-3009 |
-| **C. Use existing EIP-3009 token** | Low | Find/use Etherlink USDC if it supports EIP-3009 |
-| **D. Fork x402 SDK** | High | Create Permit-compatible version of the protocol |
+| **A. Keep Permit2 facilitator** | Low | Continue using debug binary on port 9090 |
+| **B. Containerize Permit2** | Medium | Bake Permit2 changes into Docker image |
+| **C. Expand payTo support** | Medium | Align Permit2 spender vs recipient handling |
 
 ---
 
@@ -221,7 +195,7 @@ These have different EIP-712 typed data structures, so the signature that valida
 | RPC URL | https://rpc.bubbletez.com |
 | Explorer | https://explorer.etherlink.com |
 | BBT Token | 0x7EfE4bdd11237610bcFca478937658bE39F8dfd6 |
-| Facilitator | http://100.112.150.8:8080 |
+| Facilitator | http://100.112.150.8:9090 |
 
 ---
 
@@ -229,8 +203,8 @@ These have different EIP-712 typed data structures, so the signature that valida
 
 | File | Purpose |
 |------|---------|
-| `mvp_server.py` | Minimal x402 server (returns 402, accepts X-PAYMENT) |
-| `mvp_client.py` | Minimal x402 client (creates EIP-712 permit, sends X-PAYMENT) |
+| `bbt_mvp_server.py` | Minimal x402 server (returns 402, accepts X-PAYMENT) |
+| `bbt_mvp_client.py` | Minimal x402 client (creates Permit2 payload, sends X-PAYMENT) |
 | `bbt_storefront.py` | Full SDK-based server (blocked by middleware bug) |
 | `.env` | Private key and configuration |
 
@@ -238,10 +212,9 @@ These have different EIP-712 typed data structures, so the signature that valida
 
 ## Next Steps
 
-1. **Find/Deploy EIP-3009 compatible token** - Required for on-chain settlement
-2. **Or modify x402-rs facilitator** - Add EIP-2612 Permit support
-3. **Debug SDK middleware** - Fix `RouteConfigurationError` for production use
-4. **Complete end-to-end test** - Once signature format is resolved
+1. **Decide on facilitator deployment** - Keep 9090 or bake Permit2 into container
+2. **If needed, update payTo/recipient handling** - Support non-self payTo flows
+3. **Document production flow** - Capture final commands and artifacts
 
 ---
 
@@ -260,8 +233,6 @@ The x402 HTTP payment protocol flow is **verified working** on Etherlink:
 
 | What's Blocked | Reason |
 |----------------|--------|
-| Facilitator signature validation | EIP-3009 vs EIP-2612 format mismatch |
-| On-chain token transfer | Blocked by above |
-| Transaction hash proof | Blocked by above |
+| None | Settlement verified with Permit2 |
 
-**The protocol works. The token doesn't support the required signature format.**
+**The protocol and settlement work with Permit2 on Etherlink.**
diff --git a/bbt-x402-facilitator b/bbt-x402-facilitator
deleted file mode 160000
index 25f30da..0000000
--- a/bbt-x402-facilitator
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 25f30da5753dfb6d71e7395d692727634936310d
diff --git a/bbt-x402-facilitator/.cargoignore b/bbt-x402-facilitator/.cargoignore
new file mode 100644
index 0000000..accb0fe
--- /dev/null
+++ b/bbt-x402-facilitator/.cargoignore
@@ -0,0 +1,5 @@
+justfile
+Dockerfile
+.env.example
+.github
+.cargo
diff --git a/bbt-x402-facilitator/.config/rail.toml b/bbt-x402-facilitator/.config/rail.toml
new file mode 100644
index 0000000..711cc23
--- /dev/null
+++ b/bbt-x402-facilitator/.config/rail.toml
@@ -0,0 +1,81 @@
+# cargo-rail configuration
+# Documentation: https://github.com/loadingalias/cargo-rail
+
+# targets = []  # optional: set for multi-target validation; `cargo rail init` can auto-detect from *.toml and .github/workflows
+
+[unify]
+include_paths = true
+include_renamed = false
+
+pin_transitives = false  # enable for hakari/workspace-hack users
+transitive_host = "root"  # only used if pin_transitives = true
+
+strict_version_compat = true
+exact_pin_handling = "warn"
+major_version_conflict = "warn"  # warn = skip, bump = force highest
+
+msrv = true
+msrv_source = "max"  # deps | workspace | max
+enforce_msrv_inheritance = false  # Ensure members inherit workspace rust-version
+
+detect_unused = true
+remove_unused = true  # requires detect_unused = true
+
+prune_dead_features = true
+preserve_features = []  # glob patterns to keep from pruning
+detect_undeclared_features = true
+fix_undeclared_features = true  # requires detect_undeclared_features = true
+skip_undeclared_patterns = [
+  "default",
+  "std",
+  "alloc",
+  "*_backend",
+  "*_impl",
+]
+
+exclude = []
+include = []
+max_backups = 3
+sort_dependencies = true  # false to preserve existing order
+
+
+[release]
+tag_prefix = "v"
+tag_format = "{crate}-{prefix}{version}"  # e.g. my-crate-v1.0.0 (with tag_prefix = "v")
+require_clean = true
+publish_delay = 5  # seconds between publishes
+create_github_release = false
+sign_tags = false
+changelog_path = "CHANGELOG.md"
+changelog_relative_to = "crate"  # crate = per-crate, workspace = single file
+skip_changelog_for = []
+require_changelog_entries = false
+
+
+[change-detection]
+# Paths that trigger full workspace rebuild
+infrastructure = [
+  ".github/**",
+  "scripts/**",
+  "justfile",
+  "Justfile",
+  "Makefile",
+  "makefile",
+  "GNUmakefile",
+  "*.sh",
+  "Taskfile.yml",
+  "Taskfile.yaml",
+  ".pre-commit-config.yaml",
+  "deny.toml",
+  "cliff.toml",
+  "release.toml",
+  "release-plz.toml",
+]
+
+
+# Per-crate configuration: run 'cargo rail split init <crate>' to generate
+# [crates.my-crate.split]
+# remote = "git@github.com:org/my-crate.git"
+# branch = "main"
+# mode = "single"
+# paths = [{ crate = "crates/my-crate" }]
diff --git a/bbt-x402-facilitator/.dockerignore b/bbt-x402-facilitator/.dockerignore
new file mode 100644
index 0000000..2b15494
--- /dev/null
+++ b/bbt-x402-facilitator/.dockerignore
@@ -0,0 +1,5 @@
+target/
+.git/
+*.rs.bk
+*.log
+.env
\ No newline at end of file
diff --git a/bbt-x402-facilitator/.editorconfig b/bbt-x402-facilitator/.editorconfig
new file mode 100644
index 0000000..4857d97
--- /dev/null
+++ b/bbt-x402-facilitator/.editorconfig
@@ -0,0 +1,21 @@
+# http://editorconfig.org
+
+root = true
+
+[*]
+charset = utf-8
+end_of_line = lf
+trim_trailing_whitespace = true
+insert_final_newline = true
+indent_style = space
+indent_size = 2
+
+[*.rs]
+max_line_length = 100
+indent_size = 4
+
+[*.md]
+trim_trailing_whitespace = false
+
+[Dockerfile]
+indent_size = 4
\ No newline at end of file
diff --git a/bbt-x402-facilitator/.github/workflows/ci.yaml b/bbt-x402-facilitator/.github/workflows/ci.yaml
new file mode 100644
index 0000000..5210c18
--- /dev/null
+++ b/bbt-x402-facilitator/.github/workflows/ci.yaml
@@ -0,0 +1,242 @@
+name: Build, test, and publish a Docker image
+
+on:
+  push:
+    branches: ['main']
+    tags: ['v*']
+
+env:
+  GH_REGISTRY: ghcr.io
+  GH_IMAGE_NAME: x402-rs/x402-facilitator
+  DH_REGISTRY: docker.io
+  DH_IMAGE_NAME: ukstv/x402-facilitator
+
+jobs:
+  metadata:
+    name: Docker Metadata
+    runs-on: ubuntu-24.04
+    outputs:
+      tags: ${{ steps.meta_main.outputs.tags || steps.meta_tag.outputs.tags || steps.meta_default.outputs.tags }}
+      labels: ${{ steps.meta_main.outputs.labels || steps.meta_tag.outputs.labels || steps.meta_default.outputs.labels }}
+      annotations: ${{ steps.meta_main.outputs.annotations || steps.meta_tag.outputs.annotations || steps.meta_default.outputs.annotations }}
+      json: ${{ steps.meta_main.outputs.json || steps.meta_tag.outputs.json || steps.meta_default.outputs.json }}
+      architectures: ${{ steps.set-architectures.outputs.matrix }}
+      arch-list: ${{ steps.set-architectures.outputs.list }}
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set architectures to build
+        id: set-architectures
+        run: |
+          # Define architectures here - THIS IS THE ONLY PLACE TO CHANGE FOR ARM64
+          # Current: AMD64 and ARM64
+          MATRIX='{"include":[{"runner":"ubuntu-latest","arch":"amd64","platform":"linux/amd64"},{"runner":"ubuntu-24.04-arm","arch":"arm64","platform":"linux/arm64"}]}'
+          # To disable ARM64, use this instead:
+          # MATRIX='{"include":[{"runner":"ubuntu-latest","arch":"amd64","platform":"linux/amd64"}]}'
+
+          # Extract just the arch values for the merge job
+          ARCH_LIST=$(echo "$MATRIX" | jq -c '[.include[].arch]')
+
+          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
+          echo "list=$ARCH_LIST" >> $GITHUB_OUTPUT
+          echo "Architecture matrix: $MATRIX"
+          echo "Architecture list: $ARCH_LIST"
+
+      - name: Prepare Metadata (main)
+        if: github.ref == 'refs/heads/main'
+        id: meta_main
+        uses: docker/metadata-action@v5
+        with:
+          images: ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}
+          tags: |
+            type=raw,value=dev
+          labels: true
+          annotations: true
+
+      - name: Prepare Metadata (release tag)
+        if: startsWith(github.ref, 'refs/tags/v')
+        id: meta_tag
+        uses: docker/metadata-action@v5
+        with:
+          images: ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}
+          tags: |
+            type=raw,value=latest
+            type=semver,pattern={{version}}
+            type=semver,pattern={{major}}.{{minor}}
+            type=semver,pattern={{major}}
+          labels: true
+          annotations: true
+
+      - name: Prepare Metadata (default)
+        if: github.ref != 'refs/heads/main' && !startsWith(github.ref, 'refs/tags/v')
+        id: meta_default
+        uses: docker/metadata-action@v5
+        with:
+          images: ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}
+          tags: |
+            type=raw,value=dev
+          labels: true
+          annotations: true
+
+  build:
+    strategy:
+      matrix: ${{ fromJSON(needs.metadata.outputs.architectures) }}
+    runs-on: ${{ matrix.runner }}
+    needs: metadata
+    permissions:
+      contents: read
+      packages: write
+      attestations: write
+      id-token: write
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v3
+
+      - name: Login to GHCR
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.GH_REGISTRY }}
+          username: ${{ github.actor }}
+          password: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Login to Docker Hub
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.DH_REGISTRY }}
+          username: ${{ secrets.DOCKERHUB_USERNAME }}
+          password: ${{ secrets.DOCKERHUB_TOKEN }}
+
+      - name: Build and push ${{ matrix.arch }} image
+        id: build-and-push
+        uses: docker/build-push-action@v5
+        with:
+          context: .
+          push: true
+          provenance: mode=max
+          platforms: ${{ matrix.platform }}
+          tags: ${{ join(fromJSON(needs.metadata.outputs.json).tags, format('-{0},', matrix.arch)) }}-${{ matrix.arch }}
+          labels: ${{ needs.metadata.outputs.labels }}
+          annotations: ${{ needs.metadata.outputs.annotations }}
+          cache-from: type=gha,scope=${{ matrix.arch }}
+          cache-to: type=gha,mode=max,scope=${{ matrix.arch }}
+
+      - name: Generate image attestation
+        uses: actions/attest-build-provenance@v2
+        with:
+          subject-name: ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}
+          subject-digest: ${{ steps.build-and-push.outputs.digest }}
+          push-to-registry: true
+
+  merge-manifest:
+    name: Merge Docker manifests
+    runs-on: ubuntu-latest
+    needs: [build, metadata]
+    permissions:
+      contents: read
+      packages: write
+      attestations: write
+      id-token: write
+    outputs:
+      digests_matrix: ${{ steps.merge-manifest.outputs.digests_matrix }}
+    steps:
+      - name: Login to GHCR
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.GH_REGISTRY }}
+          username: ${{ github.actor }}
+          password: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Login to Docker Hub
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.DH_REGISTRY }}
+          username: ${{ secrets.DOCKERHUB_USERNAME }}
+          password: ${{ secrets.DOCKERHUB_TOKEN }}
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v3
+
+      - name: Export description
+        run: |
+          DESCRIPTION=$(echo "${{ needs.metadata.outputs.annotations }}" | grep 'org.opencontainers.image.description=' | cut -d= -f2-)
+          echo "DESCRIPTION=$DESCRIPTION"
+          echo "DESCRIPTION=$DESCRIPTION" >> "$GITHUB_ENV"
+
+      - name: Merge all tags and capture digests
+        id: merge-manifest
+        run: |
+          echo "Merging tags: ${{ needs.metadata.outputs.tags }}"
+          echo "Architectures: ${{ needs.metadata.outputs.arch-list }}"
+
+          # Parse architecture list
+          readarray -t ARCHITECTURES < <(echo '${{ needs.metadata.outputs.arch-list }}' | jq -r '.[]')
+
+          readarray -t FULL_TAGS <<< "${{ needs.metadata.outputs.tags }}"
+          digests_matrix="["
+          for full in "${FULL_TAGS[@]}"; do
+            tag="${full##*:}"
+            echo "Creating manifest for: $tag"
+
+            # Build list of architecture-specific images dynamically
+            ARCH_IMAGES=""
+            for arch in "${ARCHITECTURES[@]}"; do
+              ARCH_IMAGES="$ARCH_IMAGES ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}:$tag-$arch"
+            done
+
+            echo "Merging images: $ARCH_IMAGES"
+            docker buildx imagetools create \
+              --tag ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}:$tag \
+              --tag ${{ env.DH_REGISTRY }}/${{ env.DH_IMAGE_NAME }}:$tag \
+              --annotation "index:org.opencontainers.image.description=$DESCRIPTION" \
+              $ARCH_IMAGES
+
+            digest=$(docker buildx imagetools inspect --format '{{json .Manifest}}' ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}:$tag | jq -r '.digest')
+            digests_matrix+="{\"tag\":\"$tag\",\"digest\":\"$digest\"},"
+          done
+          digests_matrix="${digests_matrix%,}]"
+          echo "digests_matrix=$digests_matrix" >> $GITHUB_OUTPUT
+
+  attest-digests:
+    name: Attest merged manifests
+    needs: merge-manifest
+    runs-on: ubuntu-latest
+    permissions:
+      contents: read
+      packages: write
+      attestations: write
+      id-token: write
+    strategy:
+      matrix:
+        digest_entry: ${{ fromJson(needs.merge-manifest.outputs.digests_matrix) }}
+    steps:
+      - name: Login to GHCR
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.GH_REGISTRY }}
+          username: ${{ github.actor }}
+          password: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Login to Docker Hub
+        uses: docker/login-action@v3
+        with:
+          registry: ${{ env.DH_REGISTRY }}
+          username: ${{ secrets.DOCKERHUB_USERNAME }}
+          password: ${{ secrets.DOCKERHUB_TOKEN }}
+
+      - name: Attest ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}:${{ matrix.digest_entry.tag }}
+        uses: actions/attest-build-provenance@v2
+        with:
+          subject-name: ${{ env.GH_REGISTRY }}/${{ env.GH_IMAGE_NAME }}
+          subject-digest: ${{ matrix.digest_entry.digest }}
+          push-to-registry: true
+
+      - name: Attest ${{ env.DH_REGISTRY }}/${{ env.DH_IMAGE_NAME }}:${{ matrix.digest_entry.tag }}
+        uses: actions/attest-build-provenance@v2
+        with:
+          subject-name: ${{ env.DH_REGISTRY }}/${{ env.DH_IMAGE_NAME }}
+          subject-digest: ${{ matrix.digest_entry.digest }}
+          push-to-registry: true
diff --git a/bbt-x402-facilitator/.gitignore b/bbt-x402-facilitator/.gitignore
new file mode 100644
index 0000000..ed3ce46
--- /dev/null
+++ b/bbt-x402-facilitator/.gitignore
@@ -0,0 +1,6 @@
+/target/
+.idea/
+.env
+crates/*/target/
+examples/*/.env
+config.json
\ No newline at end of file
diff --git a/bbt-x402-facilitator/CHANGELOG.md b/bbt-x402-facilitator/CHANGELOG.md
new file mode 100644
index 0000000..754e144
--- /dev/null
+++ b/bbt-x402-facilitator/CHANGELOG.md
@@ -0,0 +1,48 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [1.0.0] - 2025-02-02
+
+### Changed
+
+- **BREAKING**: Refactored from a single monolithic crate into a modular workspace architecture. The `x402-rs` crate is no longer published as a single package.
+- **BREAKING**: Import paths have changed from `x402_rs::*` to `x402_types::*` and specific chain crates.
+
+### Added
+
+- New `x402-types` crate: Core protocol types, facilitator traits, and utilities.
+- New `x402-chain-eip155` crate: EVM/EIP-155 chain support (Ethereum, Base, Polygon, etc.) with feature flags for `client`, `server`, and `facilitator`.
+- New `x402-chain-solana` crate: Solana blockchain support with feature flags for `client`, `server`, and `facilitator`.
+- New `x402-chain-aptos` crate: Aptos blockchain support with feature flags for `client`, `server`, and `facilitator`.
+- New `x402-facilitator-local` crate: Local facilitator implementation for payment verification and settlement.
+- New `facilitator` binary crate: Production-ready facilitator server (not published to crates.io).
+- New documentation: `docs/build-your-own-facilitator.md` guide.
+- Workspace-level dependency management in root `Cargo.toml`.
+
+### Migration Guide
+
+**Before (v0.12.x):**
+```toml
+[dependencies]
+x402-rs = { version = "0.12", features = ["eip155", "solana"] }
+```
+
+**After (v1.0.0):**
+```toml
+[dependencies]
+x402-types = "1.0"
+x402-chain-eip155 = { version = "1.0", features = ["client"] }
+x402-chain-solana = { version = "1.0", features = ["client"] }
+```
+
+## [0.12.6] - 2025-01-26
+
+- Added Aptos chain support.
+
+## [0.12.5] - 2025-01-21
+
+- Previous monolithic crate version before workspace refactor.
diff --git a/bbt-x402-facilitator/Cargo.lock b/bbt-x402-facilitator/Cargo.lock
new file mode 100644
index 0000000..f808cfe
--- /dev/null
+++ b/bbt-x402-facilitator/Cargo.lock
@@ -0,0 +1,13490 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 4
+
+[[package]]
+name = "Inflector"
+version = "0.11.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fe438c63458706e03479442743baae6c88256498e6431708f6dfc520a26515d3"
+dependencies = [
+ "lazy_static",
+ "regex",
+]
+
+[[package]]
+name = "abstract-domain-derive"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "addchain"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b2e69442aa5628ea6951fa33e24efe8313f4321a91bd729fc2f75bdfc858570"
+dependencies = [
+ "num-bigint 0.3.3",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "addr2line"
+version = "0.25.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b5d307320b3181d6d7954e663bd7c774a838b8220fe0593c86d9fb09f498b4b"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
+name = "adler2"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"
+
+[[package]]
+name = "aead"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
+dependencies = [
+ "crypto-common",
+ "generic-array",
+]
+
+[[package]]
+name = "aes"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
+dependencies = [
+ "cfg-if",
+ "cipher",
+ "cpufeatures",
+]
+
+[[package]]
+name = "aes-gcm"
+version = "0.10.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "831010a0f742e1209b3bcea8fab6a8e149051ba6099432c8cb2cc117dec3ead1"
+dependencies = [
+ "aead",
+ "aes",
+ "cipher",
+ "ctr",
+ "ghash",
+ "subtle",
+]
+
+[[package]]
+name = "aes-gcm-siv"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ae0784134ba9375416d469ec31e7c5f9fa94405049cf08c5ce5b4698be673e0d"
+dependencies = [
+ "aead",
+ "aes",
+ "cipher",
+ "ctr",
+ "polyval",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "agave-feature-set"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a78af1c611c18d4a20e0983f033bdd74eaa8f44cee0d3c10ee66873f2630a636"
+dependencies = [
+ "ahash 0.8.12",
+ "solana-epoch-schedule",
+ "solana-hash 3.1.0",
+ "solana-pubkey 3.0.0",
+ "solana-sha256-hasher",
+ "solana-svm-feature-set",
+]
+
+[[package]]
+name = "ahash"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
+dependencies = [
+ "getrandom 0.2.17",
+ "once_cell",
+ "version_check",
+]
+
+[[package]]
+name = "ahash"
+version = "0.8.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
+dependencies = [
+ "cfg-if",
+ "getrandom 0.3.4",
+ "once_cell",
+ "serde",
+ "version_check",
+ "zerocopy",
+]
+
+[[package]]
+name = "aho-corasick"
+version = "1.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "aliasable"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "250f629c0161ad8107cf89319e990051fae62832fd343083bea452d93e2205fd"
+
+[[package]]
+name = "alloc-no-stdlib"
+version = "2.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc7bb162ec39d46ab1ca8c77bf72e890535becd1751bb45f64c597edb4c8c6b3"
+
+[[package]]
+name = "alloc-stdlib"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
+dependencies = [
+ "alloc-no-stdlib",
+]
+
+[[package]]
+name = "allocator-api2"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"
+
+[[package]]
+name = "alloy-chains"
+version = "0.2.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "25db5bcdd086f0b1b9610140a12c59b757397be90bd130d8d836fc8da0815a34"
+dependencies = [
+ "alloy-primitives",
+ "num_enum",
+ "strum 0.27.2",
+]
+
+[[package]]
+name = "alloy-consensus"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c3a590d13de3944675987394715f37537b50b856e3b23a0e66e97d963edbf38"
+dependencies = [
+ "alloy-eips",
+ "alloy-primitives",
+ "alloy-rlp",
+ "alloy-serde",
+ "alloy-trie",
+ "alloy-tx-macros",
+ "auto_impl",
+ "borsh",
+ "c-kzg",
+ "derive_more 2.1.1",
+ "either",
+ "k256",
+ "once_cell",
+ "rand 0.8.5",
+ "secp256k1",
+ "serde",
+ "serde_json",
+ "serde_with",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-consensus-any"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0f28f769d5ea999f0d8a105e434f483456a15b4e1fcb08edbbbe1650a497ff6d"
+dependencies = [
+ "alloy-consensus",
+ "alloy-eips",
+ "alloy-primitives",
+ "alloy-rlp",
+ "alloy-serde",
+ "serde",
+]
+
+[[package]]
+name = "alloy-contract"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "990fa65cd132a99d3c3795a82b9f93ec82b81c7de3bab0bf26ca5c73286f7186"
+dependencies = [
+ "alloy-consensus",
+ "alloy-dyn-abi",
+ "alloy-json-abi",
+ "alloy-network",
+ "alloy-network-primitives",
+ "alloy-primitives",
+ "alloy-provider",
+ "alloy-rpc-types-eth",
+ "alloy-sol-types",
+ "alloy-transport",
+ "futures",
+ "futures-util",
+ "serde_json",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-dyn-abi"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "369f5707b958927176265e8a58627fc6195e5dfa5c55689396e68b241b3a72e6"
+dependencies = [
+ "alloy-json-abi",
+ "alloy-primitives",
+ "alloy-sol-type-parser",
+ "alloy-sol-types",
+ "itoa",
+ "serde",
+ "serde_json",
+ "winnow 0.7.14",
+]
+
+[[package]]
+name = "alloy-eip2124"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "741bdd7499908b3aa0b159bba11e71c8cddd009a2c2eb7a06e825f1ec87900a5"
+dependencies = [
+ "alloy-primitives",
+ "alloy-rlp",
+ "crc",
+ "serde",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-eip2930"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9441120fa82df73e8959ae0e4ab8ade03de2aaae61be313fbf5746277847ce25"
+dependencies = [
+ "alloy-primitives",
+ "alloy-rlp",
+ "borsh",
+ "serde",
+]
+
+[[package]]
+name = "alloy-eip7702"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2919c5a56a1007492da313e7a3b6d45ef5edc5d33416fdec63c0d7a2702a0d20"
+dependencies = [
+ "alloy-primitives",
+ "alloy-rlp",
+ "borsh",
+ "serde",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-eips"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09535cbc646b0e0c6fcc12b7597eaed12cf86dff4c4fba9507a61e71b94f30eb"
+dependencies = [
+ "alloy-eip2124",
+ "alloy-eip2930",
+ "alloy-eip7702",
+ "alloy-primitives",
+ "alloy-rlp",
+ "alloy-serde",
+ "auto_impl",
+ "borsh",
+ "c-kzg",
+ "derive_more 2.1.1",
+ "either",
+ "serde",
+ "serde_with",
+ "sha2 0.10.9",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-json-abi"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84e3cf01219c966f95a460c95f1d4c30e12f6c18150c21a30b768af2a2a29142"
+dependencies = [
+ "alloy-primitives",
+ "alloy-sol-type-parser",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "alloy-json-rpc"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b626409c98ba43aaaa558361bca21440c88fd30df7542c7484b9c7a1489cdb"
+dependencies = [
+ "alloy-primitives",
+ "alloy-sol-types",
+ "http 1.4.0",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tracing",
+]
+
+[[package]]
+name = "alloy-network"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "89924fdcfeee0e0fa42b1f10af42f92802b5d16be614a70897382565663bf7cf"
+dependencies = [
+ "alloy-consensus",
+ "alloy-consensus-any",
+ "alloy-eips",
+ "alloy-json-rpc",
+ "alloy-network-primitives",
+ "alloy-primitives",
+ "alloy-rpc-types-any",
+ "alloy-rpc-types-eth",
+ "alloy-serde",
+ "alloy-signer",
+ "alloy-sol-types",
+ "async-trait",
+ "auto_impl",
+ "derive_more 2.1.1",
+ "futures-utils-wasm",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-network-primitives"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0f0dbe56ff50065713ff8635d8712a0895db3ad7f209db9793ad8fcb6b1734aa"
+dependencies = [
+ "alloy-consensus",
+ "alloy-eips",
+ "alloy-primitives",
+ "alloy-serde",
+ "serde",
+]
+
+[[package]]
+name = "alloy-primitives"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6a0fb18dd5fb43ec5f0f6a20be1ce0287c79825827de5744afaa6c957737c33"
+dependencies = [
+ "alloy-rlp",
+ "bytes",
+ "cfg-if",
+ "const-hex",
+ "derive_more 2.1.1",
+ "foldhash 0.2.0",
+ "hashbrown 0.16.1",
+ "indexmap 2.13.0",
+ "itoa",
+ "k256",
+ "keccak-asm",
+ "paste",
+ "proptest",
+ "rand 0.9.2",
+ "rapidhash 4.2.1",
+ "ruint",
+ "rustc-hash",
+ "serde",
+ "sha3 0.10.8",
+ "tiny-keccak",
+]
+
+[[package]]
+name = "alloy-provider"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b56f7a77513308a21a2ba0e9d57785a9d9d2d609e77f4e71a78a1192b83ff2d"
+dependencies = [
+ "alloy-chains",
+ "alloy-consensus",
+ "alloy-eips",
+ "alloy-json-rpc",
+ "alloy-network",
+ "alloy-network-primitives",
+ "alloy-primitives",
+ "alloy-rpc-client",
+ "alloy-rpc-types-eth",
+ "alloy-signer",
+ "alloy-sol-types",
+ "alloy-transport",
+ "alloy-transport-http",
+ "async-stream",
+ "async-trait",
+ "auto_impl",
+ "dashmap 6.1.0",
+ "either",
+ "futures",
+ "futures-utils-wasm",
+ "lru",
+ "parking_lot",
+ "pin-project",
+ "reqwest 0.12.28",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tokio",
+ "tracing",
+ "url",
+ "wasmtimer",
+]
+
+[[package]]
+name = "alloy-rlp"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f70d83b765fdc080dbcd4f4db70d8d23fe4761f2f02ebfa9146b833900634b4"
+dependencies = [
+ "alloy-rlp-derive",
+ "arrayvec 0.7.6",
+ "bytes",
+]
+
+[[package]]
+name = "alloy-rlp-derive"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64b728d511962dda67c1bc7ea7c03736ec275ed2cf4c35d9585298ac9ccf3b73"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "alloy-rpc-client"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff01723afc25ec4c5b04de399155bef7b6a96dfde2475492b1b7b4e7a4f46445"
+dependencies = [
+ "alloy-json-rpc",
+ "alloy-primitives",
+ "alloy-transport",
+ "alloy-transport-http",
+ "futures",
+ "pin-project",
+ "reqwest 0.12.28",
+ "serde",
+ "serde_json",
+ "tokio",
+ "tokio-stream",
+ "tower 0.5.3",
+ "tracing",
+ "url",
+ "wasmtimer",
+]
+
+[[package]]
+name = "alloy-rpc-types-any"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "212ca1c1dab27f531d3858f8b1a2d6bfb2da664be0c1083971078eb7b71abe4b"
+dependencies = [
+ "alloy-consensus-any",
+ "alloy-rpc-types-eth",
+ "alloy-serde",
+]
+
+[[package]]
+name = "alloy-rpc-types-eth"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5715d0bf7efbd360873518bd9f6595762136b5327a9b759a8c42ccd9b5e44945"
+dependencies = [
+ "alloy-consensus",
+ "alloy-consensus-any",
+ "alloy-eips",
+ "alloy-network-primitives",
+ "alloy-primitives",
+ "alloy-rlp",
+ "alloy-serde",
+ "alloy-sol-types",
+ "itertools 0.14.0",
+ "serde",
+ "serde_json",
+ "serde_with",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-serde"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5ed8531cae8d21ee1c6571d0995f8c9f0652a6ef6452fde369283edea6ab7138"
+dependencies = [
+ "alloy-primitives",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "alloy-signer"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fb10ccd49d0248df51063fce6b716f68a315dd912d55b32178c883fd48b4021d"
+dependencies = [
+ "alloy-primitives",
+ "async-trait",
+ "auto_impl",
+ "either",
+ "elliptic-curve",
+ "k256",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-signer-local"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4d992d44e6c414ece580294abbadb50e74cfd4eaa69787350a4dfd4b20eaa1b"
+dependencies = [
+ "alloy-consensus",
+ "alloy-network",
+ "alloy-primitives",
+ "alloy-signer",
+ "async-trait",
+ "k256",
+ "rand 0.8.5",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "alloy-sol-macro"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09eb18ce0df92b4277291bbaa0ed70545d78b02948df756bbd3d6214bf39a218"
+dependencies = [
+ "alloy-sol-macro-expander",
+ "alloy-sol-macro-input",
+ "proc-macro-error2",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "alloy-sol-macro-expander"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95d9fa2daf21f59aa546d549943f10b5cce1ae59986774019fbedae834ffe01b"
+dependencies = [
+ "alloy-json-abi",
+ "alloy-sol-macro-input",
+ "const-hex",
+ "heck 0.5.0",
+ "indexmap 2.13.0",
+ "proc-macro-error2",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+ "syn-solidity",
+ "tiny-keccak",
+]
+
+[[package]]
+name = "alloy-sol-macro-input"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9396007fe69c26ee118a19f4dee1f5d1d6be186ea75b3881adf16d87f8444686"
+dependencies = [
+ "alloy-json-abi",
+ "const-hex",
+ "dunce",
+ "heck 0.5.0",
+ "macro-string",
+ "proc-macro2",
+ "quote",
+ "serde_json",
+ "syn 2.0.114",
+ "syn-solidity",
+]
+
+[[package]]
+name = "alloy-sol-type-parser"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af67a0b0dcebe14244fc92002cd8d96ecbf65db4639d479f5fcd5805755a4c27"
+dependencies = [
+ "serde",
+ "winnow 0.7.14",
+]
+
+[[package]]
+name = "alloy-sol-types"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09aeea64f09a7483bdcd4193634c7e5cf9fd7775ee767585270cd8ce2d69dc95"
+dependencies = [
+ "alloy-json-abi",
+ "alloy-primitives",
+ "alloy-sol-macro",
+ "serde",
+]
+
+[[package]]
+name = "alloy-transport"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f50a9516736d22dd834cc2240e5bf264f338667cc1d9e514b55ec5a78b987ca"
+dependencies = [
+ "alloy-json-rpc",
+ "auto_impl",
+ "base64 0.22.1",
+ "derive_more 2.1.1",
+ "futures",
+ "futures-utils-wasm",
+ "governor 0.8.1",
+ "parking_lot",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tokio",
+ "tower 0.5.3",
+ "tracing",
+ "url",
+ "wasmtimer",
+]
+
+[[package]]
+name = "alloy-transport-http"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0a18b541a6197cf9a084481498a766fdf32fefda0c35ea6096df7d511025e9f1"
+dependencies = [
+ "alloy-json-rpc",
+ "alloy-transport",
+ "opentelemetry",
+ "opentelemetry-http",
+ "reqwest 0.12.28",
+ "serde_json",
+ "tower 0.5.3",
+ "tracing",
+ "tracing-opentelemetry",
+ "url",
+]
+
+[[package]]
+name = "alloy-trie"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "428aa0f0e0658ff091f8f667c406e034b431cb10abd39de4f507520968acc499"
+dependencies = [
+ "alloy-primitives",
+ "alloy-rlp",
+ "arrayvec 0.7.6",
+ "derive_more 2.1.1",
+ "nybbles",
+ "serde",
+ "smallvec",
+ "tracing",
+]
+
+[[package]]
+name = "alloy-tx-macros"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b2289a842d02fe63f8c466db964168bb2c7a9fdfb7b24816dbb17d45520575fb"
+dependencies = [
+ "darling 0.21.3",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ambassador"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e68de4cdc6006162265d0957edb4a860fe4e711b1dc17a5746fd95f952f08285"
+dependencies = [
+ "itertools 0.10.5",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "ansi_term"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
+dependencies = [
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "anstream"
+version = "0.6.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is_terminal_polyfill",
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle"
+version = "1.0.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"
+
+[[package]]
+name = "anstyle-parse"
+version = "0.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
+dependencies = [
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "3.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
+dependencies = [
+ "anstyle",
+ "once_cell_polyfill",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "anyhow"
+version = "1.0.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"
+
+[[package]]
+name = "aptos-aggregator"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-types",
+ "bcs 0.1.4",
+ "claims",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-types",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-api-types"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-config",
+ "aptos-crypto",
+ "aptos-logger",
+ "aptos-openapi",
+ "aptos-resource-viewer",
+ "aptos-storage-interface",
+ "aptos-types",
+ "aptos-vm",
+ "async-trait",
+ "bcs 0.1.4",
+ "bytes",
+ "hex",
+ "indoc",
+ "move-binary-format",
+ "move-core-types",
+ "once_cell",
+ "poem",
+ "poem-openapi",
+ "poem-openapi-derive",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "aptos-bitvec"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "serde",
+ "serde_bytes",
+]
+
+[[package]]
+name = "aptos-block-executor"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "ambassador",
+ "anyhow",
+ "aptos-aggregator",
+ "aptos-crypto",
+ "aptos-drop-helper",
+ "aptos-gas-schedule",
+ "aptos-infallible",
+ "aptos-logger",
+ "aptos-metrics-core",
+ "aptos-mvhashmap",
+ "aptos-types",
+ "aptos-vm-environment",
+ "aptos-vm-logging",
+ "aptos-vm-types",
+ "arc-swap",
+ "bcs 0.1.4",
+ "bytes",
+ "cfg-if",
+ "claims",
+ "concurrent-queue",
+ "crossbeam",
+ "dashmap 7.0.0-rc2",
+ "derivative",
+ "fail",
+ "hashbrown 0.14.5",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "num_cpus",
+ "once_cell",
+ "parking_lot",
+ "rand 0.7.3",
+ "rayon",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-config"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-crypto",
+ "aptos-global-constants",
+ "aptos-logger",
+ "aptos-secure-storage",
+ "aptos-short-hex-str",
+ "aptos-temppath",
+ "aptos-transaction-filters",
+ "aptos-types",
+ "arr_macro",
+ "bcs 0.1.4",
+ "byteorder",
+ "cfg-if",
+ "get_if_addrs",
+ "maplit",
+ "num_cpus",
+ "poem-openapi",
+ "rand 0.7.3",
+ "serde",
+ "serde_json",
+ "serde_merge",
+ "serde_yaml 0.8.26",
+ "strum 0.27.2",
+ "strum_macros 0.27.2",
+ "thiserror 1.0.69",
+ "url",
+]
+
+[[package]]
+name = "aptos-crypto"
+version = "0.0.3"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aes-gcm",
+ "anyhow",
+ "aptos-crypto-derive",
+ "ark-bls12-381",
+ "ark-bn254",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-groth16",
+ "ark-poly",
+ "ark-relations",
+ "ark-serialize 0.5.0",
+ "ark-snark",
+ "ark-std 0.5.0",
+ "base64 0.13.1",
+ "bcs 0.1.4",
+ "bls12_381",
+ "blst",
+ "blstrs",
+ "bulletproofs",
+ "bytes",
+ "curve25519-dalek 3.2.0",
+ "curve25519-dalek-ng",
+ "digest 0.9.0",
+ "dudect-bencher",
+ "ed25519-dalek 1.0.1",
+ "ff",
+ "group",
+ "hex",
+ "hkdf",
+ "itertools 0.13.0",
+ "libsecp256k1",
+ "merlin",
+ "more-asserts",
+ "neptune",
+ "num-bigint 0.3.3",
+ "num-integer",
+ "num-traits",
+ "once_cell",
+ "p256",
+ "pairing",
+ "rand 0.7.3",
+ "rand_core 0.5.1",
+ "ring 0.16.20",
+ "serde",
+ "serde-name",
+ "serde_bytes",
+ "sha2 0.10.9",
+ "sha2 0.9.9",
+ "sha3 0.9.1",
+ "signature 2.2.0",
+ "static_assertions",
+ "thiserror 1.0.69",
+ "tiny-keccak",
+ "typenum",
+ "x25519-dalek",
+]
+
+[[package]]
+name = "aptos-crypto-derive"
+version = "0.0.3"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "aptos-dkg"
+version = "0.2.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-crypto",
+ "aptos-crypto-derive",
+ "aptos-runtimes",
+ "ark-bls12-381",
+ "ark-bn254",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-poly",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "bcs 0.1.4",
+ "blst",
+ "blstrs",
+ "criterion",
+ "derive_more 0.99.20",
+ "ff",
+ "group",
+ "hex",
+ "merlin",
+ "more-asserts",
+ "num-bigint 0.3.3",
+ "num-integer",
+ "num-traits",
+ "pairing",
+ "rand 0.7.3",
+ "rand_core 0.5.1",
+ "rayon",
+ "serde",
+ "serde_bytes",
+ "sha3 0.9.1",
+ "static_assertions",
+]
+
+[[package]]
+name = "aptos-drop-helper"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-infallible",
+ "aptos-metrics-core",
+ "once_cell",
+ "threadpool",
+]
+
+[[package]]
+name = "aptos-experimental-layered-map"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "ahash 0.8.12",
+ "aptos-crypto",
+ "aptos-drop-helper",
+ "aptos-infallible",
+ "aptos-metrics-core",
+ "bitvec",
+ "itertools 0.13.0",
+ "once_cell",
+]
+
+[[package]]
+name = "aptos-experimental-runtimes"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-runtimes",
+ "core_affinity",
+ "libc",
+ "num_cpus",
+ "once_cell",
+ "rayon",
+]
+
+[[package]]
+name = "aptos-framework"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-aggregator",
+ "aptos-crypto",
+ "aptos-gas-algebra",
+ "aptos-gas-schedule",
+ "aptos-move-stdlib",
+ "aptos-native-interface",
+ "aptos-sdk-builder",
+ "aptos-types",
+ "aptos-vm-types",
+ "ark-bls12-381",
+ "ark-bn254",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "bcs 0.1.4",
+ "better_any",
+ "blake2-rfc",
+ "bulletproofs",
+ "byteorder",
+ "clap 4.5.54",
+ "codespan-reporting",
+ "curve25519-dalek-ng",
+ "either",
+ "flate2",
+ "hex",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "libsecp256k1",
+ "log",
+ "merlin",
+ "move-binary-format",
+ "move-command-line-common",
+ "move-compiler-v2",
+ "move-core-types",
+ "move-docgen",
+ "move-model",
+ "move-package",
+ "move-prover",
+ "move-prover-boogie-backend",
+ "move-prover-bytecode-pipeline",
+ "move-prover-lab",
+ "move-stackless-bytecode",
+ "move-vm-runtime",
+ "move-vm-types",
+ "num-traits",
+ "once_cell",
+ "rand 0.7.3",
+ "rand_core 0.5.1",
+ "ripemd",
+ "serde",
+ "serde_bytes",
+ "sha2 0.10.9",
+ "sha2 0.9.9",
+ "sha3 0.9.1",
+ "siphasher 0.3.11",
+ "smallvec",
+ "tempfile",
+ "tiny-keccak",
+ "toml",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-gas-algebra"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "either",
+ "move-core-types",
+]
+
+[[package]]
+name = "aptos-gas-meter"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-algebra",
+ "aptos-gas-schedule",
+ "aptos-logger",
+ "aptos-types",
+ "aptos-vm-types",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-types",
+]
+
+[[package]]
+name = "aptos-gas-schedule"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-algebra",
+ "aptos-global-constants",
+ "move-core-types",
+ "move-vm-types",
+ "paste",
+ "rand 0.7.3",
+]
+
+[[package]]
+name = "aptos-global-constants"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+
+[[package]]
+name = "aptos-infallible"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+
+[[package]]
+name = "aptos-log-derive"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "aptos-logger"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-infallible",
+ "aptos-log-derive",
+ "backtrace",
+ "chrono",
+ "erased-serde",
+ "futures",
+ "hostname",
+ "once_cell",
+ "prometheus",
+ "serde",
+ "serde_json",
+ "strum 0.27.2",
+ "strum_macros 0.27.2",
+ "tokio",
+ "tracing",
+ "tracing-subscriber 0.3.22",
+]
+
+[[package]]
+name = "aptos-memory-usage-tracker"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-algebra",
+ "aptos-gas-meter",
+ "aptos-types",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-types",
+]
+
+[[package]]
+name = "aptos-metrics-core"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "once_cell",
+ "paste",
+ "prometheus",
+]
+
+[[package]]
+name = "aptos-move-stdlib"
+version = "0.1.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-schedule",
+ "aptos-native-interface",
+ "aptos-types",
+ "bcs 0.1.4",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "sha2 0.9.9",
+ "sha3 0.9.1",
+ "smallvec",
+]
+
+[[package]]
+name = "aptos-mvhashmap"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-aggregator",
+ "aptos-infallible",
+ "aptos-types",
+ "aptos-vm-types",
+ "bytes",
+ "claims",
+ "crossbeam",
+ "dashmap 7.0.0-rc2",
+ "equivalent",
+ "fail",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "serde",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-native-interface"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-algebra",
+ "aptos-gas-schedule",
+ "aptos-types",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "smallvec",
+]
+
+[[package]]
+name = "aptos-openapi"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "percent-encoding",
+ "poem",
+ "poem-openapi",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "aptos-protos"
+version = "1.3.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "pbjson",
+ "prost 0.13.5",
+ "serde",
+ "tonic 0.12.3",
+]
+
+[[package]]
+name = "aptos-resource-viewer"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-logger",
+ "aptos-types",
+ "aptos-vm",
+ "aptos-vm-environment",
+ "aptos-vm-logging",
+ "move-binary-format",
+ "move-bytecode-utils",
+ "move-core-types",
+ "move-resource-viewer",
+ "move-vm-runtime",
+ "move-vm-types",
+]
+
+[[package]]
+name = "aptos-rest-client"
+version = "0.0.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-api-types",
+ "aptos-crypto",
+ "aptos-infallible",
+ "aptos-logger",
+ "aptos-types",
+ "bcs 0.1.4",
+ "bytes",
+ "hex",
+ "move-core-types",
+ "reqwest 0.11.27",
+ "serde",
+ "serde_json",
+ "thiserror 1.0.69",
+ "tokio",
+ "url",
+]
+
+[[package]]
+name = "aptos-runtimes"
+version = "0.1.0"
+dependencies = [
+ "rayon",
+ "tokio",
+]
+
+[[package]]
+name = "aptos-scratchpad"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-crypto",
+ "aptos-drop-helper",
+ "aptos-infallible",
+ "aptos-metrics-core",
+ "aptos-types",
+ "aptos-vm",
+ "bitvec",
+ "dashmap 7.0.0-rc2",
+ "itertools 0.13.0",
+ "once_cell",
+ "rayon",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "aptos-sdk-builder"
+version = "0.2.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-types",
+ "bcs 0.1.4",
+ "clap 4.5.54",
+ "heck 0.4.1",
+ "move-core-types",
+ "once_cell",
+ "serde-generate",
+ "serde-reflection",
+ "serde_yaml 0.8.26",
+ "textwrap 0.15.2",
+]
+
+[[package]]
+name = "aptos-secure-net"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-logger",
+ "aptos-metrics-core",
+ "aptos-protos",
+ "bcs 0.1.4",
+ "crossbeam-channel",
+ "once_cell",
+ "serde",
+ "thiserror 1.0.69",
+ "tokio",
+ "tonic 0.12.3",
+ "tonic-reflection",
+]
+
+[[package]]
+name = "aptos-secure-storage"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-crypto",
+ "aptos-infallible",
+ "aptos-logger",
+ "aptos-temppath",
+ "aptos-time-service",
+ "aptos-vault-client",
+ "base64 0.13.1",
+ "bcs 0.1.4",
+ "chrono",
+ "enum_dispatch",
+ "rand 0.7.3",
+ "serde",
+ "serde_json",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "aptos-short-hex-str"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "mirai-annotations",
+ "serde",
+ "static_assertions",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "aptos-speculative-state-helper"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-infallible",
+ "crossbeam",
+ "rayon",
+]
+
+[[package]]
+name = "aptos-storage-interface"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-crypto",
+ "aptos-experimental-layered-map",
+ "aptos-logger",
+ "aptos-metrics-core",
+ "aptos-scratchpad",
+ "aptos-secure-net",
+ "aptos-types",
+ "arr_macro",
+ "bcs 0.1.4",
+ "dashmap 7.0.0-rc2",
+ "derive_more 0.99.20",
+ "itertools 0.13.0",
+ "once_cell",
+ "parking_lot",
+ "proptest",
+ "proptest-derive",
+ "rand 0.7.3",
+ "rayon",
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "aptos-table-natives"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-gas-schedule",
+ "aptos-native-interface",
+ "aptos-types",
+ "better_any",
+ "bytes",
+ "move-binary-format",
+ "move-core-types",
+ "move-table-extension",
+ "move-vm-runtime",
+ "move-vm-types",
+ "sha3 0.9.1",
+ "smallvec",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-temppath"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "hex",
+ "rand 0.7.3",
+]
+
+[[package]]
+name = "aptos-time-service"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-infallible",
+ "enum_dispatch",
+ "futures",
+ "pin-project",
+ "thiserror 1.0.69",
+ "tokio",
+]
+
+[[package]]
+name = "aptos-transaction-filters"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-crypto",
+ "aptos-types",
+ "move-core-types",
+ "rand 0.7.3",
+ "serde",
+ "serde_yaml 0.8.26",
+]
+
+[[package]]
+name = "aptos-types"
+version = "0.0.3"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-bitvec",
+ "aptos-crypto",
+ "aptos-crypto-derive",
+ "aptos-dkg",
+ "aptos-infallible",
+ "ark-bn254",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-groth16",
+ "ark-relations",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "base64 0.13.1",
+ "bcs 0.1.4",
+ "bytes",
+ "chrono",
+ "chrono-tz 0.10.4",
+ "dashmap 7.0.0-rc2",
+ "derivative",
+ "fixed",
+ "fxhash",
+ "hashbrown 0.14.5",
+ "hex",
+ "itertools 0.13.0",
+ "jsonwebtoken",
+ "lru",
+ "move-binary-format",
+ "move-core-types",
+ "move-model",
+ "move-table-extension",
+ "move-vm-types",
+ "num-bigint 0.3.3",
+ "num-derive",
+ "num-traits",
+ "once_cell",
+ "passkey-types",
+ "poem-openapi",
+ "poem-openapi-derive",
+ "quick_cache",
+ "rand 0.7.3",
+ "rapidhash 1.4.0",
+ "rayon",
+ "ref-cast",
+ "ring 0.16.20",
+ "rsa",
+ "serde",
+ "serde-big-array",
+ "serde_bytes",
+ "serde_json",
+ "serde_with",
+ "serde_yaml 0.8.26",
+ "strum 0.27.2",
+ "strum_macros 0.27.2",
+ "thiserror 1.0.69",
+ "tracing",
+]
+
+[[package]]
+name = "aptos-vault-client"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-crypto",
+ "base64 0.13.1",
+ "chrono",
+ "native-tls",
+ "once_cell",
+ "serde",
+ "serde_json",
+ "thiserror 1.0.69",
+ "ureq",
+]
+
+[[package]]
+name = "aptos-vm"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "aptos-aggregator",
+ "aptos-block-executor",
+ "aptos-crypto",
+ "aptos-crypto-derive",
+ "aptos-experimental-runtimes",
+ "aptos-framework",
+ "aptos-gas-algebra",
+ "aptos-gas-meter",
+ "aptos-gas-schedule",
+ "aptos-logger",
+ "aptos-memory-usage-tracker",
+ "aptos-metrics-core",
+ "aptos-mvhashmap",
+ "aptos-native-interface",
+ "aptos-table-natives",
+ "aptos-types",
+ "aptos-vm-environment",
+ "aptos-vm-logging",
+ "aptos-vm-types",
+ "ark-bn254",
+ "ark-groth16",
+ "bcs 0.1.4",
+ "bytes",
+ "claims",
+ "crossbeam-channel",
+ "derive_more 0.99.20",
+ "fail",
+ "futures",
+ "hex",
+ "itertools 0.13.0",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-metrics",
+ "move-vm-runtime",
+ "move-vm-types",
+ "num_cpus",
+ "once_cell",
+ "ouroboros",
+ "rand 0.7.3",
+ "rayon",
+ "serde",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-vm-environment"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-framework",
+ "aptos-gas-algebra",
+ "aptos-gas-schedule",
+ "aptos-move-stdlib",
+ "aptos-native-interface",
+ "aptos-table-natives",
+ "aptos-types",
+ "aptos-vm-types",
+ "ark-bn254",
+ "ark-groth16",
+ "bcs 0.1.4",
+ "move-binary-format",
+ "move-bytecode-verifier",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "once_cell",
+ "sha3 0.9.1",
+ "triomphe",
+]
+
+[[package]]
+name = "aptos-vm-logging"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "aptos-crypto",
+ "aptos-logger",
+ "aptos-metrics-core",
+ "aptos-speculative-state-helper",
+ "aptos-types",
+ "arc-swap",
+ "once_cell",
+ "serde",
+]
+
+[[package]]
+name = "aptos-vm-types"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "ambassador",
+ "anyhow",
+ "aptos-aggregator",
+ "aptos-gas-algebra",
+ "aptos-gas-schedule",
+ "aptos-types",
+ "bcs 0.1.4",
+ "bytes",
+ "claims",
+ "derivative",
+ "either",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "rand 0.7.3",
+ "serde",
+ "triomphe",
+]
+
+[[package]]
+name = "arc-swap"
+version = "1.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51d03449bb8ca2cc2ef70869af31463d1ae5ccc8fa3e334b307203fbf815207e"
+dependencies = [
+ "rustversion",
+]
+
+[[package]]
+name = "ark-bls12-381"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3df4dcc01ff89867cd86b0da835f23c3f02738353aaee7dde7495af71363b8d5"
+dependencies = [
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+]
+
+[[package]]
+name = "ark-bn254"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d69eab57e8d2663efa5c63135b2af4f396d66424f88954c21104125ab6b3e6bc"
+dependencies = [
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-std 0.5.0",
+]
+
+[[package]]
+name = "ark-crypto-primitives"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e0c292754729c8a190e50414fd1a37093c786c709899f29c9f7daccecfa855e"
+dependencies = [
+ "ahash 0.8.12",
+ "ark-crypto-primitives-macros",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-relations",
+ "ark-serialize 0.5.0",
+ "ark-snark",
+ "ark-std 0.5.0",
+ "blake2",
+ "derivative",
+ "digest 0.10.7",
+ "fnv",
+ "merlin",
+ "rayon",
+ "sha2 0.10.9",
+]
+
+[[package]]
+name = "ark-crypto-primitives-macros"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7e89fe77d1f0f4fe5b96dfc940923d88d17b6a773808124f21e764dfb063c6a"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ark-ec"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43d68f2d516162846c1238e755a7c4d131b892b70cc70c471a8e3ca3ed818fce"
+dependencies = [
+ "ahash 0.8.12",
+ "ark-ff 0.5.0",
+ "ark-poly",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "educe",
+ "fnv",
+ "hashbrown 0.15.2",
+ "itertools 0.13.0",
+ "num-bigint 0.4.6",
+ "num-integer",
+ "num-traits",
+ "rayon",
+ "zeroize",
+]
+
+[[package]]
+name = "ark-ff"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6b3235cc41ee7a12aaaf2c575a2ad7b46713a8a50bda2fc3b003a04845c05dd6"
+dependencies = [
+ "ark-ff-asm 0.3.0",
+ "ark-ff-macros 0.3.0",
+ "ark-serialize 0.3.0",
+ "ark-std 0.3.0",
+ "derivative",
+ "num-bigint 0.4.6",
+ "num-traits",
+ "paste",
+ "rustc_version 0.3.3",
+ "zeroize",
+]
+
+[[package]]
+name = "ark-ff"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec847af850f44ad29048935519032c33da8aa03340876d351dfab5660d2966ba"
+dependencies = [
+ "ark-ff-asm 0.4.2",
+ "ark-ff-macros 0.4.2",
+ "ark-serialize 0.4.2",
+ "ark-std 0.4.0",
+ "derivative",
+ "digest 0.10.7",
+ "itertools 0.10.5",
+ "num-bigint 0.4.6",
+ "num-traits",
+ "paste",
+ "rustc_version 0.4.1",
+ "zeroize",
+]
+
+[[package]]
+name = "ark-ff"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a177aba0ed1e0fbb62aa9f6d0502e9b46dad8c2eab04c14258a1212d2557ea70"
+dependencies = [
+ "ark-ff-asm 0.5.0",
+ "ark-ff-macros 0.5.0",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "arrayvec 0.7.6",
+ "digest 0.10.7",
+ "educe",
+ "itertools 0.13.0",
+ "num-bigint 0.4.6",
+ "num-traits",
+ "paste",
+ "rayon",
+ "zeroize",
+]
+
+[[package]]
+name = "ark-ff-asm"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db02d390bf6643fb404d3d22d31aee1c4bc4459600aef9113833d17e786c6e44"
+dependencies = [
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "ark-ff-asm"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3ed4aa4fe255d0bc6d79373f7e31d2ea147bcf486cba1be5ba7ea85abdb92348"
+dependencies = [
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "ark-ff-asm"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62945a2f7e6de02a31fe400aa489f0e0f5b2502e69f95f853adb82a96c7a6b60"
+dependencies = [
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ark-ff-macros"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db2fd794a08ccb318058009eefdf15bcaaaaf6f8161eb3345f907222bac38b20"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-traits",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "ark-ff-macros"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7abe79b0e4288889c4574159ab790824d0033b9fdcb2a112a3182fac2e514565"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-traits",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "ark-ff-macros"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09be120733ee33f7693ceaa202ca41accd5653b779563608f1234f78ae07c4b3"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-traits",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ark-groth16"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88f1d0f3a534bb54188b8dcc104307db6c56cdae574ddc3212aec0625740fc7e"
+dependencies = [
+ "ark-crypto-primitives",
+ "ark-ec",
+ "ark-ff 0.5.0",
+ "ark-poly",
+ "ark-relations",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "rayon",
+]
+
+[[package]]
+name = "ark-poly"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "579305839da207f02b89cd1679e50e67b4331e2f9294a57693e5051b7703fe27"
+dependencies = [
+ "ahash 0.8.12",
+ "ark-ff 0.5.0",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+ "educe",
+ "fnv",
+ "hashbrown 0.15.2",
+ "rayon",
+]
+
+[[package]]
+name = "ark-relations"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec46ddc93e7af44bcab5230937635b06fb5744464dd6a7e7b083e80ebd274384"
+dependencies = [
+ "ark-ff 0.5.0",
+ "ark-std 0.5.0",
+ "tracing",
+ "tracing-subscriber 0.2.25",
+]
+
+[[package]]
+name = "ark-serialize"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d6c2b318ee6e10f8c2853e73a83adc0ccb88995aa978d8a3408d492ab2ee671"
+dependencies = [
+ "ark-std 0.3.0",
+ "digest 0.9.0",
+]
+
+[[package]]
+name = "ark-serialize"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "adb7b85a02b83d2f22f89bd5cac66c9c89474240cb6207cb1efc16d098e822a5"
+dependencies = [
+ "ark-std 0.4.0",
+ "digest 0.10.7",
+ "num-bigint 0.4.6",
+]
+
+[[package]]
+name = "ark-serialize"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f4d068aaf107ebcd7dfb52bc748f8030e0fc930ac8e360146ca54c1203088f7"
+dependencies = [
+ "ark-serialize-derive",
+ "ark-std 0.5.0",
+ "arrayvec 0.7.6",
+ "digest 0.10.7",
+ "num-bigint 0.4.6",
+ "rayon",
+]
+
+[[package]]
+name = "ark-serialize-derive"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "213888f660fddcca0d257e88e54ac05bca01885f258ccdf695bafd77031bb69d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ark-snark"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d368e2848c2d4c129ce7679a7d0d2d612b6a274d3ea6a13bad4445d61b381b88"
+dependencies = [
+ "ark-ff 0.5.0",
+ "ark-relations",
+ "ark-serialize 0.5.0",
+ "ark-std 0.5.0",
+]
+
+[[package]]
+name = "ark-std"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1df2c09229cbc5a028b1d70e00fdb2acee28b1055dfb5ca73eea49c5a25c4e7c"
+dependencies = [
+ "num-traits",
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "ark-std"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94893f1e0c6eeab764ade8dc4c0db24caf4fe7cbbaafc0eba0a9030f447b5185"
+dependencies = [
+ "num-traits",
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "ark-std"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "246a225cc6131e9ee4f24619af0f19d67761fff15d7ccc22e42b80846e69449a"
+dependencies = [
+ "num-traits",
+ "rand 0.8.5",
+ "rayon",
+]
+
+[[package]]
+name = "arr_macro"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c49336e062fa2ae8aca17a2f99c34d9c1a5d30827e8aff1cb4c294f253afe992"
+dependencies = [
+ "arr_macro_impl",
+ "proc-macro-hack",
+ "proc-macro-nested",
+]
+
+[[package]]
+name = "arr_macro_impl"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c6368f9ae5c6ec403ca910327ae0c9437b0a85255b6950c90d497e6177f6e5e"
+dependencies = [
+ "proc-macro-hack",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "arrayref"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"
+
+[[package]]
+name = "arrayvec"
+version = "0.4.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd9fd44efafa8690358b7408d253adf110036b88f55672a933f01d616ad9b1b9"
+dependencies = [
+ "nodrop",
+]
+
+[[package]]
+name = "arrayvec"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b"
+
+[[package]]
+name = "arrayvec"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "ascii"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eab1c04a571841102f5345a8fc0f6bb3d31c315dec879b5c6e42e40ce7ffa34e"
+
+[[package]]
+name = "asn1-rs"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f6fd5ddaf0351dff5b8da21b2fb4ff8e08ddd02857f0bf69c47639106c0fff0"
+dependencies = [
+ "asn1-rs-derive",
+ "asn1-rs-impl",
+ "displaydoc",
+ "nom",
+ "num-traits",
+ "rusticata-macros",
+ "thiserror 1.0.69",
+ "time",
+]
+
+[[package]]
+name = "asn1-rs-derive"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "726535892e8eae7e70657b4c8ea93d26b8553afb1ce617caee529ef96d7dee6c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+ "synstructure 0.12.6",
+]
+
+[[package]]
+name = "asn1-rs-impl"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2777730b2039ac0f95f093556e61b6d26cebed5393ca6f152717777cec3a42ed"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "assert-json-diff"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "47e4f2b81832e72834d7518d8487a0396a28cc408186a2e8854c0f98011faf12"
+dependencies = [
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "async-compression"
+version = "0.4.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d10e4f991a553474232bc0a31799f6d24b034a84c0971d80d2e2f78b2e576e40"
+dependencies = [
+ "compression-codecs",
+ "compression-core",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "async-lock"
+version = "3.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "290f7f2596bd5b78a9fec8088ccd89180d7f9f55b94b0576823bbbdc72ee8311"
+dependencies = [
+ "event-listener",
+ "event-listener-strategy",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-stream"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
+dependencies = [
+ "async-stream-impl",
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-stream-impl"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "async-trait"
+version = "0.1.89"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "atomic-waker"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"
+
+[[package]]
+name = "atty"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
+dependencies = [
+ "hermit-abi 0.1.19",
+ "libc",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "auto_impl"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffdcb70bdbc4d478427380519163274ac86e52916e10f0a8889adf0f96d3fee7"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "autocfg"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"
+
+[[package]]
+name = "aws-lc-rs"
+version = "1.15.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e84ce723ab67259cfeb9877c6a639ee9eb7a27b28123abd71db7f0d5d0cc9d86"
+dependencies = [
+ "aws-lc-sys",
+ "zeroize",
+]
+
+[[package]]
+name = "aws-lc-sys"
+version = "0.36.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43a442ece363113bd4bd4c8b18977a7798dd4d3c3383f34fb61936960e8f4ad8"
+dependencies = [
+ "cc",
+ "cmake",
+ "dunce",
+ "fs_extra",
+]
+
+[[package]]
+name = "axum"
+version = "0.7.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "edca88bc138befd0323b20752846e6587272d3b03b0343c8ea28a6f819e6e71f"
+dependencies = [
+ "async-trait",
+ "axum-core 0.4.5",
+ "bytes",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "itoa",
+ "matchit 0.7.3",
+ "memchr",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustversion",
+ "serde",
+ "sync_wrapper 1.0.2",
+ "tower 0.5.3",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "axum"
+version = "0.8.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b52af3cb4058c895d37317bb27508dccc8e5f2d39454016b297bf4a400597b8"
+dependencies = [
+ "axum-core 0.5.6",
+ "bytes",
+ "form_urlencoded",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-util",
+ "itoa",
+ "matchit 0.8.4",
+ "memchr",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "serde_core",
+ "serde_json",
+ "serde_path_to_error",
+ "serde_urlencoded",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tower 0.5.3",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "axum-core"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09f2bd6146b97ae3359fa0cc6d6b376d9539582c7b4220f041a33ec24c226199"
+dependencies = [
+ "async-trait",
+ "bytes",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "mime",
+ "pin-project-lite",
+ "rustversion",
+ "sync_wrapper 1.0.2",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "axum-core"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08c78f31d7b1291f7ee735c1c6780ccde7785daae9a9206026862dab7d8792d1"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "mime",
+ "pin-project-lite",
+ "sync_wrapper 1.0.2",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "az"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be5eb007b7cacc6c660343e96f650fedf4b5a77512399eb952ca6642cf8d13f7"
+
+[[package]]
+name = "backtrace"
+version = "0.3.76"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb531853791a215d7c62a30daf0dde835f381ab5de4589cfe7c649d2cbe92bd6"
+dependencies = [
+ "addr2line",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+ "windows-link",
+]
+
+[[package]]
+name = "base16ct"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c7f02d4ea65f2c1853089ffd8d2787bdbc63de2f0d29dedbcf8ccdfa0ccd4cf"
+
+[[package]]
+name = "base64"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
+
+[[package]]
+name = "base64"
+version = "0.21.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
+
+[[package]]
+name = "base64"
+version = "0.22.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"
+
+[[package]]
+name = "base64ct"
+version = "1.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2af50177e190e07a26ab74f8b1efbfe2ef87da2116221318cb1c2e82baf7de06"
+
+[[package]]
+name = "bcs"
+version = "0.1.4"
+source = "git+https://github.com/aptos-labs/bcs.git?rev=d31fab9d81748e2594be5cd5cdf845786a30562d#d31fab9d81748e2594be5cd5cdf845786a30562d"
+dependencies = [
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "bcs"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85b6598a2f5d564fb7855dc6b06fd1c38cff5a72bd8b863a4d021938497b440a"
+dependencies = [
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "bellpepper"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ae286c2cb403324ab644c7cc68dceb25fe52ca9429908a726d7ed272c1edf7b"
+dependencies = [
+ "bellpepper-core",
+ "byteorder",
+ "ff",
+]
+
+[[package]]
+name = "bellpepper-core"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d8abb418570756396d722841b19edfec21d4e89e1cf8990610663040ecb1aea"
+dependencies = [
+ "blake2s_simd",
+ "byteorder",
+ "ff",
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "better_any"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b359aebd937c17c725e19efcb661200883f04c49c53e7132224dac26da39d4a0"
+dependencies = [
+ "better_typeid_derive",
+]
+
+[[package]]
+name = "better_typeid_derive"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3deeecb812ca5300b7d3f66f730cc2ebd3511c3d36c691dd79c165d5b19a26e3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "bincode"
+version = "1.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1f45e9417d87227c7a56d22e471c6206462cba514c7590c09aff4cf6d1ddcad"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "bit-set"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
+dependencies = [
+ "bit-vec",
+]
+
+[[package]]
+name = "bit-vec"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"
+
+[[package]]
+name = "bitcoin-io"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dee39a0ee5b4095224a0cfc6bf4cc1baf0f9624b96b367e53b66d974e51d953"
+
+[[package]]
+name = "bitcoin_hashes"
+version = "0.14.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26ec84b80c482df901772e931a9a681e26a1b9ee2302edeff23cb30328745c8b"
+dependencies = [
+ "bitcoin-io",
+ "hex-conservative",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "bitflags"
+version = "2.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"
+dependencies = [
+ "serde_core",
+]
+
+[[package]]
+name = "bitmaps"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "031043d04099746d8db04daf1fa424b2bc8bd69d92b25962dcde24da39ab64a2"
+dependencies = [
+ "typenum",
+]
+
+[[package]]
+name = "bitvec"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
+dependencies = [
+ "funty",
+ "radium",
+ "tap",
+ "wyz",
+]
+
+[[package]]
+name = "blake2"
+version = "0.10.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe"
+dependencies = [
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "blake2-rfc"
+version = "0.2.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d6d530bdd2d52966a6d03b7a964add7ae1a288d25214066fd4b600f0f796400"
+dependencies = [
+ "arrayvec 0.4.12",
+ "constant_time_eq 0.1.5",
+]
+
+[[package]]
+name = "blake2b_simd"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b79834656f71332577234b50bfc009996f7449e0c056884e6a02492ded0ca2f3"
+dependencies = [
+ "arrayref",
+ "arrayvec 0.7.6",
+ "constant_time_eq 0.4.2",
+]
+
+[[package]]
+name = "blake2s_simd"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ee29928bad1e3f94c9d1528da29e07a1d3d04817ae8332de1e8b846c8439f4b3"
+dependencies = [
+ "arrayref",
+ "arrayvec 0.7.6",
+ "constant_time_eq 0.4.2",
+]
+
+[[package]]
+name = "block-buffer"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4"
+dependencies = [
+ "block-padding",
+ "generic-array",
+]
+
+[[package]]
+name = "block-buffer"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "block-padding"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8d696c370c750c948ada61c69a0ee2cbbb9c50b1019ddb86d9317157a99c2cae"
+
+[[package]]
+name = "block2"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cdeb9d870516001442e364c5220d3574d2da8dc765554b4a617230d33fa58ef5"
+dependencies = [
+ "objc2",
+]
+
+[[package]]
+name = "bls12_381"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7bc6d6292be3a19e6379786dac800f551e5865a5bb51ebbe3064ab80433f403"
+dependencies = [
+ "ff",
+ "group",
+ "pairing",
+ "rand_core 0.6.4",
+ "subtle",
+]
+
+[[package]]
+name = "blst"
+version = "0.3.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcdb4c7013139a150f9fc55d123186dbfaba0d912817466282c73ac49e71fb45"
+dependencies = [
+ "cc",
+ "glob",
+ "threadpool",
+ "zeroize",
+]
+
+[[package]]
+name = "blstrs"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a8a8ed6fefbeef4a8c7b460e4110e12c5e22a5b7cf32621aae6ad650c4dcf29"
+dependencies = [
+ "blst",
+ "byte-slice-cast",
+ "ff",
+ "group",
+ "pairing",
+ "rand_core 0.6.4",
+ "serde",
+ "subtle",
+]
+
+[[package]]
+name = "borsh"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d1da5ab77c1437701eeff7c88d968729e7766172279eab0676857b3d63af7a6f"
+dependencies = [
+ "borsh-derive",
+ "cfg_aliases",
+]
+
+[[package]]
+name = "borsh-derive"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0686c856aa6aac0c4498f936d7d6a02df690f614c03e4d906d1018062b5c5e2c"
+dependencies = [
+ "once_cell",
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "brotli"
+version = "8.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bd8b9603c7aa97359dbd97ecf258968c95f3adddd6db2f7e7a5bef101c84560"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+ "brotli-decompressor",
+]
+
+[[package]]
+name = "brotli-decompressor"
+version = "5.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "874bb8112abecc98cbd6d81ea4fa7e94fb9449648c93cc89aa40c81c24d7de03"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+]
+
+[[package]]
+name = "bs58"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf88ba1141d185c399bee5288d850d63b8369520c1eafc32a0430b5b6c287bf4"
+dependencies = [
+ "tinyvec",
+]
+
+[[package]]
+name = "bstr"
+version = "1.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63044e1ae8e69f3b5a92c736ca6269b8d12fa7efe39bf34ddb06d102cf0e2cab"
+dependencies = [
+ "memchr",
+ "serde",
+]
+
+[[package]]
+name = "bulletproofs"
+version = "4.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "40e698f1df446cc6246afd823afbe2d121134d089c9102c1dd26d1264991ba32"
+dependencies = [
+ "byteorder",
+ "clear_on_drop",
+ "curve25519-dalek-ng",
+ "digest 0.9.0",
+ "merlin",
+ "rand 0.8.5",
+ "rand_core 0.6.4",
+ "serde",
+ "serde_derive",
+ "sha3 0.9.1",
+ "subtle-ng",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "bumpalo"
+version = "3.19.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"
+
+[[package]]
+name = "bv"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8834bb1d8ee5dc048ee3124f2c7c1afcc6bc9aed03f11e9dfd8c69470a5db340"
+dependencies = [
+ "feature-probe",
+ "serde",
+]
+
+[[package]]
+name = "byte-slice-cast"
+version = "1.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7575182f7272186991736b70173b0ea045398f984bf5ebbb3804736ce1330c9d"
+
+[[package]]
+name = "bytecheck"
+version = "0.6.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23cdc57ce23ac53c931e88a43d06d070a6fd142f2617be5855eb75efc9beb1c2"
+dependencies = [
+ "bytecheck_derive",
+ "ptr_meta",
+ "simdutf8",
+]
+
+[[package]]
+name = "bytecheck_derive"
+version = "0.6.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3db406d29fbcd95542e92559bed4d8ad92636d1ca8b3b72ede10b4bcc010e659"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "bytemuck"
+version = "1.24.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fbdf580320f38b612e485521afda1ee26d10cc9884efaaa750d383e13e3c5f4"
+dependencies = [
+ "bytemuck_derive",
+]
+
+[[package]]
+name = "bytemuck_derive"
+version = "1.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9abbd1bc6865053c427f7198e6af43bfdedc55ab791faed4fbd361d789575ff"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "byteorder"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"
+
+[[package]]
+name = "bytes"
+version = "1.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "c-kzg"
+version = "2.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e00bf4b112b07b505472dbefd19e37e53307e2bfed5a79e0cc161d58ccd0e687"
+dependencies = [
+ "blst",
+ "cc",
+ "glob",
+ "hex",
+ "libc",
+ "once_cell",
+ "serde",
+]
+
+[[package]]
+name = "c_linked_list"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4964518bd3b4a8190e832886cdc0da9794f12e8e6c1613a9e90ff331c4c8724b"
+
+[[package]]
+name = "caps"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fd1ddba47aba30b6a889298ad0109c3b8dcb0e8fc993b459daa7067d46f865e0"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "cast"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
+
+[[package]]
+name = "cc"
+version = "1.2.53"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "755d2fce177175ffca841e9a06afdb2c4ab0f593d53b4dee48147dfaade85932"
+dependencies = [
+ "find-msvc-tools",
+ "jobserver",
+ "libc",
+ "shlex",
+]
+
+[[package]]
+name = "cesu8"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
+
+[[package]]
+name = "cfg-if"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"
+
+[[package]]
+name = "cfg_aliases"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"
+
+[[package]]
+name = "cfg_eval"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45565fc9416b9896014f5732ac776f810ee53a66730c17e4020c3ec064a8f88f"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "chrono"
+version = "0.4.43"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fac4744fb15ae8337dc853fee7fb3f4e48c0fbaa23d0afe49c447b4fab126118"
+dependencies = [
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "serde",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
+name = "chrono-tz"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93698b29de5e97ad0ae26447b344c482a7284c737d9ddc5f9e52b74a336671bb"
+dependencies = [
+ "chrono",
+ "chrono-tz-build",
+ "phf 0.11.3",
+]
+
+[[package]]
+name = "chrono-tz"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6139a8597ed92cf816dfb33f5dd6cf0bb93a6adc938f11039f371bc5bcd26c3"
+dependencies = [
+ "chrono",
+ "phf 0.12.1",
+]
+
+[[package]]
+name = "chrono-tz-build"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0c088aee841df9c3041febbb73934cfc39708749bf96dc827e3359cd39ef11b1"
+dependencies = [
+ "parse-zoneinfo",
+ "phf 0.11.3",
+ "phf_codegen",
+]
+
+[[package]]
+name = "chunked_transfer"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e4de3bc4ea267985becf712dc6d9eed8b04c953b3fcfb339ebc87acd9804901"
+
+[[package]]
+name = "ciborium"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e"
+dependencies = [
+ "ciborium-io",
+ "ciborium-ll",
+ "serde",
+]
+
+[[package]]
+name = "ciborium-io"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757"
+
+[[package]]
+name = "ciborium-ll"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9"
+dependencies = [
+ "ciborium-io",
+ "half 2.7.1",
+]
+
+[[package]]
+name = "cipher"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
+dependencies = [
+ "crypto-common",
+ "inout",
+]
+
+[[package]]
+name = "claims"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6995bbe186456c36307f8ea36be3eefe42f49d106896414e18efc4fb2f846b5"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "clap"
+version = "2.34.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c"
+dependencies = [
+ "ansi_term",
+ "atty",
+ "bitflags 1.3.2",
+ "strsim 0.8.0",
+ "textwrap 0.11.0",
+ "unicode-width 0.1.14",
+ "vec_map",
+]
+
+[[package]]
+name = "clap"
+version = "4.5.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c6e6ff9dcd79cff5cd969a17a545d79e84ab086e444102a591e288a8aa3ce394"
+dependencies = [
+ "clap_builder",
+ "clap_derive",
+]
+
+[[package]]
+name = "clap_builder"
+version = "4.5.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa42cf4d2b7a41bc8f663a7cab4031ebafa1bf3875705bfaf8466dc60ab52c00"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap_lex",
+ "strsim 0.11.1",
+ "terminal_size",
+]
+
+[[package]]
+name = "clap_derive"
+version = "4.5.49"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
+dependencies = [
+ "heck 0.5.0",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "clap_lex"
+version = "0.7.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c3e64b0cc0439b12df2fa678eae89a1c56a529fd067a9115f7827f1fffd22b32"
+
+[[package]]
+name = "clear_on_drop"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38508a63f4979f0048febc9966fadbd48e5dab31fd0ec6a3f151bbf4a74f7423"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "cmake"
+version = "0.1.57"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75443c44cd6b379beb8c5b45d85d0773baf31cce901fe7bb252f4eff3008ef7d"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "codespan"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3362992a0d9f1dd7c3d0e89e0ab2bb540b7a95fea8cd798090e758fda2899b5e"
+dependencies = [
+ "codespan-reporting",
+]
+
+[[package]]
+name = "codespan-reporting"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
+dependencies = [
+ "serde",
+ "termcolor",
+ "unicode-width 0.1.14",
+]
+
+[[package]]
+name = "colorchoice"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"
+
+[[package]]
+name = "colored"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "117725a109d387c937a1533ce01b450cbde6b88abceea8473c4d7a85853cda3c"
+dependencies = [
+ "lazy_static",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "combine"
+version = "3.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da3da6baa321ec19e1cc41d31bf599f00c783d0517095cdaf0332e3fe8d20680"
+dependencies = [
+ "ascii",
+ "byteorder",
+ "either",
+ "memchr",
+ "unreachable",
+]
+
+[[package]]
+name = "combine"
+version = "4.6.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
+dependencies = [
+ "bytes",
+ "memchr",
+]
+
+[[package]]
+name = "compression-codecs"
+version = "0.4.36"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "00828ba6fd27b45a448e57dbfe84f1029d4c9f26b368157e9a448a5f49a2ec2a"
+dependencies = [
+ "brotli",
+ "compression-core",
+ "flate2",
+ "memchr",
+ "zstd",
+ "zstd-safe",
+]
+
+[[package]]
+name = "compression-core"
+version = "0.4.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75984efb6ed102a0d42db99afb6c1948f0380d1d91808d5529916e6c08b49d8d"
+
+[[package]]
+name = "concurrent-queue"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "console"
+version = "0.16.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "03e45a4a8926227e4197636ba97a9fc9b00477e9f4bd711395687c5f0734bec4"
+dependencies = [
+ "encode_unicode",
+ "libc",
+ "once_cell",
+ "unicode-width 0.2.2",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "const-hex"
+version = "1.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3bb320cac8a0750d7f25280aa97b09c26edfe161164238ecbbb31092b079e735"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "proptest",
+ "serde_core",
+]
+
+[[package]]
+name = "const-oid"
+version = "0.9.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"
+
+[[package]]
+name = "const_format"
+version = "0.2.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7faa7469a93a566e9ccc1c73fe783b4a65c274c5ace346038dca9c39fe0030ad"
+dependencies = [
+ "const_format_proc_macros",
+]
+
+[[package]]
+name = "const_format_proc_macros"
+version = "0.2.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d57c2eccfb16dbac1f4e61e206105db5820c9d26c3c472bc17c774259ef7744"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-xid",
+]
+
+[[package]]
+name = "constant_time_eq"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc"
+
+[[package]]
+name = "constant_time_eq"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d52eff69cd5e647efe296129160853a42795992097e8af39800e1060caeea9b"
+
+[[package]]
+name = "convert_case"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"
+
+[[package]]
+name = "convert_case"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "633458d4ef8c78b72454de2d54fd6ab2e60f9e02be22f3c6104cdc8a4e0fceb9"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "cookie"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7efb37c3e1ccb1ff97164ad95ac1606e8ccd35b3fa0a7d99a304c7f4a428cc24"
+dependencies = [
+ "percent-encoding",
+ "time",
+ "version_check",
+]
+
+[[package]]
+name = "cookie_store"
+version = "0.20.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "387461abbc748185c3a6e1673d826918b450b87ff22639429c694619a83b6cf6"
+dependencies = [
+ "cookie",
+ "idna 0.3.0",
+ "log",
+ "publicsuffix",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "time",
+ "url",
+]
+
+[[package]]
+name = "core-foundation"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "core-foundation"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b2a6cd9ae233e7f62ba4e9353e81a88df7fc8a5987b8d445b4d90c879bd156f6"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
+name = "core_affinity"
+version = "0.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a034b3a7b624016c6e13f5df875747cc25f884156aad2abd12b6c46797971342"
+dependencies = [
+ "libc",
+ "num_cpus",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "coset"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4c8cc80f631f8307b887faca24dcc3abc427cd0367f6eb6188f6e8f5b7ad8fb"
+dependencies = [
+ "ciborium",
+ "ciborium-io",
+]
+
+[[package]]
+name = "cpufeatures"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "crc"
+version = "3.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5eb8a2a1cd12ab0d987a5d5e825195d372001a4094a0376319d5a0ad71c1ba0d"
+dependencies = [
+ "crc-catalog",
+]
+
+[[package]]
+name = "crc-catalog"
+version = "2.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"
+
+[[package]]
+name = "crc32fast"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "criterion"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b01d6de93b2b6c65e17c634a26653a29d107b3c98c607c765bf38d041531cd8f"
+dependencies = [
+ "atty",
+ "cast",
+ "clap 2.34.0",
+ "criterion-plot",
+ "csv",
+ "itertools 0.10.5",
+ "lazy_static",
+ "num-traits",
+ "oorandom",
+ "plotters",
+ "rayon",
+ "regex",
+ "serde",
+ "serde_cbor",
+ "serde_derive",
+ "serde_json",
+ "tinytemplate",
+ "walkdir",
+]
+
+[[package]]
+name = "criterion-plot"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2673cc8207403546f45f5fd319a974b1e6983ad1a3ee7e6041650013be041876"
+dependencies = [
+ "cast",
+ "itertools 0.10.5",
+]
+
+[[package]]
+name = "crossbeam"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8"
+dependencies = [
+ "crossbeam-channel",
+ "crossbeam-deque",
+ "crossbeam-epoch",
+ "crossbeam-queue",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-channel"
+version = "0.5.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
+dependencies = [
+ "crossbeam-epoch",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.9.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-queue"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.8.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
+
+[[package]]
+name = "crunchy"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"
+
+[[package]]
+name = "crypto-bigint"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0dc92fb57ca44df6db8059111ab3af99a63d5d0f8375d9972e319a379c6bab76"
+dependencies = [
+ "generic-array",
+ "rand_core 0.6.4",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "crypto-common"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78c8292055d1c1df0cce5d180393dc8cce0abec0a7102adb6c7b1eef6016d60a"
+dependencies = [
+ "generic-array",
+ "rand_core 0.6.4",
+ "typenum",
+]
+
+[[package]]
+name = "crypto-mac"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b584a330336237c1eecd3e94266efb216c56ed91225d634cb2991c5f3fd1aeab"
+dependencies = [
+ "generic-array",
+ "subtle",
+]
+
+[[package]]
+name = "crypto-mac"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4857fd85a0c34b3c3297875b747c1e02e06b6a0ea32dd892d8192b9ce0813ea6"
+dependencies = [
+ "generic-array",
+ "subtle",
+]
+
+[[package]]
+name = "csv"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52cd9d68cf7efc6ddfaaee42e7288d3a99d613d4b50f76ce9827ae0c6e14f938"
+dependencies = [
+ "csv-core",
+ "itoa",
+ "ryu",
+ "serde_core",
+]
+
+[[package]]
+name = "csv-core"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "704a3c26996a80471189265814dbc2c257598b96b8a7feae2d31ace646bb9782"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "ctr"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0369ee1ad671834580515889b80f2ea915f23b8be8d0daa4bbaf2ac5c7590835"
+dependencies = [
+ "cipher",
+]
+
+[[package]]
+name = "ctrlc"
+version = "3.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73736a89c4aff73035ba2ed2e565061954da00d4970fc9ac25dcc85a2a20d790"
+dependencies = [
+ "dispatch2",
+ "nix",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "curve25519-dalek"
+version = "3.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b9fdf9972b2bd6af2d913799d9ebc165ea4d2e65878e329d9c6b372c4491b61"
+dependencies = [
+ "byteorder",
+ "digest 0.9.0",
+ "rand_core 0.5.1",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "curve25519-dalek"
+version = "4.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "curve25519-dalek-derive",
+ "digest 0.10.7",
+ "fiat-crypto",
+ "rand_core 0.6.4",
+ "rustc_version 0.4.1",
+ "serde",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "curve25519-dalek-derive"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "curve25519-dalek-ng"
+version = "4.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c359b7249347e46fb28804470d071c921156ad62b3eef5d34e2ba867533dec8"
+dependencies = [
+ "byteorder",
+ "digest 0.9.0",
+ "rand_core 0.6.4",
+ "serde",
+ "subtle-ng",
+ "zeroize",
+]
+
+[[package]]
+name = "darling"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc7f46116c46ff9ab3eb1597a45688b6715c6e628b5c133e288e709a29bcb4ee"
+dependencies = [
+ "darling_core 0.20.11",
+ "darling_macro 0.20.11",
+]
+
+[[package]]
+name = "darling"
+version = "0.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9cdf337090841a411e2a7f3deb9187445851f91b309c0c0a29e05f74a00a48c0"
+dependencies = [
+ "darling_core 0.21.3",
+ "darling_macro 0.21.3",
+]
+
+[[package]]
+name = "darling_core"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d00b9596d185e565c2207a0b01f8bd1a135483d02d9b7b0a54b11da8d53412e"
+dependencies = [
+ "fnv",
+ "ident_case",
+ "proc-macro2",
+ "quote",
+ "strsim 0.11.1",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "darling_core"
+version = "0.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1247195ecd7e3c85f83c8d2a366e4210d588e802133e1e355180a9870b517ea4"
+dependencies = [
+ "fnv",
+ "ident_case",
+ "proc-macro2",
+ "quote",
+ "serde",
+ "strsim 0.11.1",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "darling_macro"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc34b93ccb385b40dc71c6fceac4b2ad23662c7eeb248cf10d529b7e055b6ead"
+dependencies = [
+ "darling_core 0.20.11",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "darling_macro"
+version = "0.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d38308df82d1080de0afee5d069fa14b0326a88c14f15c5ccda35b4a6c414c81"
+dependencies = [
+ "darling_core 0.21.3",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "dashmap"
+version = "5.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
+dependencies = [
+ "cfg-if",
+ "hashbrown 0.14.5",
+ "lock_api",
+ "once_cell",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "dashmap"
+version = "6.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
+dependencies = [
+ "cfg-if",
+ "crossbeam-utils",
+ "hashbrown 0.14.5",
+ "lock_api",
+ "once_cell",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "dashmap"
+version = "7.0.0-rc2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e4a1e35a65fe0538a60167f0ada6e195ad5d477f6ddae273943596d4a1a5730b"
+dependencies = [
+ "cfg-if",
+ "crossbeam-utils",
+ "equivalent",
+ "hashbrown 0.15.2",
+ "lock_api",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "data-encoding"
+version = "2.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7a1e2f27636f116493b8b860f5546edb47c8d8f8ea73e1d2a20be88e28d1fea"
+
+[[package]]
+name = "deadpool"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0be2b1d1d6ec8d846f05e137292d0b89133caf95ef33695424c09568bdd39b1b"
+dependencies = [
+ "deadpool-runtime",
+ "lazy_static",
+ "num_cpus",
+ "tokio",
+]
+
+[[package]]
+name = "deadpool-runtime"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "092966b41edc516079bdf31ec78a2e0588d1d0c08f78b91d8307215928642b2b"
+
+[[package]]
+name = "der"
+version = "0.7.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
+dependencies = [
+ "const-oid",
+ "pem-rfc7468",
+ "zeroize",
+]
+
+[[package]]
+name = "der-parser"
+version = "8.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dbd676fbbab537128ef0278adb5576cf363cff6aa22a7b24effe97347cfab61e"
+dependencies = [
+ "asn1-rs",
+ "displaydoc",
+ "nom",
+ "num-bigint 0.4.6",
+ "num-traits",
+ "rusticata-macros",
+]
+
+[[package]]
+name = "deranged"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ececcb659e7ba858fb4f10388c250a7252eb0a27373f1a72b8748afdd248e587"
+dependencies = [
+ "powerfmt",
+ "serde_core",
+]
+
+[[package]]
+name = "derivation-path"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e5c37193a1db1d8ed868c03ec7b152175f26160a5b740e5e484143877e0adf0"
+
+[[package]]
+name = "derivative"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "derive_more"
+version = "0.99.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6edb4b64a43d977b8e99788fe3a04d483834fba1215a7e02caa415b626497f7f"
+dependencies = [
+ "convert_case 0.4.0",
+ "proc-macro2",
+ "quote",
+ "rustc_version 0.4.1",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "derive_more"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d751e9e49156b02b44f9c1815bcb94b984cdcc4396ecc32521c739452808b134"
+dependencies = [
+ "derive_more-impl",
+]
+
+[[package]]
+name = "derive_more-impl"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "799a97264921d8623a957f6c3b9011f3b5492f557bbb7a5a19b7fa6d06ba8dcb"
+dependencies = [
+ "convert_case 0.10.0",
+ "proc-macro2",
+ "quote",
+ "rustc_version 0.4.1",
+ "syn 2.0.114",
+ "unicode-xid",
+]
+
+[[package]]
+name = "deunicode"
+version = "1.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abd57806937c9cc163efc8ea3910e00a62e2aeb0b8119f1793a978088f8f6b04"
+
+[[package]]
+name = "difference"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198"
+
+[[package]]
+name = "digest"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "digest"
+version = "0.10.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+dependencies = [
+ "block-buffer 0.10.4",
+ "const-oid",
+ "crypto-common",
+ "subtle",
+]
+
+[[package]]
+name = "dirs-next"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1"
+dependencies = [
+ "cfg-if",
+ "dirs-sys-next",
+]
+
+[[package]]
+name = "dirs-sys-next"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d"
+dependencies = [
+ "libc",
+ "redox_users",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "dispatch2"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "89a09f22a6c6069a18470eb92d2298acf25463f14256d24778e1230d789a2aec"
+dependencies = [
+ "bitflags 2.10.0",
+ "block2",
+ "libc",
+ "objc2",
+]
+
+[[package]]
+name = "displaydoc"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "dlopen2"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09b4f5f101177ff01b8ec4ecc81eead416a8aa42819a2869311b3420fa114ffa"
+dependencies = [
+ "dlopen2_derive",
+ "libc",
+ "once_cell",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "dlopen2_derive"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6cbae11b3de8fce2a456e8ea3dada226b35fe791f0dc1d360c0941f0bb681f3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "dotenvy"
+version = "0.15.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"
+
+[[package]]
+name = "dudect-bencher"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5d065e1eac4fe9b4313fe81f692c7f589ce7b431719296a3392b85af4b73d38"
+dependencies = [
+ "clap 2.34.0",
+ "ctrlc",
+ "rand 0.8.5",
+ "rand_chacha 0.3.1",
+]
+
+[[package]]
+name = "dunce"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
+
+[[package]]
+name = "dyn-clone"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0881ea181b1df73ff77ffaaf9c7544ecc11e82fba9b5f27b262a3c73a332555"
+
+[[package]]
+name = "ecdsa"
+version = "0.16.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ee27f32b5c5292967d2d4a9d7f1e0b0aed2c15daded5a60300e4abb9d8020bca"
+dependencies = [
+ "der",
+ "digest 0.10.7",
+ "elliptic-curve",
+ "rfc6979",
+ "serdect",
+ "signature 2.2.0",
+ "spki",
+]
+
+[[package]]
+name = "ed25519"
+version = "1.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91cff35c70bba8a626e3185d8cd48cc11b5437e1a5bcd15b9b5fa3c64b6dfee7"
+dependencies = [
+ "serde",
+ "signature 1.6.4",
+]
+
+[[package]]
+name = "ed25519"
+version = "2.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
+dependencies = [
+ "pkcs8",
+ "signature 2.2.0",
+]
+
+[[package]]
+name = "ed25519-dalek"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c762bae6dcaf24c4c84667b8579785430908723d5c889f469d76a41d59cc7a9d"
+dependencies = [
+ "curve25519-dalek 3.2.0",
+ "ed25519 1.5.3",
+ "rand 0.7.3",
+ "serde",
+ "serde_bytes",
+ "sha2 0.9.9",
+ "zeroize",
+]
+
+[[package]]
+name = "ed25519-dalek"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
+dependencies = [
+ "curve25519-dalek 4.1.3",
+ "ed25519 2.2.3",
+ "rand_core 0.6.4",
+ "serde",
+ "sha2 0.10.9",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "educe"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d7bc049e1bd8cdeb31b68bbd586a9464ecf9f3944af3958a7a9d0f8b9799417"
+dependencies = [
+ "enum-ordinalize",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "either"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "elliptic-curve"
+version = "0.13.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5e6043086bf7973472e0c7dff2142ea0b680d30e18d9cc40f267efbf222bd47"
+dependencies = [
+ "base16ct",
+ "crypto-bigint",
+ "digest 0.10.7",
+ "ff",
+ "generic-array",
+ "group",
+ "pem-rfc7468",
+ "pkcs8",
+ "rand_core 0.6.4",
+ "sec1",
+ "serdect",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "encode_unicode"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"
+
+[[package]]
+name = "encoding_rs"
+version = "0.8.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "enum-ordinalize"
+version = "4.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a1091a7bb1f8f2c4b28f1fe2cef4980ca2d410a3d727d67ecc3178c9b0800f0"
+dependencies = [
+ "enum-ordinalize-derive",
+]
+
+[[package]]
+name = "enum-ordinalize-derive"
+version = "4.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ca9601fb2d62598ee17836250842873a413586e5d7ed88b356e38ddbb0ec631"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "enum_dispatch"
+version = "0.3.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa18ce2bc66555b3218614519ac839ddb759a7d6720732f979ef8d13be147ecd"
+dependencies = [
+ "once_cell",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
+[[package]]
+name = "erased-serde"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c138974f9d5e7fe373eb04df7cae98833802ae4b11c24ac7039a21d5af4b26c"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "errno"
+version = "0.3.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
+dependencies = [
+ "libc",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "ethnum"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca81e6b4777c89fd810c25a4be2b1bd93ea034fbe58e6a75216a34c6b82c539b"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "event-listener"
+version = "5.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e13b66accf52311f30a0db42147dadea9850cb48cd070028831ae5f5d4b856ab"
+dependencies = [
+ "concurrent-queue",
+ "parking",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "event-listener-strategy"
+version = "0.5.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
+dependencies = [
+ "event-listener",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "fail"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fe5e43d0f78a42ad591453aedb1d7ae631ce7ee445c7643691055a9ed8d3b01c"
+dependencies = [
+ "log",
+ "once_cell",
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "fastbloom"
+version = "0.14.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e7f34442dbe69c60fe8eaf58a8cafff81a1f278816d8ab4db255b3bef4ac3c4"
+dependencies = [
+ "getrandom 0.3.4",
+ "libm",
+ "rand 0.9.2",
+ "siphasher 1.0.1",
+]
+
+[[package]]
+name = "fastrand"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
+
+[[package]]
+name = "fastrlp"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "139834ddba373bbdd213dffe02c8d110508dcf1726c2be27e8d1f7d7e1856418"
+dependencies = [
+ "arrayvec 0.7.6",
+ "auto_impl",
+ "bytes",
+]
+
+[[package]]
+name = "fastrlp"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ce8dba4714ef14b8274c371879b175aa55b16b30f269663f19d576f380018dc4"
+dependencies = [
+ "arrayvec 0.7.6",
+ "auto_impl",
+ "bytes",
+]
+
+[[package]]
+name = "feature-probe"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "835a3dc7d1ec9e75e2b5fb4ba75396837112d2060b03f7d43bc1897c7f7211da"
+
+[[package]]
+name = "ff"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c0b50bfb653653f9ca9095b427bed08ab8d75a137839d9ad64eb11810d5b6393"
+dependencies = [
+ "bitvec",
+ "byteorder",
+ "ff_derive",
+ "rand_core 0.6.4",
+ "subtle",
+]
+
+[[package]]
+name = "ff_derive"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f10d12652036b0e99197587c6ba87a8fc3031986499973c030d8b44fcc151b60"
+dependencies = [
+ "addchain",
+ "num-bigint 0.3.3",
+ "num-integer",
+ "num-traits",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "fiat-crypto"
+version = "0.2.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"
+
+[[package]]
+name = "find-msvc-tools"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8591b0bcc8a98a64310a2fae1bb3e9b8564dd10e381e6e28010fde8e8e8568db"
+
+[[package]]
+name = "five8"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75b8549488b4715defcb0d8a8a1c1c76a80661b5fa106b4ca0e7fce59d7d875"
+dependencies = [
+ "five8_core 0.1.2",
+]
+
+[[package]]
+name = "five8"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23f76610e969fa1784327ded240f1e28a3fd9520c9cec93b636fcf62dd37f772"
+dependencies = [
+ "five8_core 1.0.0",
+]
+
+[[package]]
+name = "five8_const"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a0f1728185f277989ca573a402716ae0beaaea3f76a8ff87ef9dd8fb19436c5"
+dependencies = [
+ "five8_core 1.0.0",
+]
+
+[[package]]
+name = "five8_core"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2551bf44bc5f776c15044b9b94153a00198be06743e262afaaa61f11ac7523a5"
+
+[[package]]
+name = "five8_core"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "059c31d7d36c43fe39d89e55711858b4da8be7eb6dabac23c7289b1a19489406"
+
+[[package]]
+name = "fixed"
+version = "1.30.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c566da967934c6c7ee0458a9773de9b2a685bd2ce26a3b28ddfc740e640182f5"
+dependencies = [
+ "az",
+ "bytemuck",
+ "half 2.7.1",
+ "typenum",
+]
+
+[[package]]
+name = "fixed-hash"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534"
+dependencies = [
+ "byteorder",
+ "rand 0.8.5",
+ "rustc-hex",
+ "static_assertions",
+]
+
+[[package]]
+name = "fixedbitset"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"
+
+[[package]]
+name = "flate2"
+version = "1.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b375d6465b98090a5f25b1c7703f3859783755aa9a80433b36e0379a3ec2f369"
+dependencies = [
+ "crc32fast",
+ "miniz_oxide",
+]
+
+[[package]]
+name = "flexi_logger"
+version = "0.27.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "469e584c031833564840fb0cdbce99bdfe946fd45480a188545e73a76f45461c"
+dependencies = [
+ "chrono",
+ "glob",
+ "is-terminal",
+ "lazy_static",
+ "log",
+ "nu-ansi-term 0.49.0",
+ "regex",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "fnv"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
+
+[[package]]
+name = "foldhash"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"
+
+[[package]]
+name = "foldhash"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77ce24cb58228fbb8aa041425bb1050850ac19177686ea6e0f41a70416f56fdb"
+
+[[package]]
+name = "foreign-types"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
+dependencies = [
+ "foreign-types-shared",
+]
+
+[[package]]
+name = "foreign-types-shared"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"
+
+[[package]]
+name = "form_urlencoded"
+version = "1.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
+dependencies = [
+ "percent-encoding",
+]
+
+[[package]]
+name = "fs_extra"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"
+
+[[package]]
+name = "fst"
+version = "0.4.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ab85b9b05e3978cc9a9cf8fea7f01b494e1a09ed3037e16ba39edc7a29eb61a"
+
+[[package]]
+name = "funty"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"
+
+[[package]]
+name = "futures"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "futures-executor",
+ "futures-io",
+ "futures-sink",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-channel"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+]
+
+[[package]]
+name = "futures-core"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
+
+[[package]]
+name = "futures-executor"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
+dependencies = [
+ "futures-core",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-io"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
+
+[[package]]
+name = "futures-macro"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "futures-sink"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"
+
+[[package]]
+name = "futures-task"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"
+
+[[package]]
+name = "futures-timer"
+version = "3.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f288b0a4f20f9a56b5d1da57e2227c661b7b16168e2f72365f57b63326e29b24"
+
+[[package]]
+name = "futures-util"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "futures-io",
+ "futures-macro",
+ "futures-sink",
+ "futures-task",
+ "memchr",
+ "pin-project-lite",
+ "pin-utils",
+ "slab",
+]
+
+[[package]]
+name = "futures-utils-wasm"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42012b0f064e01aa58b545fe3727f90f7dd4020f4a3ea735b50344965f5a57e9"
+
+[[package]]
+name = "fxhash"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
+dependencies = [
+ "byteorder",
+]
+
+[[package]]
+name = "gcc"
+version = "0.3.55"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2"
+
+[[package]]
+name = "generic-array"
+version = "0.14.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+dependencies = [
+ "typenum",
+ "version_check",
+ "zeroize",
+]
+
+[[package]]
+name = "get_if_addrs"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abddb55a898d32925f3148bd281174a68eeb68bbfd9a5938a57b18f506ee4ef7"
+dependencies = [
+ "c_linked_list",
+ "get_if_addrs-sys",
+ "libc",
+ "winapi 0.2.8",
+]
+
+[[package]]
+name = "get_if_addrs-sys"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d04f9fb746cf36b191c00f3ede8bde9c8e64f9f4b05ae2694a9ccf5e3f5ab48"
+dependencies = [
+ "gcc",
+ "libc",
+]
+
+[[package]]
+name = "gethostname"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c1ebd34e35c46e00bb73e81363248d627782724609fe1b6396f553f68fe3862e"
+dependencies = [
+ "libc",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.1.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "wasi 0.9.0+wasi-snapshot-preview1",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff2abc00be7fca6ebc474524697ae276ad847ad0a6b3faa4bcb027e9a4614ad0"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "libc",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "libc",
+ "r-efi",
+ "wasip2",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "ghash"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f0d8a4362ccb29cb0b265253fb0a2728f592895ee6854fd9bc13f2ffda266ff1"
+dependencies = [
+ "opaque-debug",
+ "polyval",
+]
+
+[[package]]
+name = "gimli"
+version = "0.32.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e629b9b98ef3dd8afe6ca2bd0f89306cec16d43d907889945bc5d6687f2f13c7"
+
+[[package]]
+name = "glob"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"
+
+[[package]]
+name = "globset"
+version = "0.4.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52dfc19153a48bde0cbd630453615c8151bce3a5adfac7a0aebfbf0a1e1f57e3"
+dependencies = [
+ "aho-corasick",
+ "bstr",
+ "log",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "globwalk"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bf760ebf69878d9fd8f110c89703d90ce35095324d1f1edcb595c63945ee757"
+dependencies = [
+ "bitflags 2.10.0",
+ "ignore",
+ "walkdir",
+]
+
+[[package]]
+name = "governor"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68a7f542ee6b35af73b06abc0dad1c1bae89964e4e253bc4b587b91c9637867b"
+dependencies = [
+ "cfg-if",
+ "dashmap 5.5.3",
+ "futures",
+ "futures-timer",
+ "no-std-compat",
+ "nonzero_ext",
+ "parking_lot",
+ "portable-atomic",
+ "quanta",
+ "rand 0.8.5",
+ "smallvec",
+ "spinning_top",
+]
+
+[[package]]
+name = "governor"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be93b4ec2e4710b04d9264c0c7350cdd62a8c20e5e4ac732552ebb8f0debe8eb"
+dependencies = [
+ "cfg-if",
+ "futures-sink",
+ "futures-timer",
+ "futures-util",
+ "getrandom 0.3.4",
+ "no-std-compat",
+ "nonzero_ext",
+ "parking_lot",
+ "portable-atomic",
+ "quanta",
+ "smallvec",
+ "spinning_top",
+ "web-time",
+]
+
+[[package]]
+name = "group"
+version = "0.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
+dependencies = [
+ "ff",
+ "rand 0.8.5",
+ "rand_core 0.6.4",
+ "rand_xorshift 0.3.0",
+ "subtle",
+]
+
+[[package]]
+name = "h2"
+version = "0.3.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0beca50380b1fc32983fc1cb4587bfa4bb9e78fc259aad4a0032d2080309222d"
+dependencies = [
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "http 0.2.12",
+ "indexmap 2.13.0",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "h2"
+version = "0.4.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f44da3a8150a6703ed5d34e164b875fd14c2cdab9af1252a9a1020bde2bdc54"
+dependencies = [
+ "atomic-waker",
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "http 1.4.0",
+ "indexmap 2.13.0",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "half"
+version = "1.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b43ede17f21864e81be2fa654110bf1e793774238d86ef8555c37e6519c0403"
+
+[[package]]
+name = "half"
+version = "2.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ea2d84b969582b4b1864a92dc5d27cd2b77b622a8d79306834f1be5ba20d84b"
+dependencies = [
+ "cfg-if",
+ "crunchy",
+ "zerocopy",
+]
+
+[[package]]
+name = "hash32"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "47d60b12902ba28e2730cd37e95b8c9223af2808df9e902d4df49588d1470606"
+dependencies = [
+ "byteorder",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
+dependencies = [
+ "ahash 0.7.8",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.14.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
+dependencies = [
+ "ahash 0.8.12",
+ "allocator-api2",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
+dependencies = [
+ "allocator-api2",
+ "equivalent",
+ "foldhash 0.1.5",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.16.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"
+dependencies = [
+ "allocator-api2",
+ "equivalent",
+ "foldhash 0.2.0",
+ "serde",
+ "serde_core",
+]
+
+[[package]]
+name = "headers"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b3314d5adb5d94bcdf56771f2e50dbbc80bb4bdf88967526706205ac9eff24eb"
+dependencies = [
+ "base64 0.22.1",
+ "bytes",
+ "headers-core",
+ "http 1.4.0",
+ "httpdate",
+ "mime",
+ "sha1",
+]
+
+[[package]]
+name = "headers-core"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "54b4a22553d4242c49fddb9ba998a99962b5cc6f22cb5a3482bec22522403ce4"
+dependencies = [
+ "http 1.4.0",
+]
+
+[[package]]
+name = "heck"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "heck"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
+
+[[package]]
+name = "heck"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"
+
+[[package]]
+name = "hermit-abi"
+version = "0.1.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "hermit-abi"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"
+
+[[package]]
+name = "hex"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "hex-conservative"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fda06d18ac606267c40c04e41b9947729bf8b9efe74bd4e82b61a5f26a510b9f"
+dependencies = [
+ "arrayvec 0.7.6",
+]
+
+[[package]]
+name = "histogram"
+version = "0.6.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12cb882ccb290b8646e554b157ab0b71e64e8d5bef775cd66b6531e52d302669"
+
+[[package]]
+name = "hkdf"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51ab2f639c231793c5f6114bdb9bbe50a7dbbfcd7c7c6bd8475dec2d991e964f"
+dependencies = [
+ "digest 0.9.0",
+ "hmac 0.10.1",
+]
+
+[[package]]
+name = "hmac"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "126888268dcc288495a26bf004b38c5fdbb31682f992c84ceb046a1f0fe38840"
+dependencies = [
+ "crypto-mac 0.8.0",
+ "digest 0.9.0",
+]
+
+[[package]]
+name = "hmac"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c1441c6b1e930e2817404b5046f1f989899143a12bf92de603b69f4e0aee1e15"
+dependencies = [
+ "crypto-mac 0.10.0",
+ "digest 0.9.0",
+]
+
+[[package]]
+name = "hmac"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
+dependencies = [
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "hmac-drbg"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17ea0a1394df5b6574da6e0c1ade9e78868c9fb0a4e5ef4428e32da4676b85b1"
+dependencies = [
+ "digest 0.9.0",
+ "generic-array",
+ "hmac 0.8.1",
+]
+
+[[package]]
+name = "hostname"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3c731c3e10504cc8ed35cfe2f1db4c9274c3d35fa486e3b31df46f068ef3e867"
+dependencies = [
+ "libc",
+ "match_cfg",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "http"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3ba2a386d7f85a81f119ad7498ebe444d2e22c2af0b86b069416ace48b3311a"
+dependencies = [
+ "bytes",
+ "itoa",
+]
+
+[[package]]
+name = "http-body"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
+dependencies = [
+ "bytes",
+ "http 0.2.12",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "http-body"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
+dependencies = [
+ "bytes",
+ "http 1.4.0",
+]
+
+[[package]]
+name = "http-body-util"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "httparse"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"
+
+[[package]]
+name = "httpdate"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
+
+[[package]]
+name = "humansize"
+version = "2.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6cb51c9a029ddc91b07a787f1d86b53ccfa49b0e86688c946ebe8d3555685dd7"
+dependencies = [
+ "libm",
+]
+
+[[package]]
+name = "hyper"
+version = "0.14.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41dfc780fdec9373c01bae43289ea34c972e40ee3c9f6b3c8801a35f35586ce7"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "h2 0.3.27",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "socket2 0.5.10",
+ "tokio",
+ "tower-service",
+ "tracing",
+ "want",
+]
+
+[[package]]
+name = "hyper"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2ab2d4f250c3d7b1c9fcdff1cece94ea4e2dfbec68614f7b87cb205f24ca9d11"
+dependencies = [
+ "atomic-waker",
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "h2 0.4.13",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "pin-utils",
+ "smallvec",
+ "tokio",
+ "want",
+]
+
+[[package]]
+name = "hyper-rustls"
+version = "0.27.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
+dependencies = [
+ "http 1.4.0",
+ "hyper 1.8.1",
+ "hyper-util",
+ "rustls",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+ "webpki-roots 1.0.5",
+]
+
+[[package]]
+name = "hyper-timeout"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b90d566bffbce6a75bd8b09a05aa8c2cb1fabb6cb348f8840c9e4c90a0d83b0"
+dependencies = [
+ "hyper 1.8.1",
+ "hyper-util",
+ "pin-project-lite",
+ "tokio",
+ "tower-service",
+]
+
+[[package]]
+name = "hyper-tls"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6183ddfa99b85da61a140bea0efc93fdf56ceaa041b37d553518030827f9905"
+dependencies = [
+ "bytes",
+ "hyper 0.14.32",
+ "native-tls",
+ "tokio",
+ "tokio-native-tls",
+]
+
+[[package]]
+name = "hyper-tls"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
+dependencies = [
+ "bytes",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-util",
+ "native-tls",
+ "tokio",
+ "tokio-native-tls",
+ "tower-service",
+]
+
+[[package]]
+name = "hyper-util"
+version = "0.1.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "727805d60e7938b76b826a6ef209eb70eaa1812794f9424d4a4e2d740662df5f"
+dependencies = [
+ "base64 0.22.1",
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "hyper 1.8.1",
+ "ipnet",
+ "libc",
+ "percent-encoding",
+ "pin-project-lite",
+ "socket2 0.6.1",
+ "system-configuration",
+ "tokio",
+ "tower-service",
+ "tracing",
+ "windows-registry",
+]
+
+[[package]]
+name = "iana-time-zone"
+version = "0.1.64"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "icu_collections"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c6b649701667bbe825c3b7e6388cb521c23d88644678e83c0c4d0a621a34b43"
+dependencies = [
+ "displaydoc",
+ "potential_utf",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locale_core"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "edba7861004dd3714265b4db54a3c390e880ab658fec5f7db895fae2046b5bb6"
+dependencies = [
+ "displaydoc",
+ "litemap",
+ "tinystr",
+ "writeable",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f6c8828b67bf8908d82127b2054ea1b4427ff0230ee9141c54251934ab1b599"
+dependencies = [
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
+ "icu_provider",
+ "smallvec",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer_data"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7aedcccd01fc5fe81e6b489c15b247b8b0690feb23304303a9e560f37efc560a"
+
+[[package]]
+name = "icu_properties"
+version = "2.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "020bfc02fe870ec3a66d93e677ccca0562506e5872c650f893269e08615d74ec"
+dependencies = [
+ "icu_collections",
+ "icu_locale_core",
+ "icu_properties_data",
+ "icu_provider",
+ "zerotrie",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_properties_data"
+version = "2.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "616c294cf8d725c6afcd8f55abc17c56464ef6211f9ed59cccffe534129c77af"
+
+[[package]]
+name = "icu_provider"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85962cf0ce02e1e0a629cc34e7ca3e373ce20dda4c4d7294bbd0bf1fdb59e614"
+dependencies = [
+ "displaydoc",
+ "icu_locale_core",
+ "writeable",
+ "yoke",
+ "zerofrom",
+ "zerotrie",
+ "zerovec",
+]
+
+[[package]]
+name = "ident_case"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
+
+[[package]]
+name = "idna"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6"
+dependencies = [
+ "unicode-bidi",
+ "unicode-normalization",
+]
+
+[[package]]
+name = "idna"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
+dependencies = [
+ "idna_adapter",
+ "smallvec",
+ "utf8_iter",
+]
+
+[[package]]
+name = "idna_adapter"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
+dependencies = [
+ "icu_normalizer",
+ "icu_properties",
+]
+
+[[package]]
+name = "ignore"
+version = "0.4.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3d782a365a015e0f5c04902246139249abf769125006fbe7649e2ee88169b4a"
+dependencies = [
+ "crossbeam-deque",
+ "globset",
+ "log",
+ "memchr",
+ "regex-automata",
+ "same-file",
+ "walkdir",
+ "winapi-util",
+]
+
+[[package]]
+name = "im"
+version = "15.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0acd33ff0285af998aaf9b57342af478078f53492322fafc47450e09397e0e9"
+dependencies = [
+ "bitmaps",
+ "rand_core 0.6.4",
+ "rand_xoshiro",
+ "sized-chunks",
+ "typenum",
+ "version_check",
+]
+
+[[package]]
+name = "impl-codec"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f"
+dependencies = [
+ "parity-scale-codec",
+]
+
+[[package]]
+name = "impl-trait-for-tuples"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0eb5a3343abf848c0984fe4604b2b105da9539376e24fc0a3b0007411ae4fd9"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "include_dir"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24b56e147e6187d61e9d0f039f10e070d0c0a887e24fe0bb9ca3f29bfde62cab"
+dependencies = [
+ "glob",
+ "include_dir_impl",
+ "proc-macro-hack",
+]
+
+[[package]]
+name = "include_dir_impl"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0a0c890c85da4bab7bce4204c707396bbd3c6c8a681716a51c8814cfc2b682df"
+dependencies = [
+ "anyhow",
+ "proc-macro-hack",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "indexmap"
+version = "1.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
+dependencies = [
+ "autocfg",
+ "hashbrown 0.12.3",
+ "serde",
+]
+
+[[package]]
+name = "indexmap"
+version = "2.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7714e70437a7dc3ac8eb7e6f8df75fd8eb422675fc7678aff7364301092b1017"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.16.1",
+ "serde",
+ "serde_core",
+]
+
+[[package]]
+name = "indicatif"
+version = "0.18.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9375e112e4b463ec1b1c6c011953545c65a30164fbab5b581df32b3abf0dcb88"
+dependencies = [
+ "console",
+ "portable-atomic",
+ "unicode-width 0.2.2",
+ "unit-prefix",
+ "web-time",
+]
+
+[[package]]
+name = "indoc"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa799dd5ed20a7e349f3b4639aa80d74549c81716d9ec4f994c9b5815598306"
+
+[[package]]
+name = "inout"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "internment"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ab388864246d58a276e60e7569a833d9cc4cd75c66e5ca77c177dad38e59996"
+dependencies = [
+ "ahash 0.7.8",
+ "dashmap 5.5.3",
+ "hashbrown 0.12.3",
+ "once_cell",
+ "parking_lot",
+]
+
+[[package]]
+name = "ipnet"
+version = "2.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"
+
+[[package]]
+name = "iri-string"
+version = "0.7.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c91338f0783edbd6195decb37bae672fd3b165faffb89bf7b9e6942f8b1a731a"
+dependencies = [
+ "memchr",
+ "serde",
+]
+
+[[package]]
+name = "is-terminal"
+version = "0.4.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3640c1c38b8e4e43584d8df18be5fc6b0aa314ce6ebf51b53313d4306cca8e46"
+dependencies = [
+ "hermit-abi 0.5.2",
+ "libc",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "is_terminal_polyfill"
+version = "1.70.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"
+
+[[package]]
+name = "itertools"
+version = "0.10.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itertools"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itertools"
+version = "0.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itertools"
+version = "0.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b192c782037fadd9cfa75548310488aabdbf3d2da73885b31bd0abd03351285"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92ecc6618181def0457392ccd0ee51198e065e016d1d527a7ac1b6dc7c1f09d2"
+
+[[package]]
+name = "jni"
+version = "0.21.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
+dependencies = [
+ "cesu8",
+ "cfg-if",
+ "combine 4.6.7",
+ "jni-sys",
+ "log",
+ "thiserror 1.0.69",
+ "walkdir",
+ "windows-sys 0.45.0",
+]
+
+[[package]]
+name = "jni-sys"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"
+
+[[package]]
+name = "jobserver"
+version = "0.1.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
+dependencies = [
+ "getrandom 0.3.4",
+ "libc",
+]
+
+[[package]]
+name = "js-sys"
+version = "0.3.85"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8c942ebf8e95485ca0d52d97da7c5a2c387d0e7f0ba4c35e93bfcaee045955b3"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "jsonrpc-core"
+version = "18.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "14f7f76aef2d054868398427f6c54943cf3d1caa9a7ec7d0c38d69df97a965eb"
+dependencies = [
+ "futures",
+ "futures-executor",
+ "futures-util",
+ "log",
+ "serde",
+ "serde_derive",
+ "serde_json",
+]
+
+[[package]]
+name = "jsonwebtoken"
+version = "8.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6971da4d9c3aa03c3d8f3ff0f4155b534aad021292003895a469716b2a230378"
+dependencies = [
+ "base64 0.21.7",
+ "pem",
+ "ring 0.16.20",
+ "serde",
+ "serde_json",
+ "simple_asn1",
+]
+
+[[package]]
+name = "k256"
+version = "0.13.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6e3919bbaa2945715f0bb6d3934a173d1e9a59ac23767fbaaef277265a7411b"
+dependencies = [
+ "cfg-if",
+ "ecdsa",
+ "elliptic-curve",
+ "once_cell",
+ "serdect",
+ "sha2 0.10.9",
+]
+
+[[package]]
+name = "keccak"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
+dependencies = [
+ "cpufeatures",
+]
+
+[[package]]
+name = "keccak-asm"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "505d1856a39b200489082f90d897c3f07c455563880bc5952e38eabf731c83b6"
+dependencies = [
+ "digest 0.10.7",
+ "sha3-asm",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
+dependencies = [
+ "spin 0.9.8",
+]
+
+[[package]]
+name = "legacy-move-compiler"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "bcs 0.1.4",
+ "clap 4.5.54",
+ "codespan-reporting",
+ "hex",
+ "move-binary-format",
+ "move-bytecode-source-map",
+ "move-bytecode-verifier",
+ "move-command-line-common",
+ "move-core-types",
+ "move-ir-types",
+ "move-symbol-pool",
+ "once_cell",
+ "petgraph",
+ "regex",
+ "tempfile",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.180"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bcc35a38544a891a5f7c865aca548a982ccb3b8650a5b06d0fd33a10283c56fc"
+
+[[package]]
+name = "libm"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"
+
+[[package]]
+name = "libredox"
+version = "0.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d0b95e02c851351f877147b7deea7b1afb1df71b63aa5f8270716e0c5720616"
+dependencies = [
+ "bitflags 2.10.0",
+ "libc",
+ "redox_syscall 0.7.0",
+]
+
+[[package]]
+name = "libsecp256k1"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e79019718125edc905a079a70cfa5f3820bc76139fc91d6f9abc27ea2a887139"
+dependencies = [
+ "arrayref",
+ "base64 0.22.1",
+ "digest 0.9.0",
+ "hmac-drbg",
+ "libsecp256k1-core",
+ "libsecp256k1-gen-ecmult",
+ "libsecp256k1-gen-genmult",
+ "rand 0.8.5",
+ "serde",
+ "sha2 0.9.9",
+ "typenum",
+]
+
+[[package]]
+name = "libsecp256k1-core"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5be9b9bb642d8522a44d533eab56c16c738301965504753b03ad1de3425d5451"
+dependencies = [
+ "crunchy",
+ "digest 0.9.0",
+ "subtle",
+]
+
+[[package]]
+name = "libsecp256k1-gen-ecmult"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3038c808c55c87e8a172643a7d87187fc6c4174468159cb3090659d55bcb4809"
+dependencies = [
+ "libsecp256k1-core",
+]
+
+[[package]]
+name = "libsecp256k1-gen-genmult"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3db8d6ba2cec9eacc40e6e8ccc98931840301f1006e95647ceb2dd5c3aa06f7c"
+dependencies = [
+ "libsecp256k1-core",
+]
+
+[[package]]
+name = "linked-hash-map"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"
+
+[[package]]
+name = "linux-raw-sys"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"
+
+[[package]]
+name = "litemap"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6373607a59f0be73a39b6fe456b8192fcc3585f602af20751600e974dd455e77"
+
+[[package]]
+name = "lock_api"
+version = "0.4.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
+dependencies = [
+ "scopeguard",
+]
+
+[[package]]
+name = "log"
+version = "0.4.29"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"
+dependencies = [
+ "serde_core",
+]
+
+[[package]]
+name = "lru"
+version = "0.16.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1dc47f592c06f33f8e3aea9591776ec7c9f9e4124778ff8a3c3b87159f7e593"
+dependencies = [
+ "hashbrown 0.16.1",
+]
+
+[[package]]
+name = "lru-slab"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"
+
+[[package]]
+name = "macro-string"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b27834086c65ec3f9387b096d66e99f221cf081c2b738042aa252bcd41204e3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "maplit"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3e2e65a1a2e43cfcb47a895c4c8b10d1f4a61097f9f254f183aee60cad9c651d"
+
+[[package]]
+name = "match_cfg"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffbee8634e0d45d258acb448e7eaab3fce7a0a467395d4d9f228e3c1f01fb2e4"
+
+[[package]]
+name = "matchers"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
+dependencies = [
+ "regex-automata",
+]
+
+[[package]]
+name = "matchit"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"
+
+[[package]]
+name = "matchit"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "47e1ffaa40ddd1f3ed91f717a33c8c0ee23fff369e3aa8772b9605cc1d22f4c3"
+
+[[package]]
+name = "memchr"
+version = "2.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"
+
+[[package]]
+name = "memoffset"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "merlin"
+version = "3.0.0"
+source = "git+https://github.com/aptos-labs/merlin#3454ccc85e37355c729ba40e6dac6e867ddf59f5"
+dependencies = [
+ "byteorder",
+ "keccak",
+ "rand_core 0.6.4",
+ "zeroize",
+]
+
+[[package]]
+name = "mime"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+
+[[package]]
+name = "mime_guess"
+version = "2.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
+dependencies = [
+ "mime",
+ "unicase",
+]
+
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "miniz_oxide"
+version = "0.8.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
+dependencies = [
+ "adler2",
+ "simd-adler32",
+]
+
+[[package]]
+name = "mio"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a69bcab0ad47271a0234d9422b131806bf3968021e5dc9328caf2d4cd58557fc"
+dependencies = [
+ "libc",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "mirai-annotations"
+version = "1.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c9be0862c1b3f26a88803c4a49de6889c10e608b3ee9344e6ef5b45fb37ad3d1"
+
+[[package]]
+name = "more-asserts"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fafa6961cabd9c63bcd77a45d7e3b7f3b552b70417831fb0f56db717e72407e"
+
+[[package]]
+name = "move-abigen"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "bcs 0.1.4",
+ "heck 0.4.1",
+ "log",
+ "move-binary-format",
+ "move-bytecode-verifier",
+ "move-command-line-common",
+ "move-core-types",
+ "move-model",
+ "serde",
+]
+
+[[package]]
+name = "move-asm"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "clap 4.5.54",
+ "codespan",
+ "codespan-reporting",
+ "either",
+ "move-binary-format",
+ "move-core-types",
+]
+
+[[package]]
+name = "move-binary-format"
+version = "0.0.3"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "backtrace",
+ "indexmap 2.13.0",
+ "move-bytecode-spec",
+ "move-core-types",
+ "once_cell",
+ "ref-cast",
+ "serde",
+ "variant_count",
+]
+
+[[package]]
+name = "move-borrow-graph"
+version = "0.0.1"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+
+[[package]]
+name = "move-bytecode-source-map"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "bcs 0.1.4",
+ "move-binary-format",
+ "move-command-line-common",
+ "move-core-types",
+ "move-ir-types",
+ "move-symbol-pool",
+ "serde",
+]
+
+[[package]]
+name = "move-bytecode-spec"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "once_cell",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "move-bytecode-utils"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "move-binary-format",
+ "move-core-types",
+ "petgraph",
+]
+
+[[package]]
+name = "move-bytecode-verifier"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "fail",
+ "move-binary-format",
+ "move-borrow-graph",
+ "move-core-types",
+ "petgraph",
+ "serde",
+ "typed-arena",
+]
+
+[[package]]
+name = "move-command-line-common"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "difference",
+ "dirs-next",
+ "hex",
+ "move-core-types",
+ "num-bigint 0.3.3",
+ "once_cell",
+ "serde",
+ "sha2 0.9.9",
+ "walkdir",
+]
+
+[[package]]
+name = "move-compiler-v2"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "abstract-domain-derive",
+ "anyhow",
+ "bcs 0.1.4",
+ "clap 4.5.54",
+ "codespan",
+ "codespan-reporting",
+ "colored",
+ "ethnum",
+ "flexi_logger",
+ "im",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "log",
+ "move-asm",
+ "move-binary-format",
+ "move-borrow-graph",
+ "move-bytecode-source-map",
+ "move-bytecode-verifier",
+ "move-command-line-common",
+ "move-core-types",
+ "move-ir-types",
+ "move-model",
+ "move-stackless-bytecode",
+ "move-symbol-pool",
+ "num 0.4.3",
+ "once_cell",
+ "petgraph",
+ "serde_json",
+]
+
+[[package]]
+name = "move-core-types"
+version = "0.0.4"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "bcs 0.1.4",
+ "bytes",
+ "ethnum",
+ "hashbrown 0.14.5",
+ "hex",
+ "num 0.4.3",
+ "once_cell",
+ "rand 0.8.5",
+ "ref-cast",
+ "serde",
+ "serde_bytes",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "move-docgen"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "clap 4.5.54",
+ "codespan",
+ "codespan-reporting",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "log",
+ "move-core-types",
+ "move-model",
+ "once_cell",
+ "regex",
+ "serde",
+]
+
+[[package]]
+name = "move-errmapgen"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "move-command-line-common",
+ "move-core-types",
+ "move-model",
+ "serde",
+]
+
+[[package]]
+name = "move-ir-types"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "hex",
+ "move-command-line-common",
+ "move-core-types",
+ "move-symbol-pool",
+ "once_cell",
+ "serde",
+]
+
+[[package]]
+name = "move-model"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "codespan",
+ "codespan-reporting",
+ "either",
+ "internment",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "log",
+ "move-asm",
+ "move-binary-format",
+ "move-bytecode-source-map",
+ "move-command-line-common",
+ "move-core-types",
+ "move-ir-types",
+ "move-symbol-pool",
+ "num 0.4.3",
+ "num-traits",
+ "once_cell",
+ "regex",
+ "serde",
+]
+
+[[package]]
+name = "move-package"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "clap 4.5.54",
+ "colored",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "move-abigen",
+ "move-binary-format",
+ "move-bytecode-source-map",
+ "move-bytecode-utils",
+ "move-command-line-common",
+ "move-compiler-v2",
+ "move-core-types",
+ "move-docgen",
+ "move-model",
+ "move-symbol-pool",
+ "named-lock",
+ "once_cell",
+ "petgraph",
+ "regex",
+ "serde",
+ "serde_yaml 0.8.26",
+ "sha2 0.9.9",
+ "tempfile",
+ "termcolor",
+ "toml",
+ "walkdir",
+ "whoami",
+]
+
+[[package]]
+name = "move-prover"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "atty",
+ "clap 4.5.54",
+ "codespan-reporting",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "log",
+ "move-abigen",
+ "move-command-line-common",
+ "move-compiler-v2",
+ "move-docgen",
+ "move-errmapgen",
+ "move-model",
+ "move-prover-boogie-backend",
+ "move-prover-bytecode-pipeline",
+ "move-stackless-bytecode",
+ "once_cell",
+ "serde",
+ "toml",
+]
+
+[[package]]
+name = "move-prover-boogie-backend"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "async-trait",
+ "codespan",
+ "codespan-reporting",
+ "futures",
+ "itertools 0.13.0",
+ "legacy-move-compiler",
+ "log",
+ "move-binary-format",
+ "move-command-line-common",
+ "move-core-types",
+ "move-model",
+ "move-prover-bytecode-pipeline",
+ "move-stackless-bytecode",
+ "num 0.4.3",
+ "once_cell",
+ "pretty",
+ "rand 0.7.3",
+ "regex",
+ "serde",
+ "tera",
+ "tokio",
+]
+
+[[package]]
+name = "move-prover-bytecode-pipeline"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "codespan-reporting",
+ "itertools 0.13.0",
+ "move-binary-format",
+ "move-core-types",
+ "move-model",
+ "move-stackless-bytecode",
+ "serde",
+]
+
+[[package]]
+name = "move-prover-lab"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "chrono",
+ "clap 4.5.54",
+ "codespan-reporting",
+ "itertools 0.13.0",
+ "move-model",
+ "move-prover",
+ "move-prover-boogie-backend",
+ "move-prover-bytecode-pipeline",
+ "plotters",
+ "z3tracer",
+]
+
+[[package]]
+name = "move-resource-viewer"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "anyhow",
+ "hex",
+ "move-binary-format",
+ "move-bytecode-utils",
+ "move-core-types",
+ "serde",
+]
+
+[[package]]
+name = "move-stackless-bytecode"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "abstract-domain-derive",
+ "anyhow",
+ "codespan-reporting",
+ "ethnum",
+ "im",
+ "itertools 0.13.0",
+ "log",
+ "move-binary-format",
+ "move-core-types",
+ "move-model",
+ "num 0.4.3",
+ "paste",
+ "petgraph",
+ "topological-sort",
+ "try_match",
+]
+
+[[package]]
+name = "move-symbol-pool"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "once_cell",
+ "serde",
+]
+
+[[package]]
+name = "move-table-extension"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "better_any",
+ "bytes",
+ "move-binary-format",
+ "move-core-types",
+ "move-vm-runtime",
+ "move-vm-types",
+ "sha3 0.9.1",
+ "smallvec",
+ "triomphe",
+]
+
+[[package]]
+name = "move-vm-metrics"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "once_cell",
+ "prometheus",
+]
+
+[[package]]
+name = "move-vm-profiler"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "move-vm-types",
+ "once_cell",
+]
+
+[[package]]
+name = "move-vm-runtime"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "ambassador",
+ "better_any",
+ "bitvec",
+ "bytes",
+ "cfg-if",
+ "claims",
+ "fail",
+ "fxhash",
+ "hashbrown 0.14.5",
+ "itertools 0.13.0",
+ "lazy_static",
+ "lru",
+ "move-binary-format",
+ "move-bytecode-verifier",
+ "move-core-types",
+ "move-vm-metrics",
+ "move-vm-profiler",
+ "move-vm-types",
+ "once_cell",
+ "parking_lot",
+ "serde",
+ "triomphe",
+ "typed-arena",
+]
+
+[[package]]
+name = "move-vm-types"
+version = "0.1.0"
+source = "git+https://github.com/aptos-labs/aptos-core?tag=aptos-node-v1.39.2#e66a3efbd84c33dfb395bb3e1a8fea95274e0f4e"
+dependencies = [
+ "ambassador",
+ "bcs 0.1.4",
+ "better_any",
+ "bytes",
+ "crossbeam",
+ "dashmap 7.0.0-rc2",
+ "derivative",
+ "hashbrown 0.14.5",
+ "itertools 0.13.0",
+ "move-binary-format",
+ "move-core-types",
+ "parking_lot",
+ "serde",
+ "sha3 0.9.1",
+ "smallbitvec",
+ "smallvec",
+ "triomphe",
+]
+
+[[package]]
+name = "multer"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "83e87776546dc87511aa5ee218730c92b666d7264ab6ed41f9d215af9cd5224b"
+dependencies = [
+ "bytes",
+ "encoding_rs",
+ "futures-util",
+ "http 1.4.0",
+ "httparse",
+ "memchr",
+ "mime",
+ "spin 0.9.8",
+ "tokio",
+ "version_check",
+]
+
+[[package]]
+name = "named-lock"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "40a3eb6b7c682b65d1f631ec3176829d72ab450b3aacdd3f719bf220822e59ac"
+dependencies = [
+ "libc",
+ "once_cell",
+ "parking_lot",
+ "thiserror 1.0.69",
+ "widestring",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "native-tls"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
+dependencies = [
+ "libc",
+ "log",
+ "openssl",
+ "openssl-probe 0.1.6",
+ "openssl-sys",
+ "schannel",
+ "security-framework 2.11.1",
+ "security-framework-sys",
+ "tempfile",
+]
+
+[[package]]
+name = "neptune"
+version = "13.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06626c9ac04c894e9a23d061ba1309f28506cdc5fe64156d28a15fb57fc8e438"
+dependencies = [
+ "bellpepper",
+ "bellpepper-core",
+ "blake2s_simd",
+ "blstrs",
+ "byteorder",
+ "ff",
+ "generic-array",
+ "log",
+ "pasta_curves",
+ "serde",
+ "trait-set",
+]
+
+[[package]]
+name = "nix"
+version = "0.30.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
+dependencies = [
+ "bitflags 2.10.0",
+ "cfg-if",
+ "cfg_aliases",
+ "libc",
+ "memoffset",
+]
+
+[[package]]
+name = "no-std-compat"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b93853da6d84c2e3c7d730d6473e8817692dd89be387eb01b94d7f108ecb5b8c"
+
+[[package]]
+name = "nodrop"
+version = "0.1.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72ef4a56884ca558e5ddb05a1d1e7e1bfd9a68d9ed024c21704cc98872dae1bb"
+
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
+[[package]]
+name = "nonzero_ext"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38bf9645c8b145698bb0b18a4637dcacbc421ea49bef2317e4fd8065a387cf21"
+
+[[package]]
+name = "nu-ansi-term"
+version = "0.49.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c073d3c1930d0751774acf49e66653acecb416c3a54c6ec095a9b11caddb5a68"
+dependencies = [
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "nu-ansi-term"
+version = "0.50.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7957b9740744892f114936ab4a57b3f487491bbeafaf8083688b16841a4240e5"
+dependencies = [
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "num"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8536030f9fea7127f841b45bb6243b27255787fb4eb83958aa1ef9d2fdc0c36"
+dependencies = [
+ "num-bigint 0.2.6",
+ "num-complex 0.2.4",
+ "num-integer",
+ "num-iter",
+ "num-rational 0.2.4",
+ "num-traits",
+]
+
+[[package]]
+name = "num"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b7a8e9be5e039e2ff869df49155f1c06bd01ade2117ec783e56ab0932b67a8f"
+dependencies = [
+ "num-bigint 0.3.3",
+ "num-complex 0.3.1",
+ "num-integer",
+ "num-iter",
+ "num-rational 0.3.2",
+ "num-traits",
+]
+
+[[package]]
+name = "num"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "35bd024e8b2ff75562e5f34e7f4905839deb4b22955ef5e73d2fea1b9813cb23"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-complex 0.4.6",
+ "num-integer",
+ "num-iter",
+ "num-rational 0.4.2",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "090c7f9998ee0ff65aa5b723e4009f7b217707f1fb5ea551329cc4d6231fb304"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f6f7833f2cbf2360a6cfd58cd41a53aa7a90bd4c202f5b1c7dd2ed73c57b2c3"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+ "rand 0.7.3",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
+dependencies = [
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint-dig"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e661dda6640fad38e827a6d4a310ff4763082116fe217f279885c97f511bb0b7"
+dependencies = [
+ "lazy_static",
+ "libm",
+ "num-integer",
+ "num-iter",
+ "num-traits",
+ "rand 0.8.5",
+ "smallvec",
+ "zeroize",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6b19411a9719e753aff12e5187b74d60d3dc449ec3f4dc21e3989c3f554bc95"
+dependencies = [
+ "autocfg",
+ "num-traits",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "747d632c0c558b87dbabbe6a82f3b4ae03720d0646ac5b7b4dae89394be5f2c5"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73f88a1307638156682bada9d7604135552957b7818057dcef22705b4d509495"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-conv"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
+
+[[package]]
+name = "num-derive"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-iter"
+version = "0.1.45"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c000134b5dbf44adc5cb772486d335293351644b801551abe8f75c84cfa4aef"
+dependencies = [
+ "autocfg",
+ "num-bigint 0.2.6",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12ac428b1cb17fce6f731001d307d351ec70a6d202fc2e60f7d4c5e42d8f4f07"
+dependencies = [
+ "autocfg",
+ "num-bigint 0.3.3",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f83d14da390562dca69fc84082e73e548e1ad308d24accdedd2720017cb37824"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+ "libm",
+]
+
+[[package]]
+name = "num_cpus"
+version = "1.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91df4bbde75afed763b708b7eee1e8e7651e02d97f6d5dd763e89367e957b23b"
+dependencies = [
+ "hermit-abi 0.5.2",
+ "libc",
+]
+
+[[package]]
+name = "num_enum"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1207a7e20ad57b847bbddc6776b968420d38292bbfe2089accff5e19e82454c"
+dependencies = [
+ "num_enum_derive",
+ "rustversion",
+]
+
+[[package]]
+name = "num_enum_derive"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff32365de1b6743cb203b710788263c44a03de03802daf96092f2da4fe6ba4d7"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "nybbles"
+version = "0.4.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b5676b5c379cf5b03da1df2b3061c4a4e2aa691086a56ac923e08c143f53f59"
+dependencies = [
+ "alloy-rlp",
+ "cfg-if",
+ "proptest",
+ "ruint",
+ "serde",
+ "smallvec",
+]
+
+[[package]]
+name = "objc2"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b7c2599ce0ec54857b29ce62166b0ed9b4f6f1a70ccc9a71165b6154caca8c05"
+dependencies = [
+ "objc2-encode",
+]
+
+[[package]]
+name = "objc2-encode"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ef25abbcd74fb2609453eb695bd2f860d389e457f67dc17cafc8b8cbc89d0c33"
+
+[[package]]
+name = "object"
+version = "0.37.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff76201f031d8863c38aa7f905eca4f53abbfa15f609db4277d44cd8938f33fe"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "oid-registry"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9bedf36ffb6ba96c2eb7144ef6270557b52e54b20c0a8e1eb2ff99a6c6959bff"
+dependencies = [
+ "asn1-rs",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
+name = "once_cell_polyfill"
+version = "1.70.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"
+
+[[package]]
+name = "oorandom"
+version = "11.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6790f58c7ff633d8771f42965289203411a5e5c68388703c06e14f24770b41e"
+
+[[package]]
+name = "opaque-debug"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"
+
+[[package]]
+name = "openssl"
+version = "0.10.75"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08838db121398ad17ab8531ce9de97b244589089e290a384c900cb9ff7434328"
+dependencies = [
+ "bitflags 2.10.0",
+ "cfg-if",
+ "foreign-types",
+ "libc",
+ "once_cell",
+ "openssl-macros",
+ "openssl-sys",
+]
+
+[[package]]
+name = "openssl-macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "openssl-probe"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"
+
+[[package]]
+name = "openssl-probe"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9f50d9b3dabb09ecd771ad0aa242ca6894994c130308ca3d7684634df8037391"
+
+[[package]]
+name = "openssl-sys"
+version = "0.9.111"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "82cab2d520aa75e3c58898289429321eb788c3106963d0dc886ec7a5f4adc321"
+dependencies = [
+ "cc",
+ "libc",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "opentelemetry"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b84bcd6ae87133e903af7ef497404dda70c60d0ea14895fc8a5e6722754fc2a0"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+ "js-sys",
+ "pin-project-lite",
+ "thiserror 2.0.18",
+ "tracing",
+]
+
+[[package]]
+name = "opentelemetry-http"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7a6d09a73194e6b66df7c8f1b680f156d916a1a942abf2de06823dd02b7855d"
+dependencies = [
+ "async-trait",
+ "bytes",
+ "http 1.4.0",
+ "opentelemetry",
+ "reqwest 0.12.28",
+]
+
+[[package]]
+name = "opentelemetry-otlp"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a2366db2dca4d2ad033cad11e6ee42844fd727007af5ad04a1730f4cb8163bf"
+dependencies = [
+ "http 1.4.0",
+ "opentelemetry",
+ "opentelemetry-http",
+ "opentelemetry-proto",
+ "opentelemetry_sdk",
+ "prost 0.14.3",
+ "reqwest 0.12.28",
+ "thiserror 2.0.18",
+ "tokio",
+ "tonic 0.14.2",
+ "tracing",
+]
+
+[[package]]
+name = "opentelemetry-proto"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a7175df06de5eaee9909d4805a3d07e28bb752c34cab57fa9cff549da596b30f"
+dependencies = [
+ "opentelemetry",
+ "opentelemetry_sdk",
+ "prost 0.14.3",
+ "tonic 0.14.2",
+ "tonic-prost",
+]
+
+[[package]]
+name = "opentelemetry-semantic-conventions"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e62e29dfe041afb8ed2a6c9737ab57db4907285d999ef8ad3a59092a36bdc846"
+
+[[package]]
+name = "opentelemetry-stdout"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bc8887887e169414f637b18751487cce4e095be787d23fad13c454e2fb1b3811"
+dependencies = [
+ "chrono",
+ "opentelemetry",
+ "opentelemetry_sdk",
+]
+
+[[package]]
+name = "opentelemetry_sdk"
+version = "0.31.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e14ae4f5991976fd48df6d843de219ca6d31b01daaab2dad5af2badeded372bd"
+dependencies = [
+ "futures-channel",
+ "futures-executor",
+ "futures-util",
+ "opentelemetry",
+ "percent-encoding",
+ "rand 0.9.2",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "ouroboros"
+version = "0.15.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e1358bd1558bd2a083fed428ffeda486fbfb323e698cdda7794259d592ca72db"
+dependencies = [
+ "aliasable",
+ "ouroboros_macro",
+]
+
+[[package]]
+name = "ouroboros_macro"
+version = "0.15.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f7d21ccd03305a674437ee1248f3ab5d4b1db095cf1caf49f1713ddf61956b7"
+dependencies = [
+ "Inflector",
+ "proc-macro-error",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "p256"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c9863ad85fa8f4460f9c48cb909d38a0d689dba1f6f6988a5e3e0d31071bcd4b"
+dependencies = [
+ "ecdsa",
+ "elliptic-curve",
+ "primeorder",
+ "sha2 0.10.9",
+]
+
+[[package]]
+name = "pairing"
+version = "0.23.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81fec4625e73cf41ef4bb6846cafa6d44736525f442ba45e407c4a000a13996f"
+dependencies = [
+ "group",
+]
+
+[[package]]
+name = "parity-scale-codec"
+version = "3.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "799781ae679d79a948e13d4824a40970bfa500058d245760dd857301059810fa"
+dependencies = [
+ "arrayvec 0.7.6",
+ "bitvec",
+ "byte-slice-cast",
+ "const_format",
+ "impl-trait-for-tuples",
+ "parity-scale-codec-derive",
+ "rustversion",
+ "serde",
+]
+
+[[package]]
+name = "parity-scale-codec-derive"
+version = "3.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34b4653168b563151153c9e4c08ebed57fb8262bebfa79711552fa983c623e7a"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "parking"
+version = "2.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"
+
+[[package]]
+name = "parking_lot"
+version = "0.12.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
+dependencies = [
+ "lock_api",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "parking_lot_core"
+version = "0.9.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "redox_syscall 0.5.18",
+ "smallvec",
+ "windows-link",
+]
+
+[[package]]
+name = "parse-zoneinfo"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f2a05b18d44e2957b88f96ba460715e295bc1d7510468a2f3d3b44535d26c24"
+dependencies = [
+ "regex",
+]
+
+[[package]]
+name = "passkey-types"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "499cff8432e71c5f8784d9645aac0f9fca604d67f59b68a606170b5e229c6538"
+dependencies = [
+ "bitflags 2.10.0",
+ "ciborium",
+ "coset",
+ "data-encoding",
+ "indexmap 2.13.0",
+ "rand 0.8.5",
+ "serde",
+ "serde_json",
+ "sha2 0.10.9",
+ "strum 0.25.0",
+ "typeshare",
+]
+
+[[package]]
+name = "pasta_curves"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3e57598f73cc7e1b2ac63c79c517b31a0877cd7c402cdcaa311b5208de7a095"
+dependencies = [
+ "blake2b_simd",
+ "ff",
+ "group",
+ "hex",
+ "lazy_static",
+ "rand 0.8.5",
+ "serde",
+ "static_assertions",
+ "subtle",
+]
+
+[[package]]
+name = "paste"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"
+
+[[package]]
+name = "pbjson"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "048f9ac93c1eab514f9470c4bc8d97ca2a0a236b84f45cc19d69a59fc11467f6"
+dependencies = [
+ "base64 0.13.1",
+ "serde",
+]
+
+[[package]]
+name = "pbkdf2"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "83a0692ec44e4cf1ef28ca317f14f8f07da2d95ec3fa01f86e4467b725e60917"
+dependencies = [
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "pem"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8835c273a76a90455d7344889b0964598e3316e2a79ede8e36f16bdcf2228b8"
+dependencies = [
+ "base64 0.13.1",
+]
+
+[[package]]
+name = "pem-rfc7468"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
+dependencies = [
+ "base64ct",
+]
+
+[[package]]
+name = "percent-encoding"
+version = "2.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"
+
+[[package]]
+name = "percentage"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2fd23b938276f14057220b707937bcb42fa76dda7560e57a2da30cb52d557937"
+dependencies = [
+ "num 0.2.1",
+]
+
+[[package]]
+name = "pest"
+version = "2.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c9eb05c21a464ea704b53158d358a31e6425db2f63a1a7312268b05fe2b75f7"
+dependencies = [
+ "memchr",
+ "ucd-trie",
+]
+
+[[package]]
+name = "pest_derive"
+version = "2.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68f9dbced329c441fa79d80472764b1a2c7e57123553b8519b36663a2fb234ed"
+dependencies = [
+ "pest",
+ "pest_generator",
+]
+
+[[package]]
+name = "pest_generator"
+version = "2.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3bb96d5051a78f44f43c8f712d8e810adb0ebf923fc9ed2655a7f66f63ba8ee5"
+dependencies = [
+ "pest",
+ "pest_meta",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "pest_meta"
+version = "2.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "602113b5b5e8621770cfd490cfd90b9f84ab29bd2b0e49ad83eb6d186cef2365"
+dependencies = [
+ "pest",
+ "sha2 0.10.9",
+]
+
+[[package]]
+name = "petgraph"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b4c5cc86750666a3ed20bdaf5ca2a0344f9c67674cae0515bec2da16fbaa47db"
+dependencies = [
+ "fixedbitset",
+ "indexmap 2.13.0",
+]
+
+[[package]]
+name = "phf"
+version = "0.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fd6780a80ae0c52cc120a26a1a42c1ae51b247a253e4e06113d23d2c2edd078"
+dependencies = [
+ "phf_shared 0.11.3",
+]
+
+[[package]]
+name = "phf"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "913273894cec178f401a31ec4b656318d95473527be05c0752cc41cdc32be8b7"
+dependencies = [
+ "phf_shared 0.12.1",
+]
+
+[[package]]
+name = "phf_codegen"
+version = "0.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aef8048c789fa5e851558d709946d6d79a8ff88c0440c587967f8e94bfb1216a"
+dependencies = [
+ "phf_generator",
+ "phf_shared 0.11.3",
+]
+
+[[package]]
+name = "phf_generator"
+version = "0.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3c80231409c20246a13fddb31776fb942c38553c51e871f8cbd687a4cfb5843d"
+dependencies = [
+ "phf_shared 0.11.3",
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "phf_shared"
+version = "0.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67eabc2ef2a60eb7faa00097bd1ffdb5bd28e62bf39990626a582201b7a754e5"
+dependencies = [
+ "siphasher 1.0.1",
+]
+
+[[package]]
+name = "phf_shared"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06005508882fb681fd97892ecff4b7fd0fee13ef1aa569f8695dae7ab9099981"
+dependencies = [
+ "siphasher 1.0.1",
+]
+
+[[package]]
+name = "pin-project"
+version = "1.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
+dependencies = [
+ "pin-project-internal",
+]
+
+[[package]]
+name = "pin-project-internal"
+version = "1.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "pin-project-lite"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"
+
+[[package]]
+name = "pin-utils"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
+
+[[package]]
+name = "pkcs1"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
+dependencies = [
+ "der",
+ "pkcs8",
+ "spki",
+]
+
+[[package]]
+name = "pkcs8"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
+dependencies = [
+ "der",
+ "spki",
+]
+
+[[package]]
+name = "pkg-config"
+version = "0.3.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"
+
+[[package]]
+name = "plotters"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5aeb6f403d7a4911efb1e33402027fc44f29b5bf6def3effcc22d7bb75f2b747"
+dependencies = [
+ "num-traits",
+ "plotters-backend",
+ "plotters-svg",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "plotters-backend"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df42e13c12958a16b3f7f4386b9ab1f3e7933914ecea48da7139435263a4172a"
+
+[[package]]
+name = "plotters-svg"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51bae2ac328883f7acdfea3d66a7c35751187f870bc81f94563733a154d7a670"
+dependencies = [
+ "plotters-backend",
+]
+
+[[package]]
+name = "poem"
+version = "3.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9f977080932c87287147dca052951c3e2696f8759863f6b4e4c0c9ffe7a4cc8b"
+dependencies = [
+ "anyhow",
+ "async-compression",
+ "bytes",
+ "futures-util",
+ "headers",
+ "http 1.4.0",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-util",
+ "mime",
+ "multer",
+ "nix",
+ "parking_lot",
+ "percent-encoding",
+ "pin-project-lite",
+ "poem-derive",
+ "quick-xml",
+ "regex",
+ "rfc7239",
+ "rustls-pemfile 2.2.0",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "serde_yaml 0.9.34+deprecated",
+ "smallvec",
+ "sync_wrapper 1.0.2",
+ "tempfile",
+ "thiserror 2.0.18",
+ "tokio",
+ "tokio-rustls",
+ "tokio-stream",
+ "tokio-util",
+ "tracing",
+ "wildmatch",
+]
+
+[[package]]
+name = "poem-derive"
+version = "3.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "056e2fea6de1cb240ffe23cfc4fc370b629f8be83b5f27e16b7acd5231a72de4"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "poem-openapi"
+version = "5.1.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ccbcc395bf4dd03df1da32da351b6b6732e4074ce27ddec315650e52a2be44c"
+dependencies = [
+ "base64 0.22.1",
+ "bytes",
+ "derive_more 2.1.1",
+ "futures-util",
+ "indexmap 2.13.0",
+ "itertools 0.14.0",
+ "mime",
+ "num-traits",
+ "poem",
+ "poem-openapi-derive",
+ "quick-xml",
+ "regex",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "serde_yaml 0.9.34+deprecated",
+ "thiserror 2.0.18",
+ "tokio",
+ "url",
+]
+
+[[package]]
+name = "poem-openapi-derive"
+version = "5.1.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41273b691a3d467a8c44d05506afba9f7b6bd56c9cdf80123de13fe52d7ec587"
+dependencies = [
+ "darling 0.20.11",
+ "http 1.4.0",
+ "indexmap 2.13.0",
+ "mime",
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "syn 2.0.114",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "polyval"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d1fe60d06143b2430aa532c94cfe9e29783047f06c0d7fd359a9a51b729fa25"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "opaque-debug",
+ "universal-hash",
+]
+
+[[package]]
+name = "pomelo"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76dd249f63dbbc68c8caa9b5fd16b32c7ba5da56df93d40a9552c91ebfd2a1cd"
+dependencies = [
+ "pomelo-impl",
+]
+
+[[package]]
+name = "pomelo-impl"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "597c3287a549da151aca6ada2795ecde089c7527bd5093114e8e0e1c3f0e52b1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "portable-atomic"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f89776e4d69bb58bc6993e99ffa1d11f228b839984854c7daeb5d37f87cbe950"
+
+[[package]]
+name = "potential_utf"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b73949432f5e2a09657003c25bca5e19a0e9c84f8058ca374f49e0ebe605af77"
+dependencies = [
+ "zerovec",
+]
+
+[[package]]
+name = "powerfmt"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
+
+[[package]]
+name = "ppv-lite86"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
+dependencies = [
+ "zerocopy",
+]
+
+[[package]]
+name = "pretty"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ad9940b913ee56ddd94aec2d3cd179dd47068236f42a1a6415ccf9d880ce2a61"
+dependencies = [
+ "arrayvec 0.5.2",
+ "typed-arena",
+]
+
+[[package]]
+name = "primeorder"
+version = "0.13.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "353e1ca18966c16d9deb1c69278edbc5f194139612772bd9537af60ac231e1e6"
+dependencies = [
+ "elliptic-curve",
+]
+
+[[package]]
+name = "primitive-types"
+version = "0.12.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b34d9fd68ae0b74a41b21c03c2f62847aa0ffea044eee893b4c140b37e244e2"
+dependencies = [
+ "fixed-hash",
+ "impl-codec",
+ "uint",
+]
+
+[[package]]
+name = "proc-macro-crate"
+version = "3.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "219cb19e96be00ab2e37d6e299658a0cfa83e52429179969b0f0121b4ac46983"
+dependencies = [
+ "toml_edit 0.23.10+spec-1.0.0",
+]
+
+[[package]]
+name = "proc-macro-error"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
+dependencies = [
+ "proc-macro-error-attr",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+ "version_check",
+]
+
+[[package]]
+name = "proc-macro-error-attr"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "version_check",
+]
+
+[[package]]
+name = "proc-macro-error-attr2"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96de42df36bb9bba5542fe9f1a054b8cc87e172759a1868aa05c1f3acc89dfc5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+]
+
+[[package]]
+name = "proc-macro-error2"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11ec05c52be0a07b08061f7dd003e7d7092e0472bc731b4af7bb1ef876109802"
+dependencies = [
+ "proc-macro-error-attr2",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "proc-macro-hack"
+version = "0.5.20+deprecated"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"
+
+[[package]]
+name = "proc-macro-nested"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bc881b2c22681370c6a780e47af9840ef841837bc98118431d4e1868bd0c1086"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.105"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "535d180e0ecab6268a3e718bb9fd44db66bbbc256257165fc699dadf70d16fe7"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "prometheus"
+version = "0.13.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d33c28a30771f7f96db69893f78b857f7450d7e0237e9c8fc6427a81bae7ed1"
+dependencies = [
+ "cfg-if",
+ "fnv",
+ "lazy_static",
+ "memchr",
+ "parking_lot",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "proptest"
+version = "1.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bee689443a2bd0a16ab0348b52ee43e3b2d1b1f931c8aa5c9f8de4c86fbe8c40"
+dependencies = [
+ "bit-set",
+ "bit-vec",
+ "bitflags 2.10.0",
+ "num-traits",
+ "rand 0.9.2",
+ "rand_chacha 0.9.0",
+ "rand_xorshift 0.4.0",
+ "regex-syntax",
+ "rusty-fork",
+ "tempfile",
+ "unarray",
+]
+
+[[package]]
+name = "proptest-derive"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ee1c9ac207483d5e7db4940700de86a9aae46ef90c48b57f99fe7edb8345e49"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "prost"
+version = "0.13.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2796faa41db3ec313a31f7624d9286acf277b52de526150b7e69f3debf891ee5"
+dependencies = [
+ "bytes",
+ "prost-derive 0.13.5",
+]
+
+[[package]]
+name = "prost"
+version = "0.14.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d2ea70524a2f82d518bce41317d0fae74151505651af45faf1ffbd6fd33f0568"
+dependencies = [
+ "bytes",
+ "prost-derive 0.14.3",
+]
+
+[[package]]
+name = "prost-derive"
+version = "0.13.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a56d757972c98b346a9b766e3f02746cde6dd1cd1d1d563472929fdd74bec4d"
+dependencies = [
+ "anyhow",
+ "itertools 0.12.1",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "prost-derive"
+version = "0.14.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "27c6023962132f4b30eb4c172c91ce92d933da334c59c23cddee82358ddafb0b"
+dependencies = [
+ "anyhow",
+ "itertools 0.12.1",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "prost-types"
+version = "0.13.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52c2c1bf36ddb1a1c396b3601a3cec27c2462e45f07c386894ec3ccf5332bd16"
+dependencies = [
+ "prost 0.13.5",
+]
+
+[[package]]
+name = "psl-types"
+version = "2.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33cb294fe86a74cbcf50d4445b37da762029549ebeea341421c7c70370f86cac"
+
+[[package]]
+name = "ptr_meta"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0738ccf7ea06b608c10564b31debd4f5bc5e197fc8bfe088f68ae5ce81e7a4f1"
+dependencies = [
+ "ptr_meta_derive",
+]
+
+[[package]]
+name = "ptr_meta_derive"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "16b845dbfca988fa33db069c0e230574d15a3088f147a87b64c7589eb662c9ac"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "publicsuffix"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f42ea446cab60335f76979ec15e12619a2165b5ae2c12166bef27d283a9fadf"
+dependencies = [
+ "idna 1.1.0",
+ "psl-types",
+]
+
+[[package]]
+name = "qstring"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d464fae65fff2680baf48019211ce37aaec0c78e9264c84a3e484717f965104e"
+dependencies = [
+ "percent-encoding",
+]
+
+[[package]]
+name = "quanta"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f3ab5a9d756f0d97bdc89019bd2e4ea098cf9cde50ee7564dde6b81ccc8f06c7"
+dependencies = [
+ "crossbeam-utils",
+ "libc",
+ "once_cell",
+ "raw-cpuid",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "web-sys",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "quick-error"
+version = "1.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"
+
+[[package]]
+name = "quick-xml"
+version = "0.36.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f7649a7b4df05aed9ea7ec6f628c67c9953a43869b8bc50929569b2999d443fe"
+dependencies = [
+ "memchr",
+ "serde",
+]
+
+[[package]]
+name = "quick_cache"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eb55a1aa7668676bb93926cd4e9cdfe60f03bb866553bcca9112554911b6d3dc"
+dependencies = [
+ "ahash 0.8.12",
+ "equivalent",
+ "hashbrown 0.14.5",
+ "parking_lot",
+]
+
+[[package]]
+name = "quinn"
+version = "0.11.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9e20a958963c291dc322d98411f541009df2ced7b5a4f2bd52337638cfccf20"
+dependencies = [
+ "bytes",
+ "cfg_aliases",
+ "pin-project-lite",
+ "quinn-proto",
+ "quinn-udp",
+ "rustc-hash",
+ "rustls",
+ "socket2 0.6.1",
+ "thiserror 2.0.18",
+ "tokio",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-proto"
+version = "0.11.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1906b49b0c3bc04b5fe5d86a77925ae6524a19b816ae38ce1e426255f1d8a31"
+dependencies = [
+ "aws-lc-rs",
+ "bytes",
+ "fastbloom",
+ "getrandom 0.3.4",
+ "lru-slab",
+ "rand 0.9.2",
+ "ring 0.17.14",
+ "rustc-hash",
+ "rustls",
+ "rustls-pki-types",
+ "rustls-platform-verifier",
+ "slab",
+ "thiserror 2.0.18",
+ "tinyvec",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-udp"
+version = "0.5.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "addec6a0dcad8a8d96a771f815f0eaf55f9d1805756410b39f5fa81332574cbd"
+dependencies = [
+ "cfg_aliases",
+ "libc",
+ "once_cell",
+ "socket2 0.6.1",
+ "tracing",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.43"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc74d9a594b72ae6656596548f56f667211f8a97b3d4c3d467150794690dc40a"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "r-efi"
+version = "5.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"
+
+[[package]]
+name = "radium"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"
+
+[[package]]
+name = "rand"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
+dependencies = [
+ "getrandom 0.1.16",
+ "libc",
+ "rand_chacha 0.2.2",
+ "rand_core 0.5.1",
+ "rand_hc",
+]
+
+[[package]]
+name = "rand"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
+dependencies = [
+ "libc",
+ "rand_chacha 0.3.1",
+ "rand_core 0.6.4",
+ "serde",
+]
+
+[[package]]
+name = "rand"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
+dependencies = [
+ "rand_chacha 0.9.0",
+ "rand_core 0.9.5",
+ "serde",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.5.1",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.9.5",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
+dependencies = [
+ "getrandom 0.1.16",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
+dependencies = [
+ "getrandom 0.2.17",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76afc826de14238e6e8c374ddcc1fa19e374fd8dd986b0d2af0d02377261d83c"
+dependencies = [
+ "getrandom 0.3.4",
+ "serde",
+]
+
+[[package]]
+name = "rand_hc"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
+dependencies = [
+ "rand_core 0.5.1",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d25bf25ec5ae4a3f1b92f929810509a2f53d7dca2f50b794ff57e3face536c8f"
+dependencies = [
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "513962919efc330f829edb2535844d1b912b0fbe2ca165d613e4e8788bb05a5a"
+dependencies = [
+ "rand_core 0.9.5",
+]
+
+[[package]]
+name = "rand_xoshiro"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa"
+dependencies = [
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rapidhash"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9813f789f95ee4fe6b4d01834404d7cccacbc3f6c029343af910b3c2835eb9f1"
+
+[[package]]
+name = "rapidhash"
+version = "4.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d8b5b858a440a0bc02625b62dd95131b9201aa9f69f411195dd4a7cfb1de3d7"
+dependencies = [
+ "rustversion",
+]
+
+[[package]]
+name = "raw-cpuid"
+version = "11.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "498cd0dc59d73224351ee52a95fee0f1a617a2eae0e7d9d720cc622c73a54186"
+dependencies = [
+ "bitflags 2.10.0",
+]
+
+[[package]]
+name = "rayon"
+version = "1.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
+dependencies = [
+ "either",
+ "rayon-core",
+]
+
+[[package]]
+name = "rayon-core"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
+dependencies = [
+ "crossbeam-deque",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.5.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
+dependencies = [
+ "bitflags 2.10.0",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49f3fe0889e69e2ae9e41f4d6c4c0181701d00e4697b356fb1f74173a5e0ee27"
+dependencies = [
+ "bitflags 2.10.0",
+]
+
+[[package]]
+name = "redox_users"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
+dependencies = [
+ "getrandom 0.2.17",
+ "libredox",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "ref-cast"
+version = "1.0.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f354300ae66f76f1c85c5f84693f0ce81d747e2c3f21a45fef496d89c960bf7d"
+dependencies = [
+ "ref-cast-impl",
+]
+
+[[package]]
+name = "ref-cast-impl"
+version = "1.0.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b7186006dcb21920990093f30e3dea63b7d6e977bf1256be20c3563a5db070da"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "regex"
+version = "1.12.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "843bc0191f75f3e22651ae5f1e72939ab2f72a4bc30fa80a066bd66edefc24d4"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"
+
+[[package]]
+name = "rend"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "71fe3824f5629716b1589be05dacd749f6aa084c87e00e016714a8cdfccc997c"
+dependencies = [
+ "bytecheck",
+]
+
+[[package]]
+name = "reqwest"
+version = "0.11.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd67538700a17451e7cba03ac727fb961abb7607553461627b97de0b89cf4a62"
+dependencies = [
+ "base64 0.21.7",
+ "bytes",
+ "cookie",
+ "cookie_store",
+ "encoding_rs",
+ "futures-core",
+ "futures-util",
+ "h2 0.3.27",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "hyper 0.14.32",
+ "hyper-tls 0.5.0",
+ "ipnet",
+ "js-sys",
+ "log",
+ "mime",
+ "mime_guess",
+ "native-tls",
+ "once_cell",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustls-pemfile 1.0.4",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper 0.1.2",
+ "system-configuration",
+ "tokio",
+ "tokio-native-tls",
+ "tokio-util",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "wasm-streams",
+ "web-sys",
+ "winreg",
+]
+
+[[package]]
+name = "reqwest"
+version = "0.12.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eddd3ca559203180a307f12d114c268abf583f59b03cb906fd0b3ff8646c1147"
+dependencies = [
+ "base64 0.22.1",
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-rustls",
+ "hyper-tls 0.6.0",
+ "hyper-util",
+ "js-sys",
+ "log",
+ "native-tls",
+ "percent-encoding",
+ "pin-project-lite",
+ "quinn",
+ "rustls",
+ "rustls-pki-types",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tokio-native-tls",
+ "tokio-rustls",
+ "tower 0.5.3",
+ "tower-http",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+ "webpki-roots 1.0.5",
+]
+
+[[package]]
+name = "reqwest"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "04e9018c9d814e5f30cc16a0f03271aeab3571e609612d9fe78c1aa8d11c2f62"
+dependencies = [
+ "base64 0.22.1",
+ "bytes",
+ "encoding_rs",
+ "futures-core",
+ "h2 0.4.13",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-rustls",
+ "hyper-util",
+ "js-sys",
+ "log",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "quinn",
+ "rustls",
+ "rustls-pki-types",
+ "rustls-platform-verifier",
+ "serde",
+ "serde_json",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tokio-rustls",
+ "tower 0.5.3",
+ "tower-http",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+]
+
+[[package]]
+name = "reqwest-middleware"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57f17d28a6e6acfe1733fe24bcd30774d13bffa4b8a22535b4c8c98423088d4e"
+dependencies = [
+ "anyhow",
+ "async-trait",
+ "http 1.4.0",
+ "reqwest 0.12.28",
+ "serde",
+ "thiserror 1.0.69",
+ "tower-service",
+]
+
+[[package]]
+name = "reqwest-middleware"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f42e2f48018a33d679ee7f477a446b697663a14e91ab0b3a0206792a22dd3aa8"
+dependencies = [
+ "anyhow",
+ "async-trait",
+ "http 1.4.0",
+ "reqwest 0.13.1",
+ "serde",
+ "thiserror 2.0.18",
+ "tower-service",
+]
+
+[[package]]
+name = "rfc6979"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f8dd2a808d456c4a54e300a23e9f5a67e122c3024119acbfd73e3bf664491cb2"
+dependencies = [
+ "hmac 0.12.1",
+ "subtle",
+]
+
+[[package]]
+name = "rfc7239"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a82f1d1e38e9a85bb58ffcfadf22ed6f2c94e8cd8581ec2b0f80a2a6858350f"
+dependencies = [
+ "uncased",
+]
+
+[[package]]
+name = "ring"
+version = "0.16.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3053cf52e236a3ed746dfc745aa9cacf1b791d846bdaf412f60a8d7d6e17c8fc"
+dependencies = [
+ "cc",
+ "libc",
+ "once_cell",
+ "spin 0.5.2",
+ "untrusted 0.7.1",
+ "web-sys",
+ "winapi 0.3.9",
+]
+
+[[package]]
+name = "ring"
+version = "0.17.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
+dependencies = [
+ "cc",
+ "cfg-if",
+ "getrandom 0.2.17",
+ "libc",
+ "untrusted 0.9.0",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "ripemd"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd124222d17ad93a644ed9d011a40f4fb64aa54275c08cc216524a9ea82fb09f"
+dependencies = [
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "rkyv"
+version = "0.7.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2297bf9c81a3f0dc96bc9521370b88f054168c29826a75e89c55ff196e7ed6a1"
+dependencies = [
+ "bitvec",
+ "bytecheck",
+ "bytes",
+ "hashbrown 0.12.3",
+ "ptr_meta",
+ "rend",
+ "rkyv_derive",
+ "seahash",
+ "tinyvec",
+ "uuid",
+]
+
+[[package]]
+name = "rkyv_derive"
+version = "0.7.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84d7b42d4b8d06048d3ac8db0eb31bcb942cbeb709f0b5f2b2ebde398d3038f5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "rlp"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb919243f34364b6bd2fc10ef797edbfa75f33c252e7998527479c6d6b47e1ec"
+dependencies = [
+ "bytes",
+ "rustc-hex",
+]
+
+[[package]]
+name = "rsa"
+version = "0.9.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8573f03f5883dcaebdfcf4725caa1ecb9c15b2ef50c43a07b816e06799bb12d"
+dependencies = [
+ "const-oid",
+ "digest 0.10.7",
+ "num-bigint-dig",
+ "num-integer",
+ "num-traits",
+ "pkcs1",
+ "pkcs8",
+ "rand_core 0.6.4",
+ "signature 2.2.0",
+ "spki",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "ruint"
+version = "1.17.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c141e807189ad38a07276942c6623032d3753c8859c146104ac2e4d68865945a"
+dependencies = [
+ "alloy-rlp",
+ "ark-ff 0.3.0",
+ "ark-ff 0.4.2",
+ "ark-ff 0.5.0",
+ "bytes",
+ "fastrlp 0.3.1",
+ "fastrlp 0.4.0",
+ "num-bigint 0.4.6",
+ "num-integer",
+ "num-traits",
+ "parity-scale-codec",
+ "primitive-types",
+ "proptest",
+ "rand 0.8.5",
+ "rand 0.9.2",
+ "rlp",
+ "ruint-macro",
+ "serde_core",
+ "valuable",
+ "zeroize",
+]
+
+[[package]]
+name = "ruint-macro"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48fd7bd8a6377e15ad9d42a8ec25371b94ddc67abe7c8b9127bec79bebaaae18"
+
+[[package]]
+name = "rust_decimal"
+version = "1.40.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "61f703d19852dbf87cbc513643fa81428361eb6940f1ac14fd58155d295a3eb0"
+dependencies = [
+ "arrayvec 0.7.6",
+ "borsh",
+ "bytes",
+ "num-traits",
+ "rand 0.8.5",
+ "rkyv",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "rustc-demangle"
+version = "0.1.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b50b8869d9fc858ce7266cce0194bd74df58b9d0e3f6df3a9fc8eb470d95c09d"
+
+[[package]]
+name = "rustc-hash"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"
+
+[[package]]
+name = "rustc-hex"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6"
+
+[[package]]
+name = "rustc_version"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f0dfe2087c51c460008730de8b57e6a320782fbfb312e1f4d520e6c6fae155ee"
+dependencies = [
+ "semver 0.11.0",
+]
+
+[[package]]
+name = "rustc_version"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
+dependencies = [
+ "semver 1.0.27",
+]
+
+[[package]]
+name = "rusticata-macros"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "faf0c4a6ece9950b9abdb62b1cfcf2a68b3b67a10ba445b3bb85be2a293d0632"
+dependencies = [
+ "nom",
+]
+
+[[package]]
+name = "rustix"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "146c9e247ccc180c1f61615433868c99f3de3ae256a30a43b49f67c2d9171f34"
+dependencies = [
+ "bitflags 2.10.0",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "rustls"
+version = "0.23.36"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c665f33d38cea657d9614f766881e4d510e0eda4239891eea56b4cadcf01801b"
+dependencies = [
+ "aws-lc-rs",
+ "log",
+ "once_cell",
+ "ring 0.17.14",
+ "rustls-pki-types",
+ "rustls-webpki",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "rustls-native-certs"
+version = "0.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "612460d5f7bea540c490b2b6395d8e34a953e52b491accd6c86c8164c5932a63"
+dependencies = [
+ "openssl-probe 0.2.0",
+ "rustls-pki-types",
+ "schannel",
+ "security-framework 3.5.1",
+]
+
+[[package]]
+name = "rustls-pemfile"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c"
+dependencies = [
+ "base64 0.21.7",
+]
+
+[[package]]
+name = "rustls-pemfile"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dce314e5fee3f39953d46bb63bb8a46d40c2f8fb7cc5a3b6cab2bde9721d6e50"
+dependencies = [
+ "rustls-pki-types",
+]
+
+[[package]]
+name = "rustls-pki-types"
+version = "1.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be040f8b0a225e40375822a563fa9524378b9d63112f53e19ffff34df5d33fdd"
+dependencies = [
+ "web-time",
+ "zeroize",
+]
+
+[[package]]
+name = "rustls-platform-verifier"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d99feebc72bae7ab76ba994bb5e121b8d83d910ca40b36e0921f53becc41784"
+dependencies = [
+ "core-foundation 0.10.1",
+ "core-foundation-sys",
+ "jni",
+ "log",
+ "once_cell",
+ "rustls",
+ "rustls-native-certs",
+ "rustls-platform-verifier-android",
+ "rustls-webpki",
+ "security-framework 3.5.1",
+ "security-framework-sys",
+ "webpki-root-certs",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "rustls-platform-verifier-android"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f87165f0995f63a9fbeea62b64d10b4d9d8e78ec6d7d51fb2125fda7bb36788f"
+
+[[package]]
+name = "rustls-webpki"
+version = "0.103.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7df23109aa6c1567d1c575b9952556388da57401e4ace1d15f79eedad0d8f53"
+dependencies = [
+ "aws-lc-rs",
+ "ring 0.17.14",
+ "rustls-pki-types",
+ "untrusted 0.9.0",
+]
+
+[[package]]
+name = "rustversion"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"
+
+[[package]]
+name = "rusty-fork"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc6bf79ff24e648f6da1f8d1f011e9cac26491b619e6b9280f2b47f1774e6ee2"
+dependencies = [
+ "fnv",
+ "quick-error",
+ "tempfile",
+ "wait-timeout",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a50f4cf475b65d88e057964e0e9bb1f0aa9bbb2036dc65c64596b42932536984"
+
+[[package]]
+name = "same-file"
+version = "1.0.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "schannel"
+version = "0.1.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "891d81b926048e76efe18581bf793546b4c0eaf8448d72be8de2bbee5fd166e1"
+dependencies = [
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "schemars"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4cd191f9397d57d581cddd31014772520aa448f65ef991055d7f61582c65165f"
+dependencies = [
+ "dyn-clone",
+ "ref-cast",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "schemars"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "54e910108742c57a770f492731f99be216a52fadd361b06c8fb59d74ccc267d2"
+dependencies = [
+ "dyn-clone",
+ "ref-cast",
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "scopeguard"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+
+[[package]]
+name = "seahash"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"
+
+[[package]]
+name = "sec1"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3e97a565f76233a6003f9f5c54be1d9c5bdfa3eccfb189469f11ec4901c47dc"
+dependencies = [
+ "base16ct",
+ "der",
+ "generic-array",
+ "pkcs8",
+ "serdect",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "secp256k1"
+version = "0.30.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b50c5943d326858130af85e049f2661ba3c78b26589b8ab98e65e80ae44a1252"
+dependencies = [
+ "bitcoin_hashes",
+ "rand 0.8.5",
+ "secp256k1-sys",
+ "serde",
+]
+
+[[package]]
+name = "secp256k1-sys"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4387882333d3aa8cb20530a17c69a3752e97837832f34f6dccc760e715001d9"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "security-framework"
+version = "2.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
+dependencies = [
+ "bitflags 2.10.0",
+ "core-foundation 0.9.4",
+ "core-foundation-sys",
+ "libc",
+ "security-framework-sys",
+]
+
+[[package]]
+name = "security-framework"
+version = "3.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b3297343eaf830f66ede390ea39da1d462b6b0c1b000f420d0a83f898bbbe6ef"
+dependencies = [
+ "bitflags 2.10.0",
+ "core-foundation 0.10.1",
+ "core-foundation-sys",
+ "libc",
+ "security-framework-sys",
+]
+
+[[package]]
+name = "security-framework-sys"
+version = "2.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc1f0cbffaac4852523ce30d8bd3c5cdc873501d96ff467ca09b6767bb8cd5c0"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "semver"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6"
+dependencies = [
+ "semver-parser",
+]
+
+[[package]]
+name = "semver"
+version = "1.0.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"
+
+[[package]]
+name = "semver-parser"
+version = "0.10.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9900206b54a3527fdc7b8a938bffd94a568bac4f4aa8113b209df75a09c0dec2"
+dependencies = [
+ "pest",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.228"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
+dependencies = [
+ "serde_core",
+ "serde_derive",
+]
+
+[[package]]
+name = "serde-big-array"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11fc7cc2c76d73e0f27ee52abbd64eec84d46f370c88371120433196934e4b7f"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "serde-generate"
+version = "0.20.6"
+source = "git+https://github.com/aptos-labs/serde-reflection?rev=73b6bbf748334b71ff6d7d09d06a29e3062ca075#73b6bbf748334b71ff6d7d09d06a29e3062ca075"
+dependencies = [
+ "bcs 0.1.6",
+ "bincode",
+ "heck 0.3.3",
+ "include_dir",
+ "maplit",
+ "serde",
+ "serde-reflection",
+ "serde_bytes",
+ "serde_yaml 0.8.26",
+ "structopt",
+ "textwrap 0.13.4",
+]
+
+[[package]]
+name = "serde-name"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b5b14ebbcc4e4f2b3642fa99c388649da58d1dc3308c7d109f39f565d1710f0"
+dependencies = [
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "serde-reflection"
+version = "0.3.5"
+source = "git+https://github.com/aptos-labs/serde-reflection?rev=73b6bbf748334b71ff6d7d09d06a29e3062ca075#73b6bbf748334b71ff6d7d09d06a29e3062ca075"
+dependencies = [
+ "once_cell",
+ "serde",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "serde_bytes"
+version = "0.11.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5d440709e79d88e51ac01c4b72fc6cb7314017bb7da9eeff678aa94c10e3ea8"
+dependencies = [
+ "serde",
+ "serde_core",
+]
+
+[[package]]
+name = "serde_cbor"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2bef2ebfde456fb76bbcf9f59315333decc4fda0b2b44b420243c11e0f5ec1f5"
+dependencies = [
+ "half 1.8.3",
+ "serde",
+]
+
+[[package]]
+name = "serde_core"
+version = "1.0.228"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.228"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.149"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "83fc039473c5595ace860d8c4fafa220ff474b3fc6bfdb4293327f1a37e94d86"
+dependencies = [
+ "indexmap 2.13.0",
+ "itoa",
+ "memchr",
+ "serde",
+ "serde_core",
+ "zmij",
+]
+
+[[package]]
+name = "serde_merge"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "606e91878516232ac3b16c12e063d4468d762f16d77e7aef14a1f2326c5f409b"
+dependencies = [
+ "serde",
+ "serde_json",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "serde_path_to_error"
+version = "0.1.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "10a9ff822e371bb5403e391ecd83e182e0e77ba7f6fe0160b795797109d1b457"
+dependencies = [
+ "itoa",
+ "serde",
+ "serde_core",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "0.6.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "serde_urlencoded"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
+dependencies = [
+ "form_urlencoded",
+ "itoa",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_with"
+version = "3.16.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4fa237f2807440d238e0364a218270b98f767a00d3dada77b1c53ae88940e2e7"
+dependencies = [
+ "base64 0.22.1",
+ "chrono",
+ "hex",
+ "indexmap 1.9.3",
+ "indexmap 2.13.0",
+ "schemars 0.9.0",
+ "schemars 1.2.0",
+ "serde_core",
+ "serde_json",
+ "serde_with_macros",
+ "time",
+]
+
+[[package]]
+name = "serde_with_macros"
+version = "3.16.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52a8e3ca0ca629121f70ab50f95249e5a6f925cc0f6ffe8256c45b728875706c"
+dependencies = [
+ "darling 0.21.3",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "serde_yaml"
+version = "0.8.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "578a7433b776b56a35785ed5ce9a7e777ac0598aac5a6dd1b4b18a307c7fc71b"
+dependencies = [
+ "indexmap 1.9.3",
+ "ryu",
+ "serde",
+ "yaml-rust",
+]
+
+[[package]]
+name = "serde_yaml"
+version = "0.9.34+deprecated"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
+dependencies = [
+ "indexmap 2.13.0",
+ "itoa",
+ "ryu",
+ "serde",
+ "unsafe-libyaml",
+]
+
+[[package]]
+name = "serdect"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a84f14a19e9a014bb9f4512488d9829a68e04ecabffb0f9904cd1ace94598177"
+dependencies = [
+ "base16ct",
+ "serde",
+]
+
+[[package]]
+name = "sha1"
+version = "0.10.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "sha2"
+version = "0.9.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4d58a1e1bf39749807d89cf2d98ac2dfa0ff1cb3faa38fbb64dd88ac8013d800"
+dependencies = [
+ "block-buffer 0.9.0",
+ "cfg-if",
+ "cpufeatures",
+ "digest 0.9.0",
+ "opaque-debug",
+]
+
+[[package]]
+name = "sha2"
+version = "0.10.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest 0.10.7",
+]
+
+[[package]]
+name = "sha3"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f81199417d4e5de3f04b1e871023acea7389672c4135918f05aa9cbf2f2fa809"
+dependencies = [
+ "block-buffer 0.9.0",
+ "digest 0.9.0",
+ "keccak",
+ "opaque-debug",
+]
+
+[[package]]
+name = "sha3"
+version = "0.10.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
+dependencies = [
+ "digest 0.10.7",
+ "keccak",
+]
+
+[[package]]
+name = "sha3-asm"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c28efc5e327c837aa837c59eae585fc250715ef939ac32881bcc11677cd02d46"
+dependencies = [
+ "cc",
+ "cfg-if",
+]
+
+[[package]]
+name = "sharded-slab"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
+dependencies = [
+ "lazy_static",
+]
+
+[[package]]
+name = "shlex"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+
+[[package]]
+name = "signal-hook-registry"
+version = "1.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c4db69cba1110affc0e9f7bcd48bbf87b3f4fc7c61fc9155afd4c469eb3d6c1b"
+dependencies = [
+ "errno",
+ "libc",
+]
+
+[[package]]
+name = "signature"
+version = "1.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c"
+
+[[package]]
+name = "signature"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
+dependencies = [
+ "digest 0.10.7",
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "simd-adler32"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e320a6c5ad31d271ad523dcf3ad13e2767ad8b1cb8f047f75a8aeaf8da139da2"
+
+[[package]]
+name = "simdutf8"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3a9fe34e3e7a50316060351f37187a3f546bce95496156754b601a5fa71b76e"
+
+[[package]]
+name = "simple_asn1"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "297f631f50729c8c99b84667867963997ec0b50f32b2a7dbcab828ef0541e8bb"
+dependencies = [
+ "num-bigint 0.4.6",
+ "num-traits",
+ "thiserror 2.0.18",
+ "time",
+]
+
+[[package]]
+name = "siphasher"
+version = "0.3.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"
+
+[[package]]
+name = "siphasher"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56199f7ddabf13fe5074ce809e7d3f42b42ae711800501b5b16ea82ad029c39d"
+
+[[package]]
+name = "sized-chunks"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "16d69225bde7a69b235da73377861095455d298f2b970996eec25ddbb42b3d1e"
+dependencies = [
+ "bitmaps",
+ "typenum",
+]
+
+[[package]]
+name = "slab"
+version = "0.4.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"
+
+[[package]]
+name = "slug"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "882a80f72ee45de3cc9a5afeb2da0331d58df69e4e7d8eeb5d3c7784ae67e724"
+dependencies = [
+ "deunicode",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "smallbitvec"
+version = "2.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d31d263dd118560e1a492922182ab6ca6dc1d03a3bf54e7699993f31a4150e3f"
+
+[[package]]
+name = "smallvec"
+version = "1.15.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "smawk"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"
+
+[[package]]
+name = "smt2parser"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "957720820c5237fbbff199be910433e453479ec91b28c5a20d3dce7ccba52f1d"
+dependencies = [
+ "fst",
+ "num 0.3.1",
+ "pomelo",
+ "structopt",
+]
+
+[[package]]
+name = "socket2"
+version = "0.5.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
+dependencies = [
+ "libc",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "socket2"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17129e116933cf371d018bb80ae557e889637989d8638274fb25622827b03881"
+dependencies = [
+ "libc",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "solana-account"
+version = "3.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "60e0ac2a81ae17e1b3570deb50242ab4cfde50b848b898f57288b6271cc7b71f"
+dependencies = [
+ "bincode",
+ "serde",
+ "serde_bytes",
+ "serde_derive",
+ "solana-account-info",
+ "solana-clock",
+ "solana-instruction-error",
+ "solana-pubkey 4.0.0",
+ "solana-sdk-ids",
+ "solana-sysvar",
+]
+
+[[package]]
+name = "solana-account-decoder"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8464b3fc2a2be746bac737762d0641b36ac6abd8011d42ab39fbac347f7f35c4"
+dependencies = [
+ "Inflector",
+ "base64 0.22.1",
+ "bincode",
+ "bs58",
+ "bv",
+ "serde",
+ "serde_json",
+ "solana-account",
+ "solana-account-decoder-client-types",
+ "solana-address-lookup-table-interface",
+ "solana-clock",
+ "solana-config-interface",
+ "solana-epoch-schedule",
+ "solana-fee-calculator",
+ "solana-instruction",
+ "solana-loader-v3-interface",
+ "solana-nonce",
+ "solana-program-option",
+ "solana-program-pack",
+ "solana-pubkey 3.0.0",
+ "solana-rent",
+ "solana-sdk-ids",
+ "solana-slot-hashes",
+ "solana-slot-history",
+ "solana-stake-interface",
+ "solana-sysvar",
+ "solana-vote-interface",
+ "spl-generic-token",
+ "spl-token-2022-interface",
+ "spl-token-group-interface",
+ "spl-token-interface",
+ "spl-token-metadata-interface",
+ "thiserror 2.0.18",
+ "zstd",
+]
+
+[[package]]
+name = "solana-account-decoder-client-types"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19c4d25af582526effd2ddb30a6d8d1272ec31ad77dbaa7f83d37dc3d8093867"
+dependencies = [
+ "base64 0.22.1",
+ "bs58",
+ "serde",
+ "serde_json",
+ "solana-account",
+ "solana-pubkey 3.0.0",
+ "zstd",
+]
+
+[[package]]
+name = "solana-account-info"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc3397241392f5756925029acaa8515dc70fcbe3d8059d4885d7d6533baf64fd"
+dependencies = [
+ "solana-address 2.0.0",
+ "solana-program-error",
+ "solana-program-memory",
+]
+
+[[package]]
+name = "solana-address"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2ecac8e1b7f74c2baa9e774c42817e3e75b20787134b76cc4d45e8a604488f5"
+dependencies = [
+ "solana-address 2.0.0",
+]
+
+[[package]]
+name = "solana-address"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e37320fd2945c5d654b2c6210624a52d66c3f1f73b653ed211ab91a703b35bdd"
+dependencies = [
+ "borsh",
+ "bytemuck",
+ "bytemuck_derive",
+ "curve25519-dalek 4.1.3",
+ "five8 1.0.0",
+ "five8_const",
+ "serde",
+ "serde_derive",
+ "solana-atomic-u64",
+ "solana-define-syscall 4.0.1",
+ "solana-program-error",
+ "solana-sanitize",
+ "solana-sha256-hasher",
+]
+
+[[package]]
+name = "solana-address-lookup-table-interface"
+version = "3.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e8df0b083c10ce32490410f3795016b1b5d9b4d094658c0a5e496753645b7cd"
+dependencies = [
+ "bincode",
+ "bytemuck",
+ "serde",
+ "serde_derive",
+ "solana-clock",
+ "solana-instruction",
+ "solana-instruction-error",
+ "solana-pubkey 4.0.0",
+ "solana-sdk-ids",
+ "solana-slot-hashes",
+]
+
+[[package]]
+name = "solana-atomic-u64"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a933ff1e50aff72d02173cfcd7511bd8540b027ee720b75f353f594f834216d0"
+dependencies = [
+ "parking_lot",
+]
+
+[[package]]
+name = "solana-borsh"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc402b16657abbfa9991cd5cbfac5a11d809f7e7d28d3bb291baeb088b39060e"
+dependencies = [
+ "borsh",
+]
+
+[[package]]
+name = "solana-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "29944803bf4958eef10dd20d6507001dbaaef4659b2749007cfc36833876c06c"
+dependencies = [
+ "async-trait",
+ "bincode",
+ "dashmap 5.5.3",
+ "futures",
+ "futures-util",
+ "indexmap 2.13.0",
+ "indicatif",
+ "log",
+ "quinn",
+ "rayon",
+ "solana-account",
+ "solana-client-traits",
+ "solana-commitment-config",
+ "solana-connection-cache",
+ "solana-epoch-info",
+ "solana-hash 3.1.0",
+ "solana-instruction",
+ "solana-keypair",
+ "solana-measure",
+ "solana-message",
+ "solana-net-utils",
+ "solana-pubkey 3.0.0",
+ "solana-pubsub-client",
+ "solana-quic-client",
+ "solana-quic-definitions",
+ "solana-rpc-client",
+ "solana-rpc-client-api",
+ "solana-rpc-client-nonce-utils",
+ "solana-signature",
+ "solana-signer",
+ "solana-streamer",
+ "solana-time-utils",
+ "solana-tpu-client",
+ "solana-transaction",
+ "solana-transaction-error",
+ "solana-transaction-status-client-types",
+ "solana-udp-client",
+ "thiserror 2.0.18",
+ "tokio",
+ "tokio-util",
+]
+
+[[package]]
+name = "solana-client-traits"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08618ed587e128105510c54ae3e456b9a06d674d8640db75afe66dad65cb4e02"
+dependencies = [
+ "solana-account",
+ "solana-commitment-config",
+ "solana-epoch-info",
+ "solana-hash 3.1.0",
+ "solana-instruction",
+ "solana-keypair",
+ "solana-message",
+ "solana-pubkey 3.0.0",
+ "solana-signature",
+ "solana-signer",
+ "solana-system-interface",
+ "solana-transaction",
+ "solana-transaction-error",
+]
+
+[[package]]
+name = "solana-clock"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fb62e9381182459a4520b5fe7fb22d423cae736239a6427fc398a88743d0ed59"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-cluster-type"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eb7692fa6bf10a1a86b450c4775526f56d7e0e2116a53313f2533b5694abea64"
+dependencies = [
+ "solana-hash 3.1.0",
+]
+
+[[package]]
+name = "solana-commitment-config"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2e41a3917076a8b5375809078ae3a6fb76a53e364b596ef8c4265e7f410876f3"
+dependencies = [
+ "serde",
+ "serde_derive",
+]
+
+[[package]]
+name = "solana-compute-budget-interface"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8292c436b269ad23cecc8b24f7da3ab07ca111661e25e00ce0e1d22771951ab9"
+dependencies = [
+ "solana-instruction",
+ "solana-sdk-ids",
+]
+
+[[package]]
+name = "solana-config-interface"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63e401ae56aed512821cc7a0adaa412ff97fecd2dff4602be7b1330d2daec0c4"
+dependencies = [
+ "bincode",
+ "serde",
+ "serde_derive",
+ "solana-account",
+ "solana-instruction",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-short-vec",
+ "solana-system-interface",
+]
+
+[[package]]
+name = "solana-connection-cache"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37366d7b502321513619bec10443441054c3a001ecb879645d15d4b95c87cfe8"
+dependencies = [
+ "async-trait",
+ "bincode",
+ "crossbeam-channel",
+ "futures-util",
+ "indexmap 2.13.0",
+ "log",
+ "rand 0.8.5",
+ "rayon",
+ "solana-keypair",
+ "solana-measure",
+ "solana-metrics",
+ "solana-time-utils",
+ "solana-transaction-error",
+ "thiserror 2.0.18",
+ "tokio",
+]
+
+[[package]]
+name = "solana-cpi"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4dea26709d867aada85d0d3617db0944215c8bb28d3745b912de7db13a23280c"
+dependencies = [
+ "solana-account-info",
+ "solana-define-syscall 4.0.1",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 4.0.0",
+ "solana-stable-layout",
+]
+
+[[package]]
+name = "solana-curve25519"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6d1e80bc1dec29e07019e96eeb7d72aa5ff70780a9ae700d7dd101692456739"
+dependencies = [
+ "bytemuck",
+ "bytemuck_derive",
+ "curve25519-dalek 4.1.3",
+ "solana-define-syscall 3.0.0",
+ "subtle",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-define-syscall"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9697086a4e102d28a156b8d6b521730335d6951bd39a5e766512bbe09007cee"
+
+[[package]]
+name = "solana-define-syscall"
+version = "4.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57e5b1c0bc1d4a4d10c88a4100499d954c09d3fecfae4912c1a074dff68b1738"
+
+[[package]]
+name = "solana-derivation-path"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff71743072690fdbdfcdc37700ae1cb77485aaad49019473a81aee099b1e0b8c"
+dependencies = [
+ "derivation-path",
+ "qstring",
+ "uriparse",
+]
+
+[[package]]
+name = "solana-epoch-info"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e093c84f6ece620a6b10cd036574b0cd51944231ab32d81f80f76d54aba833e6"
+dependencies = [
+ "serde",
+ "serde_derive",
+]
+
+[[package]]
+name = "solana-epoch-rewards"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b319a4ed70390af911090c020571f0ff1f4ec432522d05ab89f5c08080381995"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-hash 3.1.0",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-epoch-schedule"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e5481e72cc4d52c169db73e4c0cd16de8bc943078aac587ec4817a75cc6388f"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-feature-gate-interface"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7347ab62e6d47a82e340c865133795b394feea7c2b2771d293f57691c6544c3f"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+]
+
+[[package]]
+name = "solana-fee-calculator"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a73cc03ca4bed871ca174558108835f8323e85917bb38b9c81c7af2ab853efe"
+dependencies = [
+ "log",
+ "serde",
+ "serde_derive",
+]
+
+[[package]]
+name = "solana-hash"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "337c246447142f660f778cf6cb582beba8e28deb05b3b24bfb9ffd7c562e5f41"
+dependencies = [
+ "solana-hash 4.0.1",
+]
+
+[[package]]
+name = "solana-hash"
+version = "4.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a5d48a6ee7b91fc7b998944ab026ed7b3e2fc8ee3bc58452644a86c2648152f"
+dependencies = [
+ "borsh",
+ "bytemuck",
+ "bytemuck_derive",
+ "five8 1.0.0",
+ "serde",
+ "serde_derive",
+ "solana-atomic-u64",
+ "solana-sanitize",
+]
+
+[[package]]
+name = "solana-inflation"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e92f37a14e7c660628752833250dd3dcd8e95309876aee751d7f8769a27947c6"
+
+[[package]]
+name = "solana-instruction"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ee1b699a2c1518028a9982e255e0eca10c44d90006542d9d7f9f40dbce3f7c78"
+dependencies = [
+ "bincode",
+ "borsh",
+ "serde",
+ "serde_derive",
+ "solana-define-syscall 4.0.1",
+ "solana-instruction-error",
+ "solana-pubkey 4.0.0",
+]
+
+[[package]]
+name = "solana-instruction-error"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b04259e03c05faf38a8c24217b5cfe4c90572ae6184ab49cddb1584fdd756d3f"
+dependencies = [
+ "num-traits",
+ "serde",
+ "serde_derive",
+ "solana-program-error",
+]
+
+[[package]]
+name = "solana-instructions-sysvar"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ddf67876c541aa1e21ee1acae35c95c6fbc61119814bfef70579317a5e26955"
+dependencies = [
+ "bitflags 2.10.0",
+ "solana-account-info",
+ "solana-instruction",
+ "solana-instruction-error",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-sanitize",
+ "solana-sdk-ids",
+ "solana-serialize-utils",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-keypair"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5ac8be597c9e231b0cab2928ce3bc3e4ee77d9c0ad92977b9d901f3879f25a7a"
+dependencies = [
+ "ed25519-dalek 2.2.0",
+ "five8 1.0.0",
+ "rand 0.8.5",
+ "solana-address 2.0.0",
+ "solana-seed-phrase",
+ "solana-signature",
+ "solana-signer",
+]
+
+[[package]]
+name = "solana-last-restart-slot"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcda154ec827f5fc1e4da0af3417951b7e9b8157540f81f936c4a8b1156134d0"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-loader-v3-interface"
+version = "6.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dee44c9b1328c5c712c68966fb8de07b47f3e7bac006e74ddd1bb053d3e46e5d"
+dependencies = [
+ "serde",
+ "serde_bytes",
+ "serde_derive",
+ "solana-instruction",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+]
+
+[[package]]
+name = "solana-measure"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1db48b39416f1907faea5ffa791fc97fe595ef7c8de7850a772f96af2ec3f220"
+
+[[package]]
+name = "solana-message"
+version = "3.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85666605c9fd727f865ed381665db0a8fc29f984a030ecc1e40f43bfb2541623"
+dependencies = [
+ "bincode",
+ "lazy_static",
+ "serde",
+ "serde_derive",
+ "solana-address 1.1.0",
+ "solana-hash 3.1.0",
+ "solana-instruction",
+ "solana-sanitize",
+ "solana-sdk-ids",
+ "solana-short-vec",
+ "solana-transaction-error",
+]
+
+[[package]]
+name = "solana-metrics"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "83ef3e5000a821e64ff5db303892479d4952cfecf5aa1dbc2b0142ddfaa5e652"
+dependencies = [
+ "crossbeam-channel",
+ "gethostname",
+ "log",
+ "reqwest 0.12.28",
+ "solana-cluster-type",
+ "solana-sha256-hasher",
+ "solana-time-utils",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-msg"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "264275c556ea7e22b9d3f87d56305546a38d4eee8ec884f3b126236cb7dcbbb4"
+dependencies = [
+ "solana-define-syscall 3.0.0",
+]
+
+[[package]]
+name = "solana-net-utils"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46e45ceafd02f7e0d11f902ba956193ca459f3cceac69fc1e3b9716a0c5047f9"
+dependencies = [
+ "anyhow",
+ "bincode",
+ "bytes",
+ "cfg-if",
+ "dashmap 5.5.3",
+ "itertools 0.12.1",
+ "log",
+ "nix",
+ "rand 0.8.5",
+ "serde",
+ "socket2 0.6.1",
+ "solana-serde",
+ "solana-svm-type-overrides",
+ "tokio",
+ "url",
+]
+
+[[package]]
+name = "solana-nonce"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abbdc6c8caf1c08db9f36a50967539d0f72b9f1d4aea04fec5430f532e5afadc"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-fee-calculator",
+ "solana-hash 3.1.0",
+ "solana-pubkey 3.0.0",
+ "solana-sha256-hasher",
+]
+
+[[package]]
+name = "solana-packet"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6edf2f25743c95229ac0fdc32f8f5893ef738dbf332c669e9861d33ddb0f469d"
+dependencies = [
+ "bincode",
+ "bitflags 2.10.0",
+ "cfg_eval",
+ "serde",
+ "serde_derive",
+ "serde_with",
+]
+
+[[package]]
+name = "solana-perf"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "409ee7655f9133e8ec09f5237f0eef32183c3536552c27a81dd7de2774144a60"
+dependencies = [
+ "ahash 0.8.12",
+ "bincode",
+ "bv",
+ "bytes",
+ "caps",
+ "curve25519-dalek 4.1.3",
+ "dlopen2",
+ "fnv",
+ "libc",
+ "log",
+ "nix",
+ "rand 0.8.5",
+ "rayon",
+ "serde",
+ "solana-hash 3.1.0",
+ "solana-message",
+ "solana-metrics",
+ "solana-packet",
+ "solana-pubkey 3.0.0",
+ "solana-rayon-threadlimit",
+ "solana-sdk-ids",
+ "solana-short-vec",
+ "solana-signature",
+ "solana-time-utils",
+ "solana-transaction-context",
+]
+
+[[package]]
+name = "solana-program-entrypoint"
+version = "3.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84c9b0a1ff494e05f503a08b3d51150b73aa639544631e510279d6375f290997"
+dependencies = [
+ "solana-account-info",
+ "solana-define-syscall 4.0.1",
+ "solana-program-error",
+ "solana-pubkey 4.0.0",
+]
+
+[[package]]
+name = "solana-program-error"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1af32c995a7b692a915bb7414d5f8e838450cf7c70414e763d8abcae7b51f28"
+dependencies = [
+ "borsh",
+]
+
+[[package]]
+name = "solana-program-memory"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4068648649653c2c50546e9a7fb761791b5ab0cda054c771bb5808d3a4b9eb52"
+dependencies = [
+ "solana-define-syscall 4.0.1",
+]
+
+[[package]]
+name = "solana-program-option"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e7b4ddb464f274deb4a497712664c3b612e3f5f82471d4e47710fc4ab1c3095"
+
+[[package]]
+name = "solana-program-pack"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c169359de21f6034a63ebf96d6b380980307df17a8d371344ff04a883ec4e9d0"
+dependencies = [
+ "solana-program-error",
+]
+
+[[package]]
+name = "solana-pubkey"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8909d399deb0851aa524420beeb5646b115fd253ef446e35fe4504c904da3941"
+dependencies = [
+ "solana-address 1.1.0",
+]
+
+[[package]]
+name = "solana-pubkey"
+version = "4.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6f7104d456b58e1418c21a8581e89810278d1190f70f27ece7fc0b2c9282a57"
+dependencies = [
+ "solana-address 2.0.0",
+]
+
+[[package]]
+name = "solana-pubsub-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13ee11014415fc24dcd1086566b17f20c2a78f6e5343c28368131948949eb499"
+dependencies = [
+ "crossbeam-channel",
+ "futures-util",
+ "http 0.2.12",
+ "log",
+ "semver 1.0.27",
+ "serde",
+ "serde_json",
+ "solana-account-decoder-client-types",
+ "solana-clock",
+ "solana-pubkey 3.0.0",
+ "solana-rpc-client-types",
+ "solana-signature",
+ "thiserror 2.0.18",
+ "tokio",
+ "tokio-stream",
+ "tokio-tungstenite",
+ "tungstenite",
+ "url",
+]
+
+[[package]]
+name = "solana-quic-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "44d057f1c3aaa3a43a7e805efe7c6a4a6b1825ab29ca1f4a0e16be66dc65fe96"
+dependencies = [
+ "async-lock",
+ "async-trait",
+ "futures",
+ "itertools 0.12.1",
+ "log",
+ "quinn",
+ "quinn-proto",
+ "rustls",
+ "solana-connection-cache",
+ "solana-keypair",
+ "solana-measure",
+ "solana-metrics",
+ "solana-net-utils",
+ "solana-pubkey 3.0.0",
+ "solana-quic-definitions",
+ "solana-rpc-client-api",
+ "solana-signer",
+ "solana-streamer",
+ "solana-tls-utils",
+ "solana-transaction-error",
+ "thiserror 2.0.18",
+ "tokio",
+]
+
+[[package]]
+name = "solana-quic-definitions"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "15319accf7d3afd845817aeffa6edd8cc185f135cefbc6b985df29cfd8c09609"
+dependencies = [
+ "solana-keypair",
+]
+
+[[package]]
+name = "solana-rayon-threadlimit"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d2ce963aa8e7f69d61752e5c2f09e3c213f29383b32a34d3ecaf29f4b10f42d"
+dependencies = [
+ "log",
+ "num_cpus",
+]
+
+[[package]]
+name = "solana-rent"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e860d5499a705369778647e97d760f7670adfb6fc8419dd3d568deccd46d5487"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-reward-info"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "82be7946105c2ee6be9f9ee7bd18a068b558389221d29efa92b906476102bfcc"
+dependencies = [
+ "serde",
+ "serde_derive",
+]
+
+[[package]]
+name = "solana-rpc-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d0ca112a1f5a94870d0eae0d1fac2009a0f717523188dd1a867dab7e921e17e"
+dependencies = [
+ "async-trait",
+ "base64 0.22.1",
+ "bincode",
+ "bs58",
+ "futures",
+ "indicatif",
+ "log",
+ "reqwest 0.12.28",
+ "reqwest-middleware 0.4.2",
+ "semver 1.0.27",
+ "serde",
+ "serde_json",
+ "solana-account",
+ "solana-account-decoder",
+ "solana-account-decoder-client-types",
+ "solana-clock",
+ "solana-commitment-config",
+ "solana-epoch-info",
+ "solana-epoch-schedule",
+ "solana-feature-gate-interface",
+ "solana-hash 3.1.0",
+ "solana-instruction",
+ "solana-message",
+ "solana-pubkey 3.0.0",
+ "solana-rpc-client-api",
+ "solana-signature",
+ "solana-transaction",
+ "solana-transaction-error",
+ "solana-transaction-status-client-types",
+ "solana-version",
+ "solana-vote-interface",
+ "tokio",
+]
+
+[[package]]
+name = "solana-rpc-client-api"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d934907c81013f8e561177045340702f957c840abb74a4f16e2b04bc10d4cd50"
+dependencies = [
+ "anyhow",
+ "jsonrpc-core",
+ "reqwest 0.12.28",
+ "reqwest-middleware 0.4.2",
+ "serde",
+ "serde_json",
+ "solana-account-decoder-client-types",
+ "solana-clock",
+ "solana-rpc-client-types",
+ "solana-signer",
+ "solana-transaction-error",
+ "solana-transaction-status-client-types",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-rpc-client-nonce-utils"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df9abd8cfe0b7f60e0601197e5ef0831f5cb80fae3f77ac044a3e32a8d83ae1f"
+dependencies = [
+ "solana-account",
+ "solana-commitment-config",
+ "solana-hash 3.1.0",
+ "solana-message",
+ "solana-nonce",
+ "solana-pubkey 3.0.0",
+ "solana-rpc-client",
+ "solana-sdk-ids",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-rpc-client-types"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "169b1197c7a242357478d0a88ed5c3e698cfd6ed0436d2eb710cfea79d1b0b92"
+dependencies = [
+ "base64 0.22.1",
+ "bs58",
+ "semver 1.0.27",
+ "serde",
+ "serde_json",
+ "solana-account",
+ "solana-account-decoder-client-types",
+ "solana-address 1.1.0",
+ "solana-clock",
+ "solana-commitment-config",
+ "solana-fee-calculator",
+ "solana-inflation",
+ "solana-reward-info",
+ "solana-transaction",
+ "solana-transaction-error",
+ "solana-transaction-status-client-types",
+ "solana-version",
+ "spl-generic-token",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-sanitize"
+version = "3.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcf09694a0fc14e5ffb18f9b7b7c0f15ecb6eac5b5610bf76a1853459d19daf9"
+
+[[package]]
+name = "solana-sbpf"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b15b079e08471a9dbfe1e48b2c7439c85aa2a055cbd54eddd8bd257b0a7dbb29"
+dependencies = [
+ "byteorder",
+ "combine 3.8.1",
+ "hash32",
+ "log",
+ "rustc-demangle",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-sdk-ids"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "def234c1956ff616d46c9dd953f251fa7096ddbaa6d52b165218de97882b7280"
+dependencies = [
+ "solana-address 2.0.0",
+]
+
+[[package]]
+name = "solana-sdk-macro"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6430000e97083460b71d9fbadc52a2ab2f88f53b3a4c5e58c5ae3640a0e8c00"
+dependencies = [
+ "bs58",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "solana-security-txt"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "156bb61a96c605fa124e052d630dba2f6fb57e08c7d15b757e1e958b3ed7b3fe"
+dependencies = [
+ "hashbrown 0.15.2",
+]
+
+[[package]]
+name = "solana-seed-derivable"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff7bdb72758e3bec33ed0e2658a920f1f35dfb9ed576b951d20d63cb61ecd95c"
+dependencies = [
+ "solana-derivation-path",
+]
+
+[[package]]
+name = "solana-seed-phrase"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc905b200a95f2ea9146e43f2a7181e3aeb55de6bc12afb36462d00a3c7310de"
+dependencies = [
+ "hmac 0.12.1",
+ "pbkdf2",
+ "sha2 0.10.9",
+]
+
+[[package]]
+name = "solana-serde"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "709a93cab694c70f40b279d497639788fc2ccbcf9b4aa32273d4b361322c02dd"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "solana-serde-varint"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3e5174c57d5ff3c1995f274d17156964664566e2cde18a07bba1586d35a70d3b"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "solana-serialize-utils"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e41dd8feea239516c623a02f0a81c2367f4b604d7965237fed0751aeec33ed"
+dependencies = [
+ "solana-instruction-error",
+ "solana-pubkey 3.0.0",
+ "solana-sanitize",
+]
+
+[[package]]
+name = "solana-sha256-hasher"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db7dc3011ea4c0334aaaa7e7128cb390ecf546b28d412e9bf2064680f57f588f"
+dependencies = [
+ "sha2 0.10.9",
+ "solana-define-syscall 4.0.1",
+ "solana-hash 4.0.1",
+]
+
+[[package]]
+name = "solana-short-vec"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "79fb1809a32cfcf7d9c47b7070a92fa17cdb620ab5829e9a8a9ff9d138a7a175"
+dependencies = [
+ "serde_core",
+]
+
+[[package]]
+name = "solana-signature"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bb8057cc0e9f7b5e89883d49de6f407df655bb6f3a71d0b7baf9986a2218fd9"
+dependencies = [
+ "ed25519-dalek 2.2.0",
+ "five8 0.2.1",
+ "serde",
+ "serde-big-array",
+ "serde_derive",
+ "solana-sanitize",
+]
+
+[[package]]
+name = "solana-signer"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5bfea97951fee8bae0d6038f39a5efcb6230ecdfe33425ac75196d1a1e3e3235"
+dependencies = [
+ "solana-pubkey 3.0.0",
+ "solana-signature",
+ "solana-transaction-error",
+]
+
+[[package]]
+name = "solana-slot-hashes"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "80a293f952293281443c04f4d96afd9d547721923d596e92b4377ed2360f1746"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-hash 3.1.0",
+ "solana-sdk-ids",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-slot-history"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f914f6b108f5bba14a280b458d023e3621c9973f27f015a4d755b50e88d89e97"
+dependencies = [
+ "bv",
+ "serde",
+ "serde_derive",
+ "solana-sdk-ids",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-stable-layout"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1da74507795b6e8fb60b7c7306c0c36e2c315805d16eaaf479452661234685ac"
+dependencies = [
+ "solana-instruction",
+ "solana-pubkey 3.0.0",
+]
+
+[[package]]
+name = "solana-stake-interface"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9bc26191b533f9a6e5a14cca05174119819ced680a80febff2f5051a713f0db"
+dependencies = [
+ "num-traits",
+ "serde",
+ "serde_derive",
+ "solana-clock",
+ "solana-cpi",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-system-interface",
+ "solana-sysvar",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-streamer"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7faa088da7bcdd543e75233a5ea4a4e5cb8883634cbca6cc9d4c7a0d40e3cdd4"
+dependencies = [
+ "arc-swap",
+ "bytes",
+ "crossbeam-channel",
+ "dashmap 5.5.3",
+ "futures",
+ "futures-util",
+ "governor 0.6.3",
+ "histogram",
+ "indexmap 2.13.0",
+ "itertools 0.12.1",
+ "libc",
+ "log",
+ "nix",
+ "num_cpus",
+ "pem",
+ "percentage",
+ "quinn",
+ "quinn-proto",
+ "rand 0.8.5",
+ "rustls",
+ "smallvec",
+ "socket2 0.6.1",
+ "solana-keypair",
+ "solana-measure",
+ "solana-metrics",
+ "solana-net-utils",
+ "solana-packet",
+ "solana-perf",
+ "solana-pubkey 3.0.0",
+ "solana-quic-definitions",
+ "solana-signature",
+ "solana-signer",
+ "solana-time-utils",
+ "solana-tls-utils",
+ "solana-transaction-error",
+ "solana-transaction-metrics-tracker",
+ "thiserror 2.0.18",
+ "tokio",
+ "tokio-util",
+ "x509-parser",
+]
+
+[[package]]
+name = "solana-svm-feature-set"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91a5fd5b82b7abe74f286179380469ea577f56a9d986a6071ed75b6276b42c64"
+
+[[package]]
+name = "solana-svm-type-overrides"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a32fa5f1cd4b6f06950ba2e24e2b1fb806d3ac5634bd9518d7b8c73cf3cf77ee"
+dependencies = [
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "solana-system-interface"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e1790547bfc3061f1ee68ea9d8dc6c973c02a163697b24263a8e9f2e6d4afa2"
+dependencies = [
+ "num-traits",
+ "serde",
+ "serde_derive",
+ "solana-instruction",
+ "solana-msg",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+]
+
+[[package]]
+name = "solana-sysvar"
+version = "3.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6690d3dd88f15c21edff68eb391ef8800df7a1f5cec84ee3e8d1abf05affdf74"
+dependencies = [
+ "base64 0.22.1",
+ "bincode",
+ "lazy_static",
+ "serde",
+ "serde_derive",
+ "solana-account-info",
+ "solana-clock",
+ "solana-define-syscall 4.0.1",
+ "solana-epoch-rewards",
+ "solana-epoch-schedule",
+ "solana-fee-calculator",
+ "solana-hash 4.0.1",
+ "solana-instruction",
+ "solana-last-restart-slot",
+ "solana-program-entrypoint",
+ "solana-program-error",
+ "solana-program-memory",
+ "solana-pubkey 4.0.0",
+ "solana-rent",
+ "solana-sdk-ids",
+ "solana-sdk-macro",
+ "solana-slot-hashes",
+ "solana-slot-history",
+ "solana-sysvar-id",
+]
+
+[[package]]
+name = "solana-sysvar-id"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17358d1e9a13e5b9c2264d301102126cf11a47fd394cdf3dec174fe7bc96e1de"
+dependencies = [
+ "solana-address 2.0.0",
+ "solana-sdk-ids",
+]
+
+[[package]]
+name = "solana-time-utils"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ced92c60aa76ec4780a9d93f3bd64dfa916e1b998eacc6f1c110f3f444f02c9"
+
+[[package]]
+name = "solana-tls-utils"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "80960921cdbcea1be13c31940baf5049b9925aab4e4c1d2f748ff8362dfd6591"
+dependencies = [
+ "rustls",
+ "solana-keypair",
+ "solana-pubkey 3.0.0",
+ "solana-signer",
+ "x509-parser",
+]
+
+[[package]]
+name = "solana-tpu-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "004dc9e07edc3e04e943ecdd515e6cd88b22330fd8e0a4f8fdfd82c77c5d5d17"
+dependencies = [
+ "async-trait",
+ "bincode",
+ "futures-util",
+ "indexmap 2.13.0",
+ "indicatif",
+ "log",
+ "rayon",
+ "solana-client-traits",
+ "solana-clock",
+ "solana-commitment-config",
+ "solana-connection-cache",
+ "solana-epoch-schedule",
+ "solana-measure",
+ "solana-message",
+ "solana-net-utils",
+ "solana-pubkey 3.0.0",
+ "solana-pubsub-client",
+ "solana-quic-definitions",
+ "solana-rpc-client",
+ "solana-rpc-client-api",
+ "solana-signature",
+ "solana-signer",
+ "solana-transaction",
+ "solana-transaction-error",
+ "thiserror 2.0.18",
+ "tokio",
+]
+
+[[package]]
+name = "solana-transaction"
+version = "3.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2ceb2efbf427a91b884709ffac4dac29117752ce1e37e9ae04977e450aa0bb76"
+dependencies = [
+ "bincode",
+ "serde",
+ "serde_derive",
+ "solana-address 2.0.0",
+ "solana-hash 4.0.1",
+ "solana-instruction",
+ "solana-instruction-error",
+ "solana-message",
+ "solana-sanitize",
+ "solana-sdk-ids",
+ "solana-short-vec",
+ "solana-signature",
+ "solana-signer",
+ "solana-transaction-error",
+]
+
+[[package]]
+name = "solana-transaction-context"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3cc4d1cd3ae46f1e93740cc6faa7fed82d921cbe9a82f93b103a323cbd432b12"
+dependencies = [
+ "bincode",
+ "serde",
+ "solana-account",
+ "solana-instruction",
+ "solana-instructions-sysvar",
+ "solana-pubkey 3.0.0",
+ "solana-rent",
+ "solana-sbpf",
+ "solana-sdk-ids",
+]
+
+[[package]]
+name = "solana-transaction-error"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4222065402340d7e6aec9dc3e54d22992ddcf923d91edcd815443c2bfca3144a"
+dependencies = [
+ "serde",
+ "serde_derive",
+ "solana-instruction-error",
+ "solana-sanitize",
+]
+
+[[package]]
+name = "solana-transaction-metrics-tracker"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "095a72c48ca8d21531e65196be74178c423ddb1255baeda9cb7901cd71d4ee40"
+dependencies = [
+ "base64 0.22.1",
+ "bincode",
+ "log",
+ "rand 0.8.5",
+ "solana-packet",
+ "solana-perf",
+ "solana-short-vec",
+ "solana-signature",
+]
+
+[[package]]
+name = "solana-transaction-status-client-types"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc89888b2e96c03339c388447134bd64ac6d5a30d9286f74b82593129b702a93"
+dependencies = [
+ "base64 0.22.1",
+ "bincode",
+ "bs58",
+ "serde",
+ "serde_json",
+ "solana-account-decoder-client-types",
+ "solana-commitment-config",
+ "solana-instruction",
+ "solana-message",
+ "solana-pubkey 3.0.0",
+ "solana-reward-info",
+ "solana-signature",
+ "solana-transaction",
+ "solana-transaction-context",
+ "solana-transaction-error",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "solana-udp-client"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24fab937290de5ccac5108703f691b658f94a0b72aa9a3e0ffc7a292bbd460ff"
+dependencies = [
+ "async-trait",
+ "solana-connection-cache",
+ "solana-keypair",
+ "solana-net-utils",
+ "solana-streamer",
+ "solana-transaction-error",
+ "thiserror 2.0.18",
+ "tokio",
+]
+
+[[package]]
+name = "solana-version"
+version = "3.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f496e1623d5e687c1a65bc4fcd17cab819998232863ee038749d625857c04888"
+dependencies = [
+ "agave-feature-set",
+ "rand 0.8.5",
+ "semver 1.0.27",
+ "serde",
+ "solana-sanitize",
+ "solana-serde-varint",
+]
+
+[[package]]
+name = "solana-vote-interface"
+version = "4.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db6e123e16bfdd7a81d71b4c4699e0b29580b619f4cd2ef5b6aae1eb85e8979f"
+dependencies = [
+ "bincode",
+ "cfg_eval",
+ "num-derive",
+ "num-traits",
+ "serde",
+ "serde_derive",
+ "serde_with",
+ "solana-clock",
+ "solana-hash 3.1.0",
+ "solana-instruction",
+ "solana-instruction-error",
+ "solana-pubkey 3.0.0",
+ "solana-rent",
+ "solana-sdk-ids",
+ "solana-serde-varint",
+ "solana-serialize-utils",
+ "solana-short-vec",
+ "solana-system-interface",
+]
+
+[[package]]
+name = "solana-zk-sdk"
+version = "4.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9602bcb1f7af15caef92b91132ec2347e1c51a72ecdbefdaefa3eac4b8711475"
+dependencies = [
+ "aes-gcm-siv",
+ "base64 0.22.1",
+ "bincode",
+ "bytemuck",
+ "bytemuck_derive",
+ "curve25519-dalek 4.1.3",
+ "getrandom 0.2.17",
+ "itertools 0.12.1",
+ "js-sys",
+ "merlin",
+ "num-derive",
+ "num-traits",
+ "rand 0.8.5",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "sha3 0.10.8",
+ "solana-derivation-path",
+ "solana-instruction",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-seed-derivable",
+ "solana-seed-phrase",
+ "solana-signature",
+ "solana-signer",
+ "subtle",
+ "thiserror 2.0.18",
+ "wasm-bindgen",
+ "zeroize",
+]
+
+[[package]]
+name = "spin"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
+
+[[package]]
+name = "spin"
+version = "0.9.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
+
+[[package]]
+name = "spinning_top"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d96d2d1d716fb500937168cc09353ffdc7a012be8475ac7308e1bdf0e3923300"
+dependencies = [
+ "lock_api",
+]
+
+[[package]]
+name = "spki"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
+dependencies = [
+ "base64ct",
+ "der",
+]
+
+[[package]]
+name = "spl-discriminator"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d48cc11459e265d5b501534144266620289720b4c44522a47bc6b63cd295d2f3"
+dependencies = [
+ "bytemuck",
+ "solana-program-error",
+ "solana-sha256-hasher",
+ "spl-discriminator-derive",
+]
+
+[[package]]
+name = "spl-discriminator-derive"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9e8418ea6269dcfb01c712f0444d2c75542c04448b480e87de59d2865edc750"
+dependencies = [
+ "quote",
+ "spl-discriminator-syn",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "spl-discriminator-syn"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d1dbc82ab91422345b6df40a79e2b78c7bce1ebb366da323572dd60b7076b67"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "sha2 0.10.9",
+ "syn 2.0.114",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "spl-elgamal-registry-interface"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "065f54100d118d24036283e03120b2f60cb5b7d597d3db649e13690e22d41398"
+dependencies = [
+ "bytemuck",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-zk-sdk",
+ "spl-token-confidential-transfer-proof-extraction",
+]
+
+[[package]]
+name = "spl-generic-token"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "233df81b75ab99b42f002b5cdd6e65a7505ffa930624f7096a7580a56765e9cf"
+dependencies = [
+ "bytemuck",
+ "solana-pubkey 3.0.0",
+]
+
+[[package]]
+name = "spl-memo-interface"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d4e2aedd58f858337fa609af5ad7100d4a243fdaf6a40d6eb4c28c5f19505d3"
+dependencies = [
+ "solana-instruction",
+ "solana-pubkey 3.0.0",
+]
+
+[[package]]
+name = "spl-pod"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1233fdecd7461611d69bb87bc2e95af742df47291975d21232a0be8217da9de"
+dependencies = [
+ "borsh",
+ "bytemuck",
+ "bytemuck_derive",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-program-error",
+ "solana-program-option",
+ "solana-pubkey 3.0.0",
+ "solana-zk-sdk",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-program-error"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c4f6cf26cb6768110bf024bc7224326c720d711f7ad25d16f40f6cee40edb2d"
+dependencies = [
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-msg",
+ "solana-program-error",
+ "spl-program-error-derive",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-program-error-derive"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ec8965aa4dc6c74701cbb48b9cad5af35b9a394514934949edbb357b78f840d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "sha2 0.10.9",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "spl-tlv-account-resolution"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6927f613c9d7ce20835d3cefb602137cab2518e383a047c0eaa58054a60644c8"
+dependencies = [
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-account-info",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "spl-discriminator",
+ "spl-pod",
+ "spl-program-error",
+ "spl-type-length-value",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token"
+version = "9.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "878b0183d51fcd8a53e1604f4c13321894cf53227e6773c529b0d03d499a8dfd"
+dependencies = [
+ "arrayref",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-account-info",
+ "solana-cpi",
+ "solana-instruction",
+ "solana-msg",
+ "solana-program-entrypoint",
+ "solana-program-error",
+ "solana-program-memory",
+ "solana-program-option",
+ "solana-program-pack",
+ "solana-pubkey 3.0.0",
+ "solana-rent",
+ "solana-sdk-ids",
+ "solana-sysvar",
+ "spl-token-interface",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-2022"
+version = "10.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "552427d9117528d037daa0e70416d51322c8a33241317210f230304d852be61e"
+dependencies = [
+ "arrayref",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-account-info",
+ "solana-clock",
+ "solana-cpi",
+ "solana-instruction",
+ "solana-msg",
+ "solana-program-entrypoint",
+ "solana-program-error",
+ "solana-program-memory",
+ "solana-program-option",
+ "solana-program-pack",
+ "solana-pubkey 3.0.0",
+ "solana-rent",
+ "solana-sdk-ids",
+ "solana-security-txt",
+ "solana-system-interface",
+ "solana-sysvar",
+ "solana-zk-sdk",
+ "spl-elgamal-registry-interface",
+ "spl-memo-interface",
+ "spl-pod",
+ "spl-token-2022-interface",
+ "spl-token-confidential-transfer-ciphertext-arithmetic",
+ "spl-token-confidential-transfer-proof-extraction",
+ "spl-token-confidential-transfer-proof-generation",
+ "spl-token-group-interface",
+ "spl-token-metadata-interface",
+ "spl-transfer-hook-interface",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-2022-interface"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2fcd81188211f4b3c8a5eba7fd534c7142f9dd026123b3472492782cc72f4dc6"
+dependencies = [
+ "arrayref",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-account-info",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-program-option",
+ "solana-program-pack",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-zk-sdk",
+ "spl-pod",
+ "spl-token-confidential-transfer-proof-extraction",
+ "spl-token-confidential-transfer-proof-generation",
+ "spl-token-group-interface",
+ "spl-token-metadata-interface",
+ "spl-type-length-value",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-confidential-transfer-ciphertext-arithmetic"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "afbeb07f737d868f145512a4bcf9f59da275b7a3483df0add3f71eb812b689fb"
+dependencies = [
+ "base64 0.22.1",
+ "bytemuck",
+ "solana-curve25519",
+ "solana-zk-sdk",
+]
+
+[[package]]
+name = "spl-token-confidential-transfer-proof-extraction"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "879a9ebad0d77383d3ea71e7de50503554961ff0f4ef6cbca39ad126e6f6da3a"
+dependencies = [
+ "bytemuck",
+ "solana-account-info",
+ "solana-curve25519",
+ "solana-instruction",
+ "solana-instructions-sysvar",
+ "solana-msg",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-zk-sdk",
+ "spl-pod",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-confidential-transfer-proof-generation"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0cd59fce3dc00f563c6fa364d67c3f200d278eae681f4dc250240afcfe044b1"
+dependencies = [
+ "curve25519-dalek 4.1.3",
+ "solana-zk-sdk",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-group-interface"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "452d0f758af20caaa10d9a6f7608232e000d4c74462f248540b3d2ddfa419776"
+dependencies = [
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "spl-discriminator",
+ "spl-pod",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-interface"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8c564ac05a7c8d8b12e988a37d82695b5ba4db376d07ea98bc4882c81f96c7f3"
+dependencies = [
+ "arrayref",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-program-option",
+ "solana-program-pack",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-token-metadata-interface"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c467c7c3bd056f8fe60119e7ec34ddd6f23052c2fa8f1f51999098063b72676"
+dependencies = [
+ "borsh",
+ "num-derive",
+ "num-traits",
+ "solana-borsh",
+ "solana-instruction",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "spl-discriminator",
+ "spl-pod",
+ "spl-type-length-value",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-transfer-hook-interface"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c34b46b8f39bc64a9ab177a0ea8e9a58826db76f8d9d154a2400ee60baef7b1e"
+dependencies = [
+ "arrayref",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "solana-account-info",
+ "solana-cpi",
+ "solana-instruction",
+ "solana-msg",
+ "solana-program-error",
+ "solana-pubkey 3.0.0",
+ "solana-sdk-ids",
+ "solana-system-interface",
+ "spl-discriminator",
+ "spl-pod",
+ "spl-program-error",
+ "spl-tlv-account-resolution",
+ "spl-type-length-value",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "spl-type-length-value"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca20a1a19f4507a98ca4b28ff5ed54cac9b9d34ed27863e2bde50a3238f9a6ac"
+dependencies = [
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum",
+ "solana-account-info",
+ "solana-msg",
+ "solana-program-error",
+ "spl-discriminator",
+ "spl-pod",
+ "thiserror 2.0.18",
+]
+
+[[package]]
+name = "stable_deref_trait"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ce2be8dc25455e1f91df71bfa12ad37d7af1092ae736f3a6cd0e37bc7810596"
+
+[[package]]
+name = "static_assertions"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
+
+[[package]]
+name = "strsim"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a"
+
+[[package]]
+name = "strsim"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"
+
+[[package]]
+name = "structopt"
+version = "0.3.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0c6b5c64445ba8094a6ab0c3cd2ad323e07171012d9c98b0b15651daf1787a10"
+dependencies = [
+ "clap 2.34.0",
+ "lazy_static",
+ "structopt-derive",
+]
+
+[[package]]
+name = "structopt-derive"
+version = "0.4.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0"
+dependencies = [
+ "heck 0.3.3",
+ "proc-macro-error",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "strum"
+version = "0.25.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "290d54ea6f91c969195bdbcd7442c8c2a2ba87da8bf60a7ee86a235d4bc1e125"
+dependencies = [
+ "strum_macros 0.25.3",
+]
+
+[[package]]
+name = "strum"
+version = "0.27.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af23d6f6c1a224baef9d3f61e287d2761385a5b88fdab4eb4c6f11aeb54c4bcf"
+dependencies = [
+ "strum_macros 0.27.2",
+]
+
+[[package]]
+name = "strum_macros"
+version = "0.25.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23dc1fa9ac9c169a78ba62f0b841814b7abae11bdd047b9c58f893439e309ea0"
+dependencies = [
+ "heck 0.4.1",
+ "proc-macro2",
+ "quote",
+ "rustversion",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "strum_macros"
+version = "0.27.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7695ce3845ea4b33927c055a39dc438a45b059f7c1b3d91d38d10355fb8cbca7"
+dependencies = [
+ "heck 0.5.0",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "subtle"
+version = "2.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"
+
+[[package]]
+name = "subtle-ng"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "734676eb262c623cec13c3155096e08d1f8f29adce39ba17948b18dad1e54142"
+
+[[package]]
+name = "syn"
+version = "1.0.109"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.114"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4d107df263a3013ef9b1879b0df87d706ff80f65a86ea879bd9c31f9b307c2a"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "syn-solidity"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f92d01b5de07eaf324f7fca61cc6bd3d82bbc1de5b6c963e6fe79e86f36580d"
+dependencies = [
+ "paste",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "sync_wrapper"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
+
+[[package]]
+name = "sync_wrapper"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
+dependencies = [
+ "futures-core",
+]
+
+[[package]]
+name = "synstructure"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+ "unicode-xid",
+]
+
+[[package]]
+name = "synstructure"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "system-configuration"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba3a3adc5c275d719af8cb4272ea1c4a6d668a777f37e115f6d11ddbc1c8e0e7"
+dependencies = [
+ "bitflags 1.3.2",
+ "core-foundation 0.9.4",
+ "system-configuration-sys",
+]
+
+[[package]]
+name = "system-configuration-sys"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75fb188eb626b924683e3b95e3a48e63551fcfb51949de2f06a9d91dbee93c9"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "tap"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"
+
+[[package]]
+name = "tempfile"
+version = "3.24.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "655da9c7eb6305c55742045d5a8d2037996d61d8de95806335c7c86ce0f82e9c"
+dependencies = [
+ "fastrand",
+ "getrandom 0.3.4",
+ "once_cell",
+ "rustix",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "tera"
+version = "1.20.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8004bca281f2d32df3bacd59bc67b312cb4c70cea46cbd79dbe8ac5ed206722"
+dependencies = [
+ "chrono",
+ "chrono-tz 0.9.0",
+ "globwalk",
+ "humansize",
+ "lazy_static",
+ "percent-encoding",
+ "pest",
+ "pest_derive",
+ "rand 0.8.5",
+ "regex",
+ "serde",
+ "serde_json",
+ "slug",
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "terminal_size"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "60b8cb979cb11c32ce1603f8137b22262a9d131aaa5c37b5678025f22b8becd0"
+dependencies = [
+ "rustix",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "textwrap"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060"
+dependencies = [
+ "unicode-width 0.1.14",
+]
+
+[[package]]
+name = "textwrap"
+version = "0.13.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd05616119e612a8041ef58f2b578906cc2531a6069047ae092cfb86a325d835"
+dependencies = [
+ "smawk",
+ "unicode-width 0.1.14",
+]
+
+[[package]]
+name = "textwrap"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b7b3e525a49ec206798b40326a44121291b530c963cfb01018f63e135bac543d"
+dependencies = [
+ "smawk",
+ "unicode-linebreak",
+ "unicode-width 0.1.14",
+]
+
+[[package]]
+name = "thiserror"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
+dependencies = [
+ "thiserror-impl 1.0.69",
+]
+
+[[package]]
+name = "thiserror"
+version = "2.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4288b5bcbc7920c07a1149a35cf9590a2aa808e0bc1eafaade0b80947865fbc4"
+dependencies = [
+ "thiserror-impl 2.0.18",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "2.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebc4ee7f67670e9b64d05fa4253e753e016c6c95ff35b89b7941d6b856dec1d5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "thread_local"
+version = "1.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "threadpool"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa"
+dependencies = [
+ "num_cpus",
+]
+
+[[package]]
+name = "time"
+version = "0.3.45"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9e442fc33d7fdb45aa9bfeb312c095964abdf596f7567261062b2a7107aaabd"
+dependencies = [
+ "deranged",
+ "itoa",
+ "num-conv",
+ "powerfmt",
+ "serde_core",
+ "time-core",
+ "time-macros",
+]
+
+[[package]]
+name = "time-core"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b36ee98fd31ec7426d599183e8fe26932a8dc1fb76ddb6214d05493377d34ca"
+
+[[package]]
+name = "time-macros"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "71e552d1249bf61ac2a52db88179fd0673def1e1ad8243a00d9ec9ed71fee3dd"
+dependencies = [
+ "num-conv",
+ "time-core",
+]
+
+[[package]]
+name = "tiny-keccak"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
+dependencies = [
+ "crunchy",
+]
+
+[[package]]
+name = "tinystr"
+version = "0.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42d3e9c45c09de15d06dd8acf5f4e0e399e85927b7f00711024eb7ae10fa4869"
+dependencies = [
+ "displaydoc",
+ "zerovec",
+]
+
+[[package]]
+name = "tinytemplate"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc"
+dependencies = [
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "tinyvec"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
+dependencies = [
+ "tinyvec_macros",
+]
+
+[[package]]
+name = "tinyvec_macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
+
+[[package]]
+name = "tokio"
+version = "1.49.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72a2903cd7736441aac9df9d7688bd0ce48edccaadf181c3b90be801e81d3d86"
+dependencies = [
+ "bytes",
+ "libc",
+ "mio",
+ "parking_lot",
+ "pin-project-lite",
+ "signal-hook-registry",
+ "socket2 0.6.1",
+ "tokio-macros",
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "tokio-macros"
+version = "2.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af407857209536a95c8e56f8231ef2c2e2aff839b22e07a1ffcbc617e9db9fa5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "tokio-native-tls"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
+dependencies = [
+ "native-tls",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-rustls"
+version = "0.26.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1729aa945f29d91ba541258c8df89027d5792d85a8841fb65e8bf0f4ede4ef61"
+dependencies = [
+ "rustls",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-stream"
+version = "0.1.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32da49809aab5c3bc678af03902d4ccddea2a87d028d86392a4b1560c6906c70"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+ "tokio",
+ "tokio-util",
+]
+
+[[package]]
+name = "tokio-tungstenite"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d25a406cddcc431a75d3d9afc6a7c0f7428d4891dd973e4d54c56b46127bf857"
+dependencies = [
+ "futures-util",
+ "log",
+ "rustls",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tungstenite",
+ "webpki-roots 0.26.11",
+]
+
+[[package]]
+name = "tokio-util"
+version = "0.7.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ae9cec805b01e8fc3fd2fe289f89149a9b66dd16786abd8b19cfa7b48cb0098"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "toml"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd79e69d3b627db300ff956027cc6c3798cef26d22526befdfcd12feeb6d2257"
+dependencies = [
+ "serde",
+ "serde_spanned",
+ "toml_datetime 0.6.11",
+ "toml_edit 0.19.15",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.7.5+spec-1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92e1cfed4a3038bc5a127e35a2d360f145e1f4b971b551a2ba5fd7aedf7e1347"
+dependencies = [
+ "serde_core",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.19.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
+dependencies = [
+ "indexmap 2.13.0",
+ "serde",
+ "serde_spanned",
+ "toml_datetime 0.6.11",
+ "winnow 0.5.40",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.23.10+spec-1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84c8b9f757e028cee9fa244aea147aab2a9ec09d5325a9b01e0a49730c2b5269"
+dependencies = [
+ "indexmap 2.13.0",
+ "toml_datetime 0.7.5+spec-1.1.0",
+ "toml_parser",
+ "winnow 0.7.14",
+]
+
+[[package]]
+name = "toml_parser"
+version = "1.0.6+spec-1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a3198b4b0a8e11f09dd03e133c0280504d0801269e9afa46362ffde1cbeebf44"
+dependencies = [
+ "winnow 0.7.14",
+]
+
+[[package]]
+name = "tonic"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877c5b330756d856ffcc4553ab34a5684481ade925ecc54bcd1bf02b1d0d4d52"
+dependencies = [
+ "async-stream",
+ "async-trait",
+ "axum 0.7.9",
+ "base64 0.22.1",
+ "bytes",
+ "flate2",
+ "h2 0.4.13",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-timeout",
+ "hyper-util",
+ "percent-encoding",
+ "pin-project",
+ "prost 0.13.5",
+ "rustls-native-certs",
+ "rustls-pemfile 2.2.0",
+ "socket2 0.5.10",
+ "tokio",
+ "tokio-rustls",
+ "tokio-stream",
+ "tower 0.4.13",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+ "zstd",
+]
+
+[[package]]
+name = "tonic"
+version = "0.14.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eb7613188ce9f7df5bfe185db26c5814347d110db17920415cf2fbcad85e7203"
+dependencies = [
+ "async-trait",
+ "base64 0.22.1",
+ "bytes",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-timeout",
+ "hyper-util",
+ "percent-encoding",
+ "pin-project",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tokio-stream",
+ "tower 0.5.3",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tonic-prost"
+version = "0.14.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "66bd50ad6ce1252d87ef024b3d64fe4c3cf54a86fb9ef4c631fdd0ded7aeaa67"
+dependencies = [
+ "bytes",
+ "prost 0.14.3",
+ "tonic 0.14.2",
+]
+
+[[package]]
+name = "tonic-reflection"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "878d81f52e7fcfd80026b7fdb6a9b578b3c3653ba987f87f0dce4b64043cba27"
+dependencies = [
+ "prost 0.13.5",
+ "prost-types",
+ "tokio",
+ "tokio-stream",
+ "tonic 0.12.3",
+]
+
+[[package]]
+name = "topological-sort"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ea68304e134ecd095ac6c3574494fc62b909f416c4fca77e440530221e549d3d"
+
+[[package]]
+name = "tower"
+version = "0.4.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8fa9be0de6cf49e536ce1851f987bd21a43b771b09473c3549a6c853db37c1c"
+dependencies = [
+ "futures-core",
+ "futures-util",
+ "indexmap 1.9.3",
+ "pin-project",
+ "pin-project-lite",
+ "rand 0.8.5",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tower"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebe5ef63511595f1344e2d5cfa636d973292adc0eec1f0ad45fae9f0851ab1d4"
+dependencies = [
+ "futures-core",
+ "futures-util",
+ "indexmap 2.13.0",
+ "pin-project-lite",
+ "slab",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tokio-util",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tower-http"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4e6559d53cc268e5031cd8429d05415bc4cb4aefc4aa5d6cc35fbf5b924a1f8"
+dependencies = [
+ "async-compression",
+ "bitflags 2.10.0",
+ "bytes",
+ "futures-core",
+ "futures-util",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "iri-string",
+ "pin-project-lite",
+ "tokio",
+ "tokio-util",
+ "tower 0.5.3",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tower-layer"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"
+
+[[package]]
+name = "tower-service"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"
+
+[[package]]
+name = "tracing"
+version = "0.1.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63e71662fa4b2a2c3a26f570f037eb95bb1f85397f3cd8076caed2f026a6d100"
+dependencies = [
+ "log",
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7490cfa5ec963746568740651ac6781f701c9c5ea257c58e057f3ba8cf69e8da"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.36"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db97caf9d906fbde555dd62fa95ddba9eecfd14cb388e4f491a66d74cd5fb79a"
+dependencies = [
+ "once_cell",
+ "valuable",
+]
+
+[[package]]
+name = "tracing-log"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
+dependencies = [
+ "log",
+ "once_cell",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-opentelemetry"
+version = "0.32.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ac28f2d093c6c477eaa76b23525478f38de514fa9aeb1285738d4b97a9552fc"
+dependencies = [
+ "js-sys",
+ "opentelemetry",
+ "smallvec",
+ "tracing",
+ "tracing-core",
+ "tracing-log",
+ "tracing-subscriber 0.3.22",
+ "web-time",
+]
+
+[[package]]
+name = "tracing-serde"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "704b1aeb7be0d0a84fc9828cae51dab5970fee5088f83d1dd7ee6f6246fc6ff1"
+dependencies = [
+ "serde",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e0d2eaa99c3c2e41547cfa109e910a68ea03823cccad4a0525dcbc9b01e8c71"
+dependencies = [
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.3.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f30143827ddab0d256fd843b7a66d164e9f271cfa0dde49142c5ca0ca291f1e"
+dependencies = [
+ "matchers",
+ "nu-ansi-term 0.50.3",
+ "once_cell",
+ "regex-automata",
+ "serde",
+ "serde_json",
+ "sharded-slab",
+ "smallvec",
+ "thread_local",
+ "tracing",
+ "tracing-core",
+ "tracing-log",
+ "tracing-serde",
+]
+
+[[package]]
+name = "trait-set"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b79e2e9c9ab44c6d7c20d5976961b47e8f49ac199154daa514b77cd1ab536625"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "triomphe"
+version = "0.1.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd69c5aa8f924c7519d6372789a74eac5b94fb0f8fcf0d4a97eb0bfc3e785f39"
+dependencies = [
+ "serde",
+ "stable_deref_trait",
+]
+
+[[package]]
+name = "try-lock"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
+
+[[package]]
+name = "try_match"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b065c869a3f832418e279aa4c1d7088f9d5d323bde15a60a08e20c2cd4549082"
+dependencies = [
+ "try_match_inner",
+]
+
+[[package]]
+name = "try_match_inner"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9c81686f7ab4065ccac3df7a910c4249f8c0f3fb70421d6ddec19b9311f63f9"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "tungstenite"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8628dcc84e5a09eb3d8423d6cb682965dea9133204e8fb3efee74c2a0c259442"
+dependencies = [
+ "bytes",
+ "data-encoding",
+ "http 1.4.0",
+ "httparse",
+ "log",
+ "rand 0.9.2",
+ "rustls",
+ "rustls-pki-types",
+ "sha1",
+ "thiserror 2.0.18",
+ "utf-8",
+ "webpki-roots 0.26.11",
+]
+
+[[package]]
+name = "typed-arena"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6af6ae20167a9ece4bcb41af5b80f8a1f1df981f6391189ce00fd257af04126a"
+
+[[package]]
+name = "typenum"
+version = "1.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"
+
+[[package]]
+name = "typeshare"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da1bf9fe204f358ffea7f8f779b53923a20278b3ab8e8d97962c5e1b3a54edb7"
+dependencies = [
+ "chrono",
+ "serde",
+ "serde_json",
+ "typeshare-annotation",
+]
+
+[[package]]
+name = "typeshare-annotation"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "621963e302416b389a1ec177397e9e62de849a78bd8205d428608553def75350"
+dependencies = [
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "ucd-trie"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"
+
+[[package]]
+name = "uint"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
+dependencies = [
+ "byteorder",
+ "crunchy",
+ "hex",
+ "static_assertions",
+]
+
+[[package]]
+name = "unarray"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"
+
+[[package]]
+name = "uncased"
+version = "0.9.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e1b88fcfe09e89d3866a5c11019378088af2d24c3fbd4f0543f96b479ec90697"
+dependencies = [
+ "version_check",
+]
+
+[[package]]
+name = "unicase"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dbc4bc3a9f746d862c45cb89d705aa10f187bb96c76001afab07a0d35ce60142"
+
+[[package]]
+name = "unicode-bidi"
+version = "0.3.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"
+
+[[package]]
+name = "unicode-linebreak"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"
+
+[[package]]
+name = "unicode-normalization"
+version = "0.1.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5fd4f6878c9cb28d874b009da9e8d183b5abc80117c40bbd187a1fde336be6e8"
+dependencies = [
+ "tinyvec",
+]
+
+[[package]]
+name = "unicode-segmentation"
+version = "1.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"
+
+[[package]]
+name = "unicode-width"
+version = "0.1.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"
+
+[[package]]
+name = "unicode-width"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b4ac048d71ede7ee76d585517add45da530660ef4390e49b098733c6e897f254"
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"
+
+[[package]]
+name = "unit-prefix"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81e544489bf3d8ef66c953931f56617f423cd4b5494be343d9b9d3dda037b9a3"
+
+[[package]]
+name = "universal-hash"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
+dependencies = [
+ "crypto-common",
+ "subtle",
+]
+
+[[package]]
+name = "unreachable"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56"
+dependencies = [
+ "void",
+]
+
+[[package]]
+name = "unsafe-libyaml"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"
+
+[[package]]
+name = "untrusted"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"
+
+[[package]]
+name = "untrusted"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"
+
+[[package]]
+name = "ureq"
+version = "1.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b8b063c2d59218ae09f22b53c42eaad0d53516457905f5235ca4bc9e99daa71"
+dependencies = [
+ "base64 0.13.1",
+ "chunked_transfer",
+ "log",
+ "native-tls",
+ "once_cell",
+ "qstring",
+ "serde",
+ "serde_json",
+ "url",
+]
+
+[[package]]
+name = "uriparse"
+version = "0.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0200d0fc04d809396c2ad43f3c95da3582a2556eba8d453c1087f4120ee352ff"
+dependencies = [
+ "fnv",
+ "lazy_static",
+]
+
+[[package]]
+name = "url"
+version = "2.5.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff67a8a4397373c3ef660812acab3268222035010ab8680ec4215f38ba3d0eed"
+dependencies = [
+ "form_urlencoded",
+ "idna 1.1.0",
+ "percent-encoding",
+ "serde",
+ "serde_derive",
+]
+
+[[package]]
+name = "utf-8"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"
+
+[[package]]
+name = "utf8_iter"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"
+
+[[package]]
+name = "utf8parse"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
+
+[[package]]
+name = "uuid"
+version = "1.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2e054861b4bd027cd373e18e8d8d8e6548085000e41290d95ce0c373a654b4a"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "valuable"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"
+
+[[package]]
+name = "variant_count"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1935e10c6f04d22688d07c0790f2fc0e1b1c5c2c55bc0cc87ed67656e587dd8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "vcpkg"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"
+
+[[package]]
+name = "vec_map"
+version = "0.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"
+
+[[package]]
+name = "version_check"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
+
+[[package]]
+name = "void"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d"
+
+[[package]]
+name = "wait-timeout"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ac3b126d3914f9849036f826e054cbabdc8519970b8998ddaf3b5bd3c65f11"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "walkdir"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
+dependencies = [
+ "same-file",
+ "winapi-util",
+]
+
+[[package]]
+name = "want"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
+dependencies = [
+ "try-lock",
+]
+
+[[package]]
+name = "wasi"
+version = "0.9.0+wasi-snapshot-preview1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"
+
+[[package]]
+name = "wasi"
+version = "0.11.1+wasi-snapshot-preview1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"
+
+[[package]]
+name = "wasip2"
+version = "1.0.2+wasi-0.2.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9517f9239f02c069db75e65f174b3da828fe5f5b945c4dd26bd25d89c03ebcf5"
+dependencies = [
+ "wit-bindgen",
+]
+
+[[package]]
+name = "wasite"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.108"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64024a30ec1e37399cf85a7ffefebdb72205ca1c972291c51512360d90bd8566"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-futures"
+version = "0.4.58"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70a6e77fd0ae8029c9ea0063f87c46fde723e7d887703d74ad2616d792e51e6f"
+dependencies = [
+ "cfg-if",
+ "futures-util",
+ "js-sys",
+ "once_cell",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.108"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "008b239d9c740232e71bd39e8ef6429d27097518b6b30bdf9086833bd5b6d608"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.108"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5256bae2d58f54820e6490f9839c49780dff84c65aeab9e772f15d5f0e913a55"
+dependencies = [
+ "bumpalo",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.108"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f01b580c9ac74c8d8f0c0e4afb04eeef2acf145458e52c03845ee9cd23e3d12"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "wasm-streams"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "15053d8d85c7eccdbefef60f06769760a563c7f0a9d6902a13d35c7800b0ad65"
+dependencies = [
+ "futures-util",
+ "js-sys",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+]
+
+[[package]]
+name = "wasmtimer"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c598d6b99ea013e35844697fc4670d08339d5cda15588f193c6beedd12f644b"
+dependencies = [
+ "futures",
+ "js-sys",
+ "parking_lot",
+ "pin-utils",
+ "slab",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "web-sys"
+version = "0.3.85"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "312e32e551d92129218ea9a2452120f4aabc03529ef03e4d0d82fb2780608598"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "web-time"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "webpki-root-certs"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "36a29fc0408b113f68cf32637857ab740edfafdf460c326cd2afaa2d84cc05dc"
+dependencies = [
+ "rustls-pki-types",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "0.26.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "521bc38abb08001b01866da9f51eb7c5d647a19260e00054a8c7fd5f9e57f7a9"
+dependencies = [
+ "webpki-roots 1.0.5",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12bed680863276c63889429bfd6cab3b99943659923822de1c8a39c49e4d722c"
+dependencies = [
+ "rustls-pki-types",
+]
+
+[[package]]
+name = "whoami"
+version = "1.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d4a4db5077702ca3015d3d02d74974948aba2ad9e12ab7df718ee64ccd7e97d"
+dependencies = [
+ "libredox",
+ "wasite",
+ "web-sys",
+]
+
+[[package]]
+name = "widestring"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17882f045410753661207383517a6f62ec3dbeb6a4ed2acce01f0728238d1983"
+
+[[package]]
+name = "wildmatch"
+version = "2.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "29333c3ea1ba8b17211763463ff24ee84e41c78224c16b001cd907e663a38c68"
+
+[[package]]
+name = "winapi"
+version = "0.2.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-util"
+version = "0.1.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
+dependencies = [
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+
+[[package]]
+name = "windows-core"
+version = "0.62.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "053e2e040ab57b9dc951b72c264860db7eb3b0200ba345b4e4c3b14f67855ddf"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f316c4a2570ba26bbec722032c4099d8c8bc095efccdc15688708623367e358"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"
+
+[[package]]
+name = "windows-registry"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "02752bf7fbdcce7f2a27a742f798510f3e5ad88dbe84871e5168e2120c3d5720"
+dependencies = [
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-result"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.45.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
+dependencies = [
+ "windows-targets 0.42.2",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.48.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
+dependencies = [
+ "windows-targets 0.48.5",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.60.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
+dependencies = [
+ "windows-targets 0.53.5",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.61.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
+dependencies = [
+ "windows_aarch64_gnullvm 0.42.2",
+ "windows_aarch64_msvc 0.42.2",
+ "windows_i686_gnu 0.42.2",
+ "windows_i686_msvc 0.42.2",
+ "windows_x86_64_gnu 0.42.2",
+ "windows_x86_64_gnullvm 0.42.2",
+ "windows_x86_64_msvc 0.42.2",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
+dependencies = [
+ "windows_aarch64_gnullvm 0.48.5",
+ "windows_aarch64_msvc 0.48.5",
+ "windows_i686_gnu 0.48.5",
+ "windows_i686_msvc 0.48.5",
+ "windows_x86_64_gnu 0.48.5",
+ "windows_x86_64_gnullvm 0.48.5",
+ "windows_x86_64_msvc 0.48.5",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
+dependencies = [
+ "windows_aarch64_gnullvm 0.52.6",
+ "windows_aarch64_msvc 0.52.6",
+ "windows_i686_gnu 0.52.6",
+ "windows_i686_gnullvm 0.52.6",
+ "windows_i686_msvc 0.52.6",
+ "windows_x86_64_gnu 0.52.6",
+ "windows_x86_64_gnullvm 0.52.6",
+ "windows_x86_64_msvc 0.52.6",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.53.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
+dependencies = [
+ "windows-link",
+ "windows_aarch64_gnullvm 0.53.1",
+ "windows_aarch64_msvc 0.53.1",
+ "windows_i686_gnu 0.53.1",
+ "windows_i686_gnullvm 0.53.1",
+ "windows_i686_msvc 0.53.1",
+ "windows_x86_64_gnu 0.53.1",
+ "windows_x86_64_gnullvm 0.53.1",
+ "windows_x86_64_msvc 0.53.1",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.42.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.53.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"
+
+[[package]]
+name = "winnow"
+version = "0.5.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "winnow"
+version = "0.7.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5364e9d77fcdeeaa6062ced926ee3381faa2ee02d3eb83a5c27a8825540829"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "winreg"
+version = "0.50.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
+dependencies = [
+ "cfg-if",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "wiremock"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08db1edfb05d9b3c1542e521aea074442088292f00b5f28e435c714a98f85031"
+dependencies = [
+ "assert-json-diff",
+ "base64 0.22.1",
+ "deadpool",
+ "futures",
+ "http 1.4.0",
+ "http-body-util",
+ "hyper 1.8.1",
+ "hyper-util",
+ "log",
+ "once_cell",
+ "regex",
+ "serde",
+ "serde_json",
+ "tokio",
+ "url",
+]
+
+[[package]]
+name = "wit-bindgen"
+version = "0.51.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7249219f66ced02969388cf2bb044a09756a083d0fab1e566056b04d9fbcaa5"
+
+[[package]]
+name = "writeable"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9edde0db4769d2dc68579893f2306b26c6ecfbe0ef499b013d731b7b9247e0b9"
+
+[[package]]
+name = "wyz"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
+dependencies = [
+ "tap",
+]
+
+[[package]]
+name = "x25519-dalek"
+version = "1.2.0"
+source = "git+https://github.com/aptos-labs/x25519-dalek?rev=b9cdbaf36bf2a83438d9f660e5a708c82ed60d8e#b9cdbaf36bf2a83438d9f660e5a708c82ed60d8e"
+dependencies = [
+ "curve25519-dalek 3.2.0",
+ "rand_core 0.5.1",
+ "zeroize",
+]
+
+[[package]]
+name = "x402-axum"
+version = "1.0.0"
+dependencies = [
+ "alloy-primitives",
+ "axum 0.8.8",
+ "axum-core 0.5.6",
+ "http 1.4.0",
+ "reqwest 0.13.1",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tokio",
+ "tower 0.5.3",
+ "tracing",
+ "url",
+ "wiremock",
+ "x402-chain-eip155",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-axum-example"
+version = "0.1.0"
+dependencies = [
+ "alloy-primitives",
+ "axum 0.8.8",
+ "dotenvy",
+ "http 1.4.0",
+ "solana-pubkey 4.0.0",
+ "tokio",
+ "tracing",
+ "tracing-subscriber 0.3.22",
+ "x402-axum",
+ "x402-chain-eip155",
+ "x402-chain-solana",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-chain-aptos"
+version = "1.0.0"
+dependencies = [
+ "aptos-crypto",
+ "aptos-rest-client",
+ "aptos-types",
+ "async-trait",
+ "bcs 0.1.6",
+ "hex",
+ "move-core-types",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tracing",
+ "url",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-chain-eip155"
+version = "1.0.0"
+dependencies = [
+ "alloy-contract",
+ "alloy-network",
+ "alloy-primitives",
+ "alloy-provider",
+ "alloy-rpc-client",
+ "alloy-rpc-types-eth",
+ "alloy-signer",
+ "alloy-signer-local",
+ "alloy-sol-types",
+ "alloy-transport",
+ "alloy-transport-http",
+ "async-trait",
+ "dashmap 6.1.0",
+ "rand 0.9.2",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tokio",
+ "tower 0.5.3",
+ "tracing",
+ "tracing-core",
+ "url",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-chain-solana"
+version = "1.0.0"
+dependencies = [
+ "alloy-primitives",
+ "async-trait",
+ "bincode",
+ "bs58",
+ "futures-util",
+ "serde",
+ "serde_json",
+ "solana-account",
+ "solana-client",
+ "solana-commitment-config",
+ "solana-compute-budget-interface",
+ "solana-keypair",
+ "solana-message",
+ "solana-pubkey 4.0.0",
+ "solana-signature",
+ "solana-signer",
+ "solana-transaction",
+ "spl-token",
+ "spl-token-2022",
+ "thiserror 2.0.18",
+ "tokio",
+ "tracing",
+ "tracing-core",
+ "url",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-facilitator"
+version = "1.0.0"
+dependencies = [
+ "async-trait",
+ "axum 0.8.8",
+ "dotenvy",
+ "rustls",
+ "serde",
+ "serde_json",
+ "tokio",
+ "tower-http",
+ "tracing",
+ "x402-chain-aptos",
+ "x402-chain-eip155",
+ "x402-chain-solana",
+ "x402-facilitator-local",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-facilitator-local"
+version = "1.0.0"
+dependencies = [
+ "axum 0.8.8",
+ "opentelemetry",
+ "opentelemetry-otlp",
+ "opentelemetry-semantic-conventions",
+ "opentelemetry-stdout",
+ "opentelemetry_sdk",
+ "serde",
+ "serde_json",
+ "thiserror 2.0.18",
+ "tokio",
+ "tokio-util",
+ "tower-http",
+ "tracing",
+ "tracing-opentelemetry",
+ "tracing-subscriber 0.3.22",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-reqwest"
+version = "1.0.0"
+dependencies = [
+ "alloy-signer-local",
+ "async-trait",
+ "http 1.4.0",
+ "reqwest 0.13.1",
+ "reqwest-middleware 0.5.0",
+ "serde_json",
+ "tracing",
+ "x402-chain-eip155",
+ "x402-types",
+]
+
+[[package]]
+name = "x402-reqwest-example"
+version = "0.1.0"
+dependencies = [
+ "alloy-signer-local",
+ "dotenvy",
+ "reqwest 0.13.1",
+ "solana-client",
+ "solana-keypair",
+ "tokio",
+ "x402-chain-eip155",
+ "x402-chain-solana",
+ "x402-reqwest",
+]
+
+[[package]]
+name = "x402-types"
+version = "1.0.0"
+dependencies = [
+ "alloy-primitives",
+ "async-trait",
+ "base64 0.22.1",
+ "clap 4.5.54",
+ "regex",
+ "rust_decimal",
+ "serde",
+ "serde_json",
+ "serde_with",
+ "thiserror 2.0.18",
+ "tracing",
+]
+
+[[package]]
+name = "x509-parser"
+version = "0.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e0ecbeb7b67ce215e40e3cc7f2ff902f94a223acf44995934763467e7b1febc8"
+dependencies = [
+ "asn1-rs",
+ "base64 0.13.1",
+ "data-encoding",
+ "der-parser",
+ "lazy_static",
+ "nom",
+ "oid-registry",
+ "rusticata-macros",
+ "thiserror 1.0.69",
+ "time",
+]
+
+[[package]]
+name = "yaml-rust"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
+dependencies = [
+ "linked-hash-map",
+]
+
+[[package]]
+name = "yoke"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72d6e5c6afb84d73944e5cedb052c4680d5657337201555f9f2a16b7406d4954"
+dependencies = [
+ "stable_deref_trait",
+ "yoke-derive",
+ "zerofrom",
+]
+
+[[package]]
+name = "yoke-derive"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b659052874eb698efe5b9e8cf382204678a0086ebf46982b79d6ca3182927e5d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+ "synstructure 0.13.2",
+]
+
+[[package]]
+name = "z3tracer"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57b52f3d4b300ffa9400cd78caebaaa6ef5a0189d08ec134624e2b8f3890b6e0"
+dependencies = [
+ "smt2parser",
+ "structopt",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "zerocopy"
+version = "0.8.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "668f5168d10b9ee831de31933dc111a459c97ec93225beb307aed970d1372dfd"
+dependencies = [
+ "zerocopy-derive",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c7962b26b0a8685668b671ee4b54d007a67d4eaf05fda79ac0ecf41e32270f1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "zerofrom"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
+dependencies = [
+ "zerofrom-derive",
+]
+
+[[package]]
+name = "zerofrom-derive"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+ "synstructure 0.13.2",
+]
+
+[[package]]
+name = "zeroize"
+version = "1.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b97154e67e32c85465826e8bcc1c59429aaaf107c1e4a9e53c8d8ccd5eff88d0"
+dependencies = [
+ "zeroize_derive",
+]
+
+[[package]]
+name = "zeroize_derive"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85a5b4158499876c763cb03bc4e49185d3cccbabb15b33c627f7884f43db852e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "zerotrie"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a59c17a5562d507e4b54960e8569ebee33bee890c70aa3fe7b97e85a9fd7851"
+dependencies = [
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+]
+
+[[package]]
+name = "zerovec"
+version = "0.11.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c28719294829477f525be0186d13efa9a3c602f7ec202ca9e353d310fb9a002"
+dependencies = [
+ "yoke",
+ "zerofrom",
+ "zerovec-derive",
+]
+
+[[package]]
+name = "zerovec-derive"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eadce39539ca5cb3985590102671f2567e659fca9666581ad3411d59207951f3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "zmij"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94f63c051f4fe3c1509da62131a678643c5b6fbdc9273b2b79d4378ebda003d2"
+
+[[package]]
+name = "zstd"
+version = "0.13.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e91ee311a569c327171651566e07972200e76fcfe2242a4fa446149a3881c08a"
+dependencies = [
+ "zstd-safe",
+]
+
+[[package]]
+name = "zstd-safe"
+version = "7.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f49c4d5f0abb602a93fb8736af2a4f4dd9512e36f7f570d66e65ff867ed3b9d"
+dependencies = [
+ "zstd-sys",
+]
+
+[[package]]
+name = "zstd-sys"
+version = "2.0.16+zstd.1.5.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91e19ebc2adc8f83e43039e79776e3fda8ca919132d68a1fed6a5faca2683748"
+dependencies = [
+ "cc",
+ "pkg-config",
+]
diff --git a/bbt-x402-facilitator/Cargo.toml b/bbt-x402-facilitator/Cargo.toml
new file mode 100644
index 0000000..9fbdf3d
--- /dev/null
+++ b/bbt-x402-facilitator/Cargo.toml
@@ -0,0 +1,62 @@
+[workspace]
+resolver = "3"
+members = [
+  "crates/x402-types",
+  "crates/x402-axum",
+  "crates/x402-reqwest",
+  "crates/x402-facilitator-local",
+  "crates/chains/x402-chain-eip155",
+  "crates/chains/x402-chain-solana",
+  "crates/chains/x402-chain-aptos",
+  "facilitator",
+  "examples/x402-axum-example",
+  "examples/x402-reqwest-example",
+]
+
+[workspace.package]
+version = "1.0.0"
+authors = ["Sergey Ukustov <sergey@ukstv.me>"]
+edition = "2024"
+license = "Apache-2.0"
+repository = "https://github.com/x402-rs/x402-rs"
+homepage = "https://x402.rs"
+rust-version = "1.88.0"
+keywords = ["blockchain", "payments", "x402", "stablecoin", "http-402"]
+categories = ["cryptography::cryptocurrencies", "finance", "network-programming", "web-programming::http-server"]
+
+[workspace.dependencies]
+x402-axum = { version = "1.0", path = "crates/x402-axum" }
+x402-chain-aptos = { version = "1.0", path = "crates/chains/x402-chain-aptos" }
+x402-chain-eip155 = { version = "1.0", path = "crates/chains/x402-chain-eip155" }
+x402-chain-solana = { version = "1.0", path = "crates/chains/x402-chain-solana" }
+x402-facilitator-local = { version = "1.0", path = "crates/x402-facilitator-local" }
+x402-reqwest = { version = "1.0", path = "crates/x402-reqwest" }
+x402-types = { version = "1.0", path = "crates/x402-types" }
+
+alloy-primitives = { version = "1.4.1" } # To represent token amounts
+async-trait = { version = "0.1" }
+axum = { version = "0.8" }
+dotenvy = { version = "0.15.7" }
+http = { version = "1.4" }
+reqwest = { version = "0.13", features = ["json"] }
+serde = { version = "1.0", features = ["derive"] }
+serde_json = { version = "1.0", features = ["raw_value"] }
+
+# Common dependencies
+thiserror = { version = "2.0" }
+tokio = { version = "1.35", features = ["sync", "rt-multi-thread"] }
+tokio-util = { version = "0.7.16", features = ["rt"] }
+tower = { version = "0.5" }
+tower-http = { version = "0.6.6", features = ["trace", "cors"] }
+tracing = { version = "0.1" }
+tracing-core = { version = "0.1.34" }
+tracing-subscriber = { version = "0.3", features = ["env-filter"] }
+url = { version = "2.5", features = ["serde"] }
+clap = { version = "4.5", features = ["derive", "env"] }
+
+# Patches for aptos-core dependencies
+[patch.crates-io]
+merlin = { git = "https://github.com/aptos-labs/merlin" }
+
+[patch."https://github.com/aptos-labs/aptos-core"]
+aptos-runtimes = { path = "patches/aptos-runtimes" }
diff --git a/bbt-x402-facilitator/Dockerfile b/bbt-x402-facilitator/Dockerfile
new file mode 100644
index 0000000..a0412f3
--- /dev/null
+++ b/bbt-x402-facilitator/Dockerfile
@@ -0,0 +1,30 @@
+FROM --platform=$BUILDPLATFORM rust:trixie AS builder
+
+ENV PORT=9090
+
+WORKDIR /app
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    pkg-config \
+    libssl-dev \
+ && rm -rf /var/lib/apt/lists/*
+
+COPY . ./
+RUN cargo build --package x402-facilitator --features full --release --locked
+
+# --- Stage 2 ---
+FROM --platform=$BUILDPLATFORM debian:trixie-slim
+
+ENV PORT=9090
+
+RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates && \
+    rm -rf /var/lib/apt/lists/*
+
+WORKDIR /app
+
+COPY --from=builder /app/target/release/x402-facilitator /usr/local/bin/x402-facilitator
+
+EXPOSE $PORT
+ENV RUST_LOG=info
+
+ENTRYPOINT ["x402-facilitator"]
diff --git a/bbt-x402-facilitator/LICENSE b/bbt-x402-facilitator/LICENSE
new file mode 100644
index 0000000..0e18545
--- /dev/null
+++ b/bbt-x402-facilitator/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2025 Sergey Ukustov
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
\ No newline at end of file
diff --git a/bbt-x402-facilitator/README.md b/bbt-x402-facilitator/README.md
new file mode 100644
index 0000000..f28ffed
--- /dev/null
+++ b/bbt-x402-facilitator/README.md
@@ -0,0 +1,148 @@
+# x402-rs
+
+[![Crates.io](https://img.shields.io/crates/v/x402-types.svg)](https://crates.io/crates/x402-types)
+[![Docs.rs](https://docs.rs/x402-types/badge.svg)](https://docs.rs/x402-types)
+[![GHCR](https://img.shields.io/badge/ghcr.io-x402--facilitator-blue)](https://github.com/orgs/x402-rs/packages/container/package/x402-facilitator)
+
+> A comprehensive Rust toolkit for the [x402 protocol](https://www.x402.org), enabling blockchain payments directly through HTTP using the native `402 Payment Required` status code.
+
+x402-rs is a modular, production-ready implementation of the x402 protocol with support for multiple blockchains (EVM, Solana, Aptos, ..) and protocol versions (V1 and V2).
+
+### Core Crates
+
+| Crate                                                           | Badges                                                                                                                                                                                                                             | Description                                                                                      |
+|-----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
+| **[`x402-types`](./crates/x402-types)**                         | [![Crates.io](https://img.shields.io/crates/v/x402-types.svg)](https://crates.io/crates/x402-types) [![Docs.rs](https://docs.rs/x402-types/badge.svg)](https://docs.rs/x402-types)                                                 | Core protocol types, facilitator traits, and utilities. Foundation for all x402 implementations. |
+| **[`x402-axum`](./crates/x402-axum)**                           | [![Crates.io](https://img.shields.io/crates/v/x402-axum.svg)](https://crates.io/crates/x402-axum) [![Docs.rs](https://docs.rs/x402-axum/badge.svg)](https://docs.rs/x402-axum)                                                     | Axum middleware for protecting routes with x402 payments.                                        |
+| **[`x402-reqwest`](./crates/x402-reqwest)**                     | [![Crates.io](https://img.shields.io/crates/v/x402-reqwest.svg)](https://crates.io/crates/x402-reqwest) [![Docs.rs](https://docs.rs/x402-reqwest/badge.svg)](https://docs.rs/x402-reqwest)                                         | Reqwest middleware for transparent x402 payment handling.                                        |
+| **[`x402-facilitator-local`](./crates/x402-facilitator-local)** | [![Crates.io](https://img.shields.io/crates/v/x402-facilitator-local.svg)](https://crates.io/crates/x402-facilitator-local) [![Docs.rs](https://docs.rs/x402-facilitator-local/badge.svg)](https://docs.rs/x402-facilitator-local) | Local facilitator implementation for payment verification and settlement.                        |
+
+### Blockchain Support
+
+| Crate                                                        | Badges                                                                                                                                                                                                         | Description                                               |
+|--------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
+| **[`x402-chain-eip155`](./crates/chains/x402-chain-eip155)** | [![Crates.io](https://img.shields.io/crates/v/x402-chain-eip155.svg)](https://crates.io/crates/x402-chain-eip155) [![Docs.rs](https://docs.rs/x402-chain-eip155/badge.svg)](https://docs.rs/x402-chain-eip155) | EVM/EIP-155 chain support (Ethereum, Base, Polygon, etc.) |
+| **[`x402-chain-solana`](./crates/chains/x402-chain-solana)** | [![Crates.io](https://img.shields.io/crates/v/x402-chain-solana.svg)](https://crates.io/crates/x402-chain-solana) [![Docs.rs](https://docs.rs/x402-chain-solana/badge.svg)](https://docs.rs/x402-chain-solana) | Solana blockchain support                                 |
+| **[`x402-chain-aptos`](./crates/chains/x402-chain-aptos)**   | âš ï¸ Git-only                                                                                                                                                                                                    | Aptos blockchain support (requires git dependency)        |
+
+### Deployment
+
+| Crate                                   | Description                                                             |
+|-----------------------------------------|-------------------------------------------------------------------------|
+| **[`x402-facilitator`](./facilitator)** | Production-ready facilitator server binary (not published to crates.io) |
+
+## About x402
+
+The [x402 protocol](https://www.x402.org) is a proposed standard for making blockchain payments directly through HTTP using the native `402 Payment Required` status code.
+
+**How it works:**
+1. **Server** declares payment requirements for specific routes
+2. **Client** sends cryptographically signed payment payloads
+3. **Facilitator** verifies and settles payments on-chain
+
+This enables seamless pay-per-use transactions without requiring clients to manage blockchain interactions directly.
+
+## Quick Start
+
+### Protect Routes (Server)
+
+Use `x402-axum` to gate your routes behind on-chain payments:
+
+```rust
+use alloy_primitives::address;
+use axum::{Router, routing::get};
+use x402_axum::X402Middleware;
+use x402_chain_eip155::V2Eip155Exact;
+use x402_types::networks::USDC;
+
+let x402 = X402Middleware::new("http://facilitator.example.com");
+
+let app = Router::new().route(
+    "/paid-content",
+    get(handler).layer(
+        x402.with_price_tag(V2Eip155Exact::price_tag(
+            address!("0xYourAddress"),
+            USDC::base_sepolia().amount(10u64),
+        ))
+    ),
+);
+```
+
+See [`x402-axum` documentation](./crates/x402-axum/README.md) for more details.
+
+### Send Payments (Client)
+
+Use `x402-reqwest` to automatically handle x402 payments:
+
+```rust
+use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+use x402_chain_eip155::V2Eip155ExactClient;
+use alloy_signer_local::PrivateKeySigner;
+use std::sync::Arc;
+use reqwest::Client;
+
+let signer: Arc<PrivateKeySigner> = Arc::new("0x...".parse()?);
+
+let x402_client = X402Client::new()
+    .register(V2Eip155ExactClient::new(signer));
+
+let client = Client::new()
+    .with_payments(x402_client)
+    .build();
+
+let res = client
+    .get("https://example.com/protected")
+    .send()
+    .await?;
+```
+
+See [`x402-reqwest` documentation](./crates/x402-reqwest/README.md) for more details.
+
+## Run a Facilitator
+
+### Docker
+
+Prebuilt Docker images are available at [GitHub Container Registry](https://github.com/orgs/x402-rs/packages/container/package/x402-facilitator):
+
+```shell
+docker run -v $(pwd)/config.json:/app/config.json -p 9090:9090 ghcr.io/x402-rs/x402-facilitator
+```
+
+### Build Your Own
+
+For custom facilitator implementations, see the [Build Your Own Facilitator](./docs/build-your-own-facilitator.md) guide.
+
+For full facilitator configuration and deployment details, see the [`x402-facilitator` README](./facilitator/README.md).
+
+## Roadmap
+
+| Milestone                           | Description                                                                                              |   Status   |
+|:------------------------------------|:---------------------------------------------------------------------------------------------------------|:----------:|
+| Facilitator for Base USDC           | Payment verification and settlement service, enabling real-time pay-per-use transactions for Base chain. | âœ… Complete |
+| Metrics and Tracing                 | Expose OpenTelemetry metrics and structured tracing for observability, monitoring, and debugging         | âœ… Complete |
+| Server Middleware                   | Provide ready-to-use integration for Rust web frameworks such as axum and tower.                         | âœ… Complete |
+| Client Library                      | Provide a lightweight Rust library for initiating and managing x402 payment flows from Rust clients.     | âœ… Complete |
+| Solana Support                      | Support Solana chain.                                                                                    | âœ… Complete |
+| Protocol v2 Support                 | Support x402 protocol version 2 with improved payload structure.                                         | âœ… Complete |
+| Multiple chains and multiple tokens | Support various tokens and EVM compatible chains.                                                        | âœ… Complete |
+| Axum Middleware v2 Support          | Full x402 protocol v2 support in x402-axum with multi-chain, multi-scheme architecture.                  | âœ… Complete |
+| Reqwest Client v2 Support           | Full x402 protocol v2 support in x402-reqwest with multi-chain, multi-scheme architecture.               | âœ… Complete |
+| Build your own facilitator hooks    | Pre/post hooks for analytics, access control, and auditability.                                          | ðŸ”œ Planned |
+| Bazaar Extension                    | Marketplace integration for discovering and purchasing x402-protected resources.                         | ðŸ”œ Planned |
+| Gasless Approval Flow               | Support for Permit2 and ERC20 approvals to enable gasless payment authorization.                         | ðŸ”œ Planned |
+| Upto Scheme                         | Payment scheme supporting "up to" amount payments with flexible pricing.                                 | ðŸ”œ Planned |
+| Deferred Scheme                     | Payment scheme supporting deferred settlement and payment scheduling.                                    | ðŸ”œ Planned |
+
+## Related Resources
+
+* [x402 Protocol Documentation](https://x402.org)
+* [x402 Overview by Coinbase](https://docs.cdp.coinbase.com/x402/docs/overview)
+* [Facilitator Documentation by Coinbase](https://docs.cdp.coinbase.com/x402/docs/facilitator)
+
+## Contributions and Feedback
+
+Feel free to open issues or pull requests to improve x402 support in the Rust ecosystem.
+
+## License
+
+[Apache-2.0](LICENSE)
diff --git a/bbt-x402-facilitator/config.json.example b/bbt-x402-facilitator/config.json.example
new file mode 100644
index 0000000..66d5f81
--- /dev/null
+++ b/bbt-x402-facilitator/config.json.example
@@ -0,0 +1,45 @@
+{
+  "port": 9090,
+  "host": "0.0.0.0",
+  "chains": {
+    "eip155:84532": {
+      "_comment": "Base Sepolia"
+      "eip1559": true,
+      "flashblocks": true,
+      "signers": [
+          "0xWALLET"
+      ],
+      "rpc": [
+        {
+          "http": "https://rpc.com/eip155/84532",
+          "rate_limit": 50
+        }
+      ]
+    },
+    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "_comment": "Solana Mainnet"
+      "signer": "SOLANA_PRIVATE_KEY",
+      "rpc": "https://rpc.com/solana/5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
+      "pubsub": "wss://rpc.com/solana/5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
+    }
+  },
+  "schemes": [
+      {
+        "id": "v1-eip155-exact",
+        "chains": "eip155:*"
+      },
+      {
+        "id": "v2-eip155-exact",
+        "chains": "eip155:*"
+      },
+      {
+        "_comment": "Solana schemes allow Phantom Lighthouse program by default",
+        "id": "v1-solana-exact",
+        "chains": "solana:*"
+      },
+      {
+        "id": "v2-solana-exact",
+        "chains": "solana:*"
+      }
+    ]
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/Cargo.toml b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/Cargo.toml
new file mode 100644
index 0000000..08c52a8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/Cargo.toml
@@ -0,0 +1,43 @@
+[package]
+name = "x402-chain-aptos"
+publish = false # Due to Aptos dependencies not published on crates.io
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+keywords.workspace = true
+categories.workspace = true
+description = "Aptos chain support for the x402 payment protocol"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[features]
+default = []
+telemetry = ["tracing", "x402-types/telemetry"]
+facilitator = ["async-trait", "url", "hex", "aptos-crypto", "aptos-types", "bcs", "aptos-rest-client"]
+full = ["telemetry", "facilitator"]
+
+[dependencies]
+x402-types = { workspace = true }
+serde = { workspace = true }
+thiserror = { workspace = true }
+serde_json = { workspace = true }
+
+url = { workspace = true, optional = true }
+async-trait = { workspace = true, optional = true }
+hex = { version = "0.4", optional = true }
+move-core-types = { git = "https://github.com/aptos-labs/aptos-core", tag = "aptos-node-v1.39.2" }
+
+# Facilitator feature
+aptos-crypto = { git = "https://github.com/aptos-labs/aptos-core", tag = "aptos-node-v1.39.2", optional = true }
+aptos-rest-client = { git = "https://github.com/aptos-labs/aptos-core", tag = "aptos-node-v1.39.2", optional = true }
+aptos-types = { git = "https://github.com/aptos-labs/aptos-core", tag = "aptos-node-v1.39.2", optional = true }
+bcs = { version = "0.1", optional = true }
+
+# Telemetry
+tracing = { workspace = true, optional = true }
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/README.md b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/README.md
new file mode 100644
index 0000000..bd875bb
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/README.md
@@ -0,0 +1,138 @@
+# x402-chain-aptos
+
+[![Crates.io](https://img.shields.io/crates/v/x402-chain-aptos.svg)](https://crates.io/crates/x402-chain-aptos)
+[![Docs.rs](https://docs.rs/x402-chain-aptos/badge.svg)](https://docs.rs/x402-chain-aptos)
+
+Aptos chain support for the x402 payment protocol.
+
+This crate provides implementations of the x402 payment protocol for the Aptos blockchain. It currently supports the V2
+protocol with the "exact" payment scheme based on fungible asset transfers with sponsored (gasless) transactions.
+
+## Features
+
+- **V2 Protocol Support**: Implements V2 protocol with CAIP-2 chain ID addressing
+- **Fungible Asset Payments**: Token transfers using `0x1::primary_fungible_store::transfer`
+- **Sponsored Transactions**: Facilitator pays gas fees for user transactions
+- **Transaction Simulation**: Pre-flight validation before settlement
+- **Balance Verification**: On-chain balance checks before settlement
+- **BCS Encoding**: Binary Canonical Serialization for transaction payloads
+
+## Architecture
+
+The crate is organized into several modules:
+
+- **`chain`** - Core Aptos chain types, providers, and configuration
+- **`v2_aptos_exact`** - V2 protocol implementation with CAIP-2 chain IDs
+
+## Feature Flags
+
+- `facilitator` - Facilitator-side payment verification and settlement
+- `telemetry` - OpenTelemetry tracing support
+
+## Usage
+
+### Facilitator: Verifying and Settling
+
+```rust
+use x402_chain_aptos::{V2AptosExact, AptosChainProvider};
+use x402_types::scheme::X402SchemeFacilitatorBuilder;
+
+let provider = AptosChainProvider::from_config( & config).await?;
+let facilitator = V2AptosExact.build(provider, None) ?;
+
+// Verify payment
+let verify_response = facilitator.verify( & verify_request).await?;
+
+// Settle payment
+let settle_response = facilitator.settle( & settle_request).await?;
+```
+
+## Supported Networks
+
+The crate includes built-in support for Aptos networks:
+
+- **Aptos Mainnet** (`aptos:1`)
+- **Aptos Testnet** (`aptos:2`)
+
+Each network includes USDC token deployment information with proper fungible asset addresses and decimal precision.
+
+## Payment Flow
+
+### Client Side
+
+1. Client receives a `PaymentRequired` response with price tags
+2. Client selects a compatible payment option (Aptos + USDC)
+3. Client creates a fungible asset transfer transaction
+4. Client signs the transaction with their private key
+5. Client BCS-encodes and base64-encodes the transaction
+6. Client sends the payment payload to the server
+
+### Facilitator Side
+
+1. Facilitator receives the payment payload
+2. Deserializes and validates the BCS-encoded transaction
+3. Simulates the transaction to verify it will succeed
+4. Checks the payer's token balance
+5. For verification: Returns success if all checks pass
+6. For settlement: Adds sponsor signature and submits the transaction on-chain
+
+## Transaction Structure
+
+Aptos payments use BCS-encoded transactions containing:
+
+- **Entry function payload**: Call to `0x1::primary_fungible_store::transfer`
+- **Sender**: The payer's account address
+- **Sequence number**: The payer's current sequence number
+- **Gas parameters**: Max gas amount and gas unit price
+- **Expiration**: Transaction expiration timestamp
+- **Chain ID**: The Aptos network identifier
+
+When `sponsor_gas` is enabled, the facilitator adds a fee payer signature before submission.
+
+## Configuration
+
+### Facilitator Configuration Example
+
+```json
+{
+  "aptos:1": {
+    "sponsor_gas": true,
+    "signer": "$APTOS_FACILITATOR_KEY",
+    "rpc": "https://fullnode.mainnet.aptoslabs.com/v1",
+    "api_key": "$APTOS_API_KEY"
+  }
+}
+```
+
+### Configuration Parameters
+
+- **`sponsor_gas`**: Whether to sponsor gas fees (default: false)
+- **`signer`**: Hex-encoded Ed25519 private key (required if `sponsor_gas` is true)
+- **`rpc`**: Aptos REST API endpoint URL
+- **`api_key`**: Optional API key for rate-limited endpoints
+
+## Sponsored Transactions
+
+When `sponsor_gas` is enabled:
+
+1. Client creates and signs a transaction with their account
+2. Facilitator validates the transaction
+3. Facilitator adds its signature as the fee payer (sponsor)
+4. Facilitator submits the dual-signed transaction
+5. Facilitator's account pays the gas fees
+
+This allows users to make payments without holding APT for gas fees.
+
+## Dependencies
+
+This crate uses the official Aptos SDK crates:
+
+- `aptos-rest-client` - REST API client for Aptos
+- `aptos-types` - Core Aptos types and transaction structures
+- `aptos-crypto` - Ed25519 cryptography for signing
+- `move-core-types` - Move language types (AccountAddress, etc.)
+- `bcs` - Binary Canonical Serialization
+
+## License
+
+Apache 2.0
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/config.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/config.rs
new file mode 100644
index 0000000..9b9d785
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/config.rs
@@ -0,0 +1,171 @@
+use serde::{Deserialize, Serialize};
+use std::ops::Deref;
+use std::str::FromStr;
+use url::Url;
+use x402_types::chain::ChainId;
+use x402_types::config::LiteralOrEnv;
+
+use crate::chain::AptosChainReference;
+
+#[derive(Debug, Clone)]
+pub struct AptosChainConfig {
+    pub chain_reference: AptosChainReference,
+    pub inner: AptosChainConfigInner,
+}
+
+impl AptosChainConfig {
+    pub fn signer(&self) -> Option<&AptosSignerConfig> {
+        self.inner.signer.as_ref()
+    }
+    pub fn rpc(&self) -> &Url {
+        self.inner.rpc.inner()
+    }
+    pub fn api_key(&self) -> Option<&str> {
+        self.inner.api_key.as_ref().map(|k| k.inner().as_str())
+    }
+    pub fn sponsor_gas(&self) -> bool {
+        *self.inner.sponsor_gas.inner()
+    }
+    pub fn chain_reference(&self) -> AptosChainReference {
+        self.chain_reference
+    }
+    pub fn chain_id(&self) -> ChainId {
+        self.chain_reference.into()
+    }
+}
+
+/// Configuration specific to Aptos chains.
+///
+/// # Example - Using environment variables (recommended for deployments)
+///
+/// ```toml
+/// [aptos."aptos:1"]
+/// rpc = "$APTOS_RPC_URL"
+/// api_key = "$APTOS_API_KEY"
+/// sponsor_gas = "$APTOS_SPONSOR_GAS"
+/// signer = { private_key = "$APTOS_PRIVATE_KEY" }
+/// ```
+///
+/// Set these environment variables:
+/// - `APTOS_RPC_URL="https://fullnode.mainnet.aptoslabs.com/v1"`
+/// - `APTOS_API_KEY="your-api-key"` (optional, sent as Bearer token)
+/// - `APTOS_SPONSOR_GAS="true"`
+/// - `APTOS_PRIVATE_KEY="0x..."`
+///
+/// # Example - Literal values in config
+///
+/// ```toml
+/// [aptos."aptos:1"]
+/// rpc = "https://fullnode.mainnet.aptoslabs.com/v1"
+/// sponsor_gas = true
+/// signer = { private_key = "$APTOS_PRIVATE_KEY" }
+/// ```
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct AptosChainConfigInner {
+    /// RPC provider URL for this chain (required).
+    /// Supports literal URLs or environment variable references like "$APTOS_RPC_URL".
+    pub rpc: LiteralOrEnv<Url>,
+    /// Optional API key for authenticated RPC access (e.g., Geomi nodes).
+    /// If provided, sent as `Authorization: Bearer {api_key}` header with all RPC requests.
+    /// Supports literal strings or environment variable references like "$APTOS_API_KEY".
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub api_key: Option<LiteralOrEnv<String>>,
+    /// Signer configuration for this chain (optional, required only if sponsor_gas is true).
+    /// A hex-encoded private key (32 or 64 bytes) or env var reference like "$APTOS_PRIVATE_KEY".
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub signer: Option<AptosSignerConfig>,
+    /// Whether the facilitator should sponsor gas fees for transactions (default: false).
+    /// If true, facilitator signs as fee payer and pays gas. If false, users pay their own gas.
+    /// Supports literal booleans or environment variable references like "$APTOS_SPONSOR_GAS".
+    #[serde(default = "aptos_chain_config::default_sponsor_gas")]
+    pub sponsor_gas: LiteralOrEnv<bool>,
+}
+
+mod aptos_chain_config {
+    use super::LiteralOrEnv;
+
+    pub fn default_sponsor_gas() -> LiteralOrEnv<bool> {
+        // Default to false when field is missing
+        LiteralOrEnv::from_literal(false)
+    }
+}
+
+// ============================================================================
+// Aptos Private Key
+// ============================================================================
+
+/// A validated Aptos private key (32 or 64 bytes).
+///
+/// This type represents an Aptos private key which can be either:
+/// - 32 bytes: Ed25519 seed
+/// - 64 bytes: Full Ed25519 keypair (seed + public key)
+///
+/// The key is stored and parsed as a hex-encoded string with 0x prefix.
+#[derive(Clone, Debug, PartialEq, Eq)]
+pub struct AptosPrivateKey(Vec<u8>);
+
+impl AptosPrivateKey {
+    /// Parse a hex string into a private key.
+    pub fn from_hex(s: &str) -> Result<Self, String> {
+        let s = s.strip_prefix("0x").unwrap_or(s);
+        let bytes = hex::decode(s).map_err(|e| format!("Invalid hex: {}", e))?;
+
+        if bytes.len() != 32 && bytes.len() != 64 {
+            return Err(format!(
+                "Private key must be 32 or 64 bytes, got {} bytes",
+                bytes.len()
+            ));
+        }
+
+        Ok(Self(bytes))
+    }
+
+    /// Encode the private key as hex.
+    pub fn to_hex(&self) -> String {
+        format!("0x{}", hex::encode(&self.0))
+    }
+}
+
+impl Serialize for AptosPrivateKey {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&self.to_hex())
+    }
+}
+
+impl FromStr for AptosPrivateKey {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        Self::from_hex(s)
+    }
+}
+
+impl std::fmt::Display for AptosPrivateKey {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.to_hex())
+    }
+}
+
+/// Type alias for Aptos signer configuration.
+///
+/// Uses `LiteralOrEnv` to support both literal hex keys and environment variable references.
+///
+/// Example JSON:
+/// ```json
+/// {
+///   "signer": "$APTOS_FACILITATOR_KEY"
+/// }
+/// ```
+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
+pub struct AptosSignerConfig(LiteralOrEnv<AptosPrivateKey>);
+
+impl Deref for AptosSignerConfig {
+    type Target = AptosPrivateKey;
+
+    fn deref(&self) -> &Self::Target {
+        self.0.inner()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/mod.rs
new file mode 100644
index 0000000..da02a48
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/mod.rs
@@ -0,0 +1,12 @@
+#[cfg(feature = "facilitator")]
+pub mod config;
+#[cfg(feature = "facilitator")]
+pub use config::*;
+
+#[cfg(feature = "facilitator")]
+pub mod provider;
+#[cfg(feature = "facilitator")]
+pub use provider::*;
+
+pub mod types;
+pub use types::*;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/provider.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/provider.rs
new file mode 100644
index 0000000..8d59ee3
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/provider.rs
@@ -0,0 +1,218 @@
+use aptos_crypto::ed25519::Ed25519PrivateKey;
+use aptos_rest_client::Client as AptosClient;
+use move_core_types::account_address::AccountAddress;
+use std::fmt::{Debug, Formatter};
+use std::sync::Arc;
+use x402_types::chain::{ChainId, ChainProviderOps};
+use x402_types::scheme::X402SchemeFacilitatorError;
+
+use crate::chain::config::AptosChainConfig;
+use crate::chain::types::{Address, AptosChainReference};
+
+/// Errors that can occur when interacting with an Aptos chain provider.
+#[derive(thiserror::Error, Debug)]
+#[allow(clippy::enum_variant_names)]
+pub enum AptosChainProviderError {
+    /// BCS (Binary Canonical Serialization) error.
+    #[error("BCS deserialization error: {0}")]
+    BcsError(#[from] bcs::Error),
+    /// JSON serialization/deserialization error.
+    #[error("JSON error: {0}")]
+    JsonError(#[from] serde_json::Error),
+}
+
+impl From<AptosChainProviderError> for X402SchemeFacilitatorError {
+    fn from(value: AptosChainProviderError) -> Self {
+        Self::OnchainFailure(value.to_string())
+    }
+}
+
+/// Provider for interacting with an Aptos blockchain.
+///
+/// This provider handles transaction sponsorship, signing, and submission for
+/// Aptos-based x402 payments. It supports both sponsored (gasless) and non-sponsored
+/// transaction modes.
+///
+/// # Configuration
+///
+/// The provider requires:
+/// - A chain reference (mainnet or testnet)
+/// - An Aptos REST API endpoint
+/// - Optionally, a fee payer keypair for sponsored transactions
+/// - Optionally, an API key for rate-limited endpoints
+///
+/// # Sponsored Transactions
+///
+/// When `sponsor_gas` is enabled, the facilitator acts as the fee payer for
+/// user transactions. The client creates and signs a transaction, and the
+/// facilitator adds its signature as the sponsor before submitting.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_aptos::chain::AptosChainProvider;
+///
+/// let provider = AptosChainProvider::from_config(&config).await?;
+/// println!("Fee payer: {:?}", provider.account_address());
+/// ```
+pub struct AptosChainProvider {
+    /// The Aptos network this provider connects to.
+    chain: AptosChainReference,
+    /// Whether to sponsor gas fees for user transactions.
+    sponsor_gas: bool,
+    /// The fee payer account address (if sponsoring).
+    fee_payer_address: Option<AccountAddress>,
+    /// The fee payer private key (if sponsoring).
+    fee_payer_private_key: Option<Ed25519PrivateKey>,
+    /// The Aptos REST API client.
+    rest_client: Arc<AptosClient>,
+}
+
+impl Debug for AptosChainProvider {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("AptosChainProvider")
+            .field("chain", &self.chain)
+            .field("sponsor_gas", &self.sponsor_gas)
+            .field("rpc_url", &"<rest_client>")
+            .finish()
+    }
+}
+
+impl AptosChainProvider {
+    /// Creates a new provider from configuration.
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if:
+    /// - `sponsor_gas` is true but no signer is provided
+    /// - The private key is invalid
+    /// - The REST client cannot be initialized
+    pub async fn from_config(
+        config: &AptosChainConfig,
+    ) -> Result<Self, Box<dyn std::error::Error>> {
+        let chain = config.chain_reference();
+        let rpc_url = config.rpc();
+        let sponsor_gas = config.sponsor_gas();
+
+        // Validate: if sponsoring, signer must be provided
+        if sponsor_gas && config.signer().is_none() {
+            return Err("signer configuration required when sponsor_gas is true".into());
+        }
+
+        // Parse private key if signer is provided
+        let (fee_payer_address, fee_payer_private_key) = if let Some(signer) = config.signer() {
+            let private_key_hex = signer.to_string();
+            let private_key_hex = private_key_hex.trim_start_matches("0x");
+            let private_key_bytes = hex::decode(private_key_hex)?;
+            let private_key = Ed25519PrivateKey::try_from(private_key_bytes.as_slice())?;
+
+            // Derive account address from public key
+            use aptos_crypto::ed25519::Ed25519PublicKey;
+            use aptos_types::transaction::authenticator::AuthenticationKey;
+
+            let public_key: Ed25519PublicKey = (&private_key).into();
+            let auth_key = AuthenticationKey::ed25519(&public_key);
+            let account_address = auth_key.account_address();
+
+            (Some(account_address), Some(private_key))
+        } else {
+            (None, None)
+        };
+
+        // Create REST client with optional API key
+        let rest_client = if let Some(api_key) = config.api_key() {
+            use aptos_rest_client::AptosBaseUrl;
+            AptosClient::builder(AptosBaseUrl::Custom(rpc_url.clone()))
+                .api_key(api_key)?
+                .build()
+        } else {
+            AptosClient::new(rpc_url.clone())
+        };
+
+        let provider = Self::new(
+            chain,
+            sponsor_gas,
+            fee_payer_address,
+            fee_payer_private_key,
+            rest_client,
+        );
+        Ok(provider)
+    }
+
+    /// Creates a new Aptos chain provider.
+    ///
+    /// # Parameters
+    ///
+    /// - `chain`: The Aptos network identifier
+    /// - `sponsor_gas`: Whether to sponsor gas fees for user transactions
+    /// - `fee_payer_address`: Optional fee payer account address
+    /// - `fee_payer_private_key`: Optional fee payer private key
+    /// - `rest_client`: The Aptos REST API client
+    pub fn new(
+        chain: AptosChainReference,
+        sponsor_gas: bool,
+        fee_payer_address: Option<AccountAddress>,
+        fee_payer_private_key: Option<Ed25519PrivateKey>,
+        rest_client: AptosClient,
+    ) -> Self {
+        #[cfg(feature = "telemetry")]
+        {
+            let chain_id: ChainId = chain.into();
+            if let Some(address) = fee_payer_address {
+                tracing::info!(
+                    chain = %chain_id,
+                    address = %address,
+                    sponsor_gas = sponsor_gas,
+                    "Initialized Aptos provider with fee payer"
+                );
+            } else {
+                tracing::info!(
+                    chain = %chain_id,
+                    sponsor_gas = sponsor_gas,
+                    "Initialized Aptos provider without fee payer"
+                );
+            }
+        }
+        Self {
+            chain,
+            sponsor_gas,
+            fee_payer_address,
+            fee_payer_private_key,
+            rest_client: Arc::new(rest_client),
+        }
+    }
+
+    /// Returns a reference to the Aptos REST API client.
+    pub fn rest_client(&self) -> &AptosClient {
+        &self.rest_client
+    }
+
+    /// Returns whether gas sponsorship is enabled.
+    pub fn sponsor_gas(&self) -> bool {
+        self.sponsor_gas
+    }
+
+    /// Returns the fee payer account address, if configured.
+    pub fn account_address(&self) -> Option<AccountAddress> {
+        self.fee_payer_address
+    }
+
+    /// Returns a reference to the fee payer private key, if configured.
+    pub fn private_key(&self) -> Option<&Ed25519PrivateKey> {
+        self.fee_payer_private_key.as_ref()
+    }
+}
+
+impl ChainProviderOps for AptosChainProvider {
+    fn signer_addresses(&self) -> Vec<String> {
+        if let Some(address) = self.fee_payer_address {
+            vec![Address::new(address).to_string()]
+        } else {
+            vec![]
+        }
+    }
+
+    fn chain_id(&self) -> ChainId {
+        self.chain.into()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/types.rs
new file mode 100644
index 0000000..e2fd63d
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/chain/types.rs
@@ -0,0 +1,248 @@
+use move_core_types::account_address::AccountAddress;
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::fmt::{Debug, Display, Formatter};
+use std::str::FromStr;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+
+/// The CAIP-2 namespace for Aptos chains.
+pub const APTOS_NAMESPACE: &str = "aptos";
+
+/// An Aptos chain reference - the numeric chain ID.
+///
+/// Aptos uses simple numeric chain IDs:
+/// - `1` for mainnet
+/// - `2` for testnet
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_aptos::chain::AptosChainReference;
+/// use x402_types::chain::ChainId;
+///
+/// let mainnet = AptosChainReference::mainnet();
+/// let chain_id: ChainId = mainnet.into();
+/// assert_eq!(chain_id.to_string(), "aptos:1");
+/// ```
+#[derive(Clone, Copy, PartialEq, Eq, Hash)]
+pub struct AptosChainReference(u8);
+
+impl AptosChainReference {
+    /// Creates a new Aptos chain reference from a numeric chain ID.
+    pub fn new(chain_id: u8) -> Self {
+        Self(chain_id)
+    }
+
+    /// Returns the numeric chain ID.
+    pub fn chain_id(&self) -> u8 {
+        self.0
+    }
+
+    /// Returns the mainnet chain reference (chain ID 1).
+    pub fn mainnet() -> Self {
+        Self(1)
+    }
+
+    /// Returns the testnet chain reference (chain ID 2).
+    pub fn testnet() -> Self {
+        Self(2)
+    }
+
+    /// Alias for mainnet for compatibility with [`KnownNetworkAptos`](crate::KnownNetworkAptos) trait.
+    pub fn aptos() -> Self {
+        Self::mainnet()
+    }
+
+    /// Alias for testnet for compatibility with [`KnownNetworkAptos`](crate::KnownNetworkAptos) trait.
+    pub fn aptos_testnet() -> Self {
+        Self::testnet()
+    }
+}
+
+impl Debug for AptosChainReference {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "AptosChainReference({})", self.0)
+    }
+}
+
+impl Display for AptosChainReference {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl FromStr for AptosChainReference {
+    type Err = AptosChainReferenceFormatError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let chain_id = s
+            .parse::<u8>()
+            .map_err(|_| AptosChainReferenceFormatError::InvalidReference(s.to_string()))?;
+        if chain_id != 1 && chain_id != 2 {
+            return Err(AptosChainReferenceFormatError::InvalidReference(format!(
+                "Invalid Aptos chain ID: {}",
+                chain_id
+            )));
+        }
+        Ok(Self(chain_id))
+    }
+}
+
+impl Serialize for AptosChainReference {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.0.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for AptosChainReference {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        s.parse().map_err(serde::de::Error::custom)
+    }
+}
+
+impl From<AptosChainReference> for ChainId {
+    fn from(value: AptosChainReference) -> Self {
+        ChainId::new(APTOS_NAMESPACE, value.0.to_string())
+    }
+}
+
+impl TryFrom<ChainId> for AptosChainReference {
+    type Error = AptosChainReferenceFormatError;
+
+    fn try_from(value: ChainId) -> Result<Self, Self::Error> {
+        if value.namespace != APTOS_NAMESPACE {
+            return Err(AptosChainReferenceFormatError::InvalidNamespace(
+                value.namespace,
+            ));
+        }
+        Self::from_str(&value.reference)
+    }
+}
+
+/// Error type for parsing Aptos chain references.
+#[derive(Debug, thiserror::Error)]
+pub enum AptosChainReferenceFormatError {
+    /// The namespace was not "aptos".
+    #[error("Invalid namespace {0}, expected aptos")]
+    InvalidNamespace(String),
+    /// The reference was not a valid Aptos chain ID (1 or 2).
+    #[error("Invalid aptos chain reference {0}")]
+    InvalidReference(String),
+}
+
+/// An Aptos account address.
+///
+/// This is a wrapper around [`AccountAddress`] that provides serialization
+/// as a hex-encoded string with `0x` prefix, suitable for use in x402 protocol messages.
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_aptos::chain::Address;
+/// use std::str::FromStr;
+///
+/// let addr = Address::from_str("0x1").unwrap();
+/// assert_eq!(addr.to_string(), "0x1");
+/// ```
+#[derive(Clone, Debug, Hash, PartialEq, Eq)]
+pub struct Address(AccountAddress);
+
+impl Address {
+    /// Creates a new address from an [`AccountAddress`].
+    pub fn new(address: AccountAddress) -> Self {
+        Self(address)
+    }
+
+    /// Returns a reference to the inner [`AccountAddress`].
+    pub fn inner(&self) -> &AccountAddress {
+        &self.0
+    }
+}
+
+impl From<AccountAddress> for Address {
+    fn from(address: AccountAddress) -> Self {
+        Self(address)
+    }
+}
+
+impl From<Address> for AccountAddress {
+    fn from(address: Address) -> Self {
+        address.0
+    }
+}
+
+impl Display for Address {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl FromStr for Address {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let address =
+            AccountAddress::from_str(s).map_err(|e| format!("Invalid Aptos address: {}", e))?;
+        Ok(Self(address))
+    }
+}
+
+impl Serialize for Address {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.0.to_hex_literal())
+    }
+}
+
+impl<'de> Deserialize<'de> for Address {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        s.parse().map_err(serde::de::Error::custom)
+    }
+}
+
+/// Token deployment information for Aptos.
+///
+/// Contains the chain reference, token address, and decimals for a token deployed
+/// on an Aptos network.
+#[derive(Clone, Debug, Eq, PartialEq, Hash)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct AptosTokenDeployment {
+    /// The Aptos network where this token is deployed.
+    pub chain_reference: AptosChainReference,
+    /// The fungible asset address.
+    pub address: Address,
+    /// The number of decimal places for this token.
+    pub decimals: u8,
+}
+
+impl AptosTokenDeployment {
+    /// Creates a new token deployment.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn new(chain_reference: AptosChainReference, address: Address, decimals: u8) -> Self {
+        Self {
+            chain_reference,
+            address,
+            decimals,
+        }
+    }
+
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn amount(&self, v: u64) -> DeployedTokenAmount<u64, AptosTokenDeployment> {
+        DeployedTokenAmount {
+            amount: v,
+            token: self.clone(),
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/lib.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/lib.rs
new file mode 100644
index 0000000..34ad8df
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/lib.rs
@@ -0,0 +1,59 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Aptos chain support for the x402 payment protocol.
+//!
+//! This crate provides implementations of the x402 payment protocol for the Aptos blockchain.
+//! It currently supports the V2 protocol with the "exact" payment scheme based on fungible
+//! asset transfers with sponsored (gasless) transactions.
+//!
+//! # Features
+//!
+//! - **V2 Protocol Support**: Implements V2 protocol with CAIP-2 chain ID addressing
+//! - **Fungible Asset Payments**: Token transfers using `0x1::primary_fungible_store::transfer`
+//! - **Sponsored Transactions**: Facilitator pays gas fees for user transactions
+//! - **Transaction Simulation**: Pre-flight validation before settlement
+//! - **Balance Verification**: On-chain balance checks before settlement
+//!
+//! # Architecture
+//!
+//! The crate is organized into several modules:
+//!
+//! - [`chain`] - Core Aptos chain types, providers, and configuration
+//! - [`v2_aptos_exact`] - V2 protocol implementation with CAIP-2 chain IDs
+//!
+//! # Feature Flags
+//!
+//! - `facilitator` - Facilitator-side payment verification and settlement
+//! - `telemetry` - OpenTelemetry tracing support
+//!
+//! # Usage Examples
+//!
+//! ## Facilitator: Verifying and Settling
+//!
+//! ```ignore
+//! use x402_chain_aptos::{V2AptosExact, AptosChainProvider};
+//! use x402_types::scheme::X402SchemeFacilitatorBuilder;
+//!
+//! let provider = AptosChainProvider::from_config(&config).await?;
+//! let facilitator = V2AptosExact.build(provider, None)?;
+//!
+//! // Verify payment
+//! let verify_response = facilitator.verify(&verify_request).await?;
+//!
+//! // Settle payment
+//! let settle_response = facilitator.settle(&settle_request).await?;
+//! ```
+//!
+//! # Sponsored Transactions
+//!
+//! Aptos payments use sponsored transactions where the facilitator acts as the fee payer.
+//! The client creates and signs a transaction, and the facilitator adds its signature
+//! as the sponsor before submitting it on-chain.
+
+pub mod chain;
+pub mod v2_aptos_exact;
+
+mod networks;
+pub use networks::*;
+
+pub use v2_aptos_exact::V2AptosExact;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/networks.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/networks.rs
new file mode 100644
index 0000000..284a27c
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/networks.rs
@@ -0,0 +1,78 @@
+use x402_types::chain::ChainId;
+use x402_types::networks::USDC;
+
+use crate::chain::{Address, AptosChainReference, AptosTokenDeployment};
+
+/// Trait providing convenient methods to get instances for well-known Aptos networks.
+///
+/// This trait can be implemented for any type to provide static methods that create
+/// instances for well-known Aptos blockchain networks. Each method returns `Self`, allowing
+/// the trait to be used with different types that need per-network configuration.
+///
+/// # Use Cases
+///
+/// - **ChainId**: Get CAIP-2 chain identifiers for Aptos networks
+/// - **Token Deployments**: Get per-chain token addresses (e.g., USDC on different Aptos networks)
+/// - **Network Configuration**: Get network-specific configuration objects for Aptos chains
+/// - **Any Per-Network Data**: Any type that needs Aptos network-specific instances
+///
+/// # Examples
+///
+/// ```ignore
+/// use x402_rs::chain::ChainId;
+/// use x402_rs::known::KnownNetworkAptos;
+///
+/// // Get Aptos mainnet chain ID
+/// let aptos = ChainId::aptos();
+/// assert_eq!(aptos.namespace, "aptos");
+/// assert_eq!(aptos.reference, "1");
+///
+/// // Get Aptos testnet chain ID
+/// let testnet = ChainId::aptos_testnet();
+/// assert_eq!(testnet.namespace, "aptos");
+/// assert_eq!(testnet.reference, "2");
+/// ```
+#[allow(dead_code)]
+pub trait KnownNetworkAptos<A> {
+    /// Returns the instance for Aptos mainnet (aptos:1)
+    fn aptos() -> A;
+    /// Returns the instance for Aptos testnet (aptos:2)
+    fn aptos_testnet() -> A;
+}
+
+/// Implementation of KnownNetworkAptos for ChainId.
+///
+/// Provides convenient static methods to create ChainId instances for well-known
+/// Aptos blockchain networks. Each method returns a properly configured ChainId with the
+/// "aptos" namespace and the correct chain reference.
+///
+/// This is one example of implementing the KnownNetworkAptos trait. Other types
+/// (such as token address types) can also implement this trait to provide
+/// per-network instances with better developer experience.
+impl KnownNetworkAptos<ChainId> for ChainId {
+    fn aptos() -> ChainId {
+        AptosChainReference::aptos().into()
+    }
+
+    fn aptos_testnet() -> ChainId {
+        AptosChainReference::aptos_testnet().into()
+    }
+}
+
+impl KnownNetworkAptos<AptosTokenDeployment> for USDC {
+    fn aptos() -> AptosTokenDeployment {
+        // USDC on Aptos mainnet (fungible asset metadata address)
+        let address: Address = "0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b"
+            .parse()
+            .expect("Invalid USDC address");
+        AptosTokenDeployment::new(AptosChainReference::aptos(), address, 6)
+    }
+
+    fn aptos_testnet() -> AptosTokenDeployment {
+        // USDC on Aptos testnet (this is a placeholder address, actual testnet USDC may differ)
+        let address: Address = "0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b"
+            .parse()
+            .expect("Invalid USDC address");
+        AptosTokenDeployment::new(AptosChainReference::aptos_testnet(), address, 6)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/facilitator.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/facilitator.rs
new file mode 100644
index 0000000..a7b6a2e
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/facilitator.rs
@@ -0,0 +1,387 @@
+use aptos_types::transaction::authenticator::AccountAuthenticator;
+use aptos_types::transaction::{EntryFunction, RawTransaction, SignedTransaction};
+use move_core_types::account_address::AccountAddress;
+use move_core_types::identifier::Identifier;
+use move_core_types::language_storage::ModuleId;
+use std::collections::HashMap;
+use std::sync::Arc;
+use x402_types::chain::ChainProviderOps;
+use x402_types::proto;
+use x402_types::proto::{PaymentVerificationError, v2};
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorBuilder, X402SchemeFacilitatorError,
+};
+use x402_types::util::Base64Bytes;
+
+use crate::V2AptosExact;
+use crate::chain::AptosChainProvider;
+use crate::v2_aptos_exact::types;
+use crate::v2_aptos_exact::types::ExactScheme;
+
+pub struct V2AptosExactFacilitator {
+    provider: Arc<AptosChainProvider>,
+}
+
+impl X402SchemeFacilitatorBuilder<Arc<AptosChainProvider>> for V2AptosExact {
+    fn build(
+        &self,
+        provider: Arc<AptosChainProvider>,
+        _config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        Ok(Box::new(V2AptosExactFacilitator { provider }))
+    }
+}
+
+#[async_trait::async_trait]
+impl X402SchemeFacilitator for V2AptosExactFacilitator {
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError> {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request).await?;
+        Ok(v2::VerifyResponse::valid(verification.payer.to_string()).into())
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError> {
+        let request = types::SettleRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request).await?;
+        let payer = verification.payer.to_string();
+        let tx_hash = settle_transaction(&self.provider, verification).await?;
+        Ok(v2::SettleResponse::Success {
+            payer,
+            transaction: format!("0x{}", hex::encode(tx_hash)),
+            network: self.provider.chain_id().to_string(),
+        }
+        .into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+
+        // Include extra.sponsored if the facilitator is configured to sponsor gas
+        let extra = if self.provider.sponsor_gas() {
+            Some(serde_json::json!({ "sponsored": true }))
+        } else {
+            None
+        };
+
+        let kinds: Vec<proto::SupportedPaymentKind> = vec![proto::SupportedPaymentKind {
+            x402_version: proto::v2::X402Version2.into(),
+            scheme: ExactScheme.to_string(),
+            network: chain_id.to_string(),
+            extra,
+        }];
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+/// Result of verifying an Aptos transfer
+pub struct VerifyTransferResult {
+    pub payer: AccountAddress,
+    pub raw_transaction: RawTransaction,
+    pub authenticator_bytes: Vec<u8>,
+}
+
+/// Verify an Aptos transfer request
+pub async fn verify_transfer(
+    provider: &AptosChainProvider,
+    request: &types::VerifyRequest,
+) -> Result<VerifyTransferResult, PaymentVerificationError> {
+    let payload = &request.payment_payload;
+    let requirements = &request.payment_requirements;
+
+    // Validate accepted == requirements
+    let accepted = &payload.accepted;
+    if accepted != requirements {
+        return Err(PaymentVerificationError::AcceptedRequirementsMismatch);
+    }
+
+    // Validate chain ID
+    let chain_id = provider.chain_id();
+    let payload_chain_id = &accepted.network;
+    if payload_chain_id != &chain_id {
+        return Err(PaymentVerificationError::UnsupportedChain);
+    }
+
+    // Deserialize transaction
+    let transaction_b64 = &payload.payload.transaction;
+    let (raw_transaction, authenticator_bytes, entry_function) =
+        deserialize_aptos_transaction(transaction_b64)?;
+
+    // Extract sender (payer)
+    let payer = raw_transaction.sender();
+
+    // Validate entry function is primary_fungible_store::transfer
+    let expected_module = ModuleId::new(
+        AccountAddress::ONE,
+        Identifier::new("primary_fungible_store").map_err(|e| {
+            PaymentVerificationError::InvalidFormat(format!("Invalid module identifier: {}", e))
+        })?,
+    );
+    let expected_function = Identifier::new("transfer").map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("Invalid function identifier: {}", e))
+    })?;
+
+    if entry_function.module() != &expected_module {
+        return Err(PaymentVerificationError::InvalidFormat(format!(
+            "Invalid module: expected {}, got {}",
+            expected_module,
+            entry_function.module()
+        )));
+    }
+
+    if *entry_function.function() != *expected_function {
+        return Err(PaymentVerificationError::InvalidFormat(format!(
+            "Invalid function: expected {}, got {}",
+            expected_function,
+            entry_function.function()
+        )));
+    }
+
+    // Validate function arguments (asset, recipient, amount)
+    // primary_fungible_store::transfer has 3 arguments:
+    // 1. asset: Object<Metadata> - the fungible asset metadata address
+    // 2. to: address - the recipient address
+    // 3. amount: u64 - the transfer amount
+    let args = entry_function.args();
+    if args.len() != 3 {
+        return Err(PaymentVerificationError::InvalidFormat(format!(
+            "Expected 3 arguments for transfer, got {}",
+            args.len()
+        )));
+    }
+
+    // Parse asset address from first argument (BCS-encoded address)
+    let asset_address: AccountAddress = bcs::from_bytes(&args[0]).map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("Failed to parse asset address: {}", e))
+    })?;
+    let expected_asset = requirements.asset.inner();
+    if &asset_address != expected_asset {
+        return Err(PaymentVerificationError::AssetMismatch);
+    }
+
+    // Parse recipient address from second argument (BCS-encoded address)
+    let recipient_address: AccountAddress = bcs::from_bytes(&args[1]).map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("Failed to parse recipient address: {}", e))
+    })?;
+    let expected_recipient = requirements.pay_to.inner();
+    if &recipient_address != expected_recipient {
+        return Err(PaymentVerificationError::RecipientMismatch);
+    }
+
+    // Parse amount from third argument (BCS-encoded u64)
+    let amount: u64 = bcs::from_bytes(&args[2]).map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("Failed to parse amount: {}", e))
+    })?;
+    let expected_amount: u64 = requirements.amount.parse().map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("Failed to parse expected amount: {}", e))
+    })?;
+    if amount != expected_amount {
+        return Err(PaymentVerificationError::InvalidPaymentAmount);
+    }
+
+    Ok(VerifyTransferResult {
+        payer,
+        raw_transaction,
+        authenticator_bytes,
+    })
+}
+
+/// Settle the transaction by submitting it to the network
+pub async fn settle_transaction(
+    provider: &AptosChainProvider,
+    verification: VerifyTransferResult,
+) -> Result<[u8; 32], PaymentVerificationError> {
+    use aptos_crypto::SigningKey;
+    use aptos_crypto::ed25519::Ed25519PublicKey;
+    use aptos_types::transaction::RawTransactionWithData;
+
+    // Deserialize sender's authenticator
+    let sender_authenticator: AccountAuthenticator =
+        bcs::from_bytes(&verification.authenticator_bytes).map_err(|e| {
+            PaymentVerificationError::InvalidFormat(format!(
+                "Failed to deserialize authenticator: {}",
+                e
+            ))
+        })?;
+
+    let signed_txn = if provider.sponsor_gas() {
+        // Sponsored transaction: facilitator signs as fee payer
+        let fee_payer_address = provider.account_address().ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat(
+                "Fee payer address not configured for sponsored transaction".to_string(),
+            )
+        })?;
+        let fee_payer_private_key = provider.private_key().ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat(
+                "Fee payer private key not configured for sponsored transaction".to_string(),
+            )
+        })?;
+        let fee_payer_public_key: Ed25519PublicKey = fee_payer_private_key.into();
+
+        // Create the message that the fee payer needs to sign
+        let fee_payer_message = RawTransactionWithData::new_fee_payer(
+            verification.raw_transaction.clone(),
+            vec![], // No secondary signers
+            fee_payer_address,
+        );
+
+        // Sign as fee payer
+        let fee_payer_signature = fee_payer_private_key
+            .sign(&fee_payer_message)
+            .map_err(|e| {
+                PaymentVerificationError::InvalidSignature(format!(
+                    "Failed to sign as fee payer: {}",
+                    e
+                ))
+            })?;
+
+        let fee_payer_authenticator =
+            AccountAuthenticator::ed25519(fee_payer_public_key.clone(), fee_payer_signature);
+
+        // Create fee payer signed transaction
+        SignedTransaction::new_fee_payer(
+            verification.raw_transaction.clone(),
+            sender_authenticator,
+            vec![], // No secondary signer addresses
+            vec![], // No secondary signers
+            fee_payer_address,
+            fee_payer_authenticator,
+        )
+    } else {
+        // Non-sponsored transaction: client pays own gas, just submit their fully-signed transaction
+        // Extract public key and signature from the sender's authenticator
+        let (public_key, signature) = match sender_authenticator {
+            AccountAuthenticator::Ed25519 {
+                public_key,
+                signature,
+            } => (public_key, signature),
+            _ => {
+                return Err(PaymentVerificationError::InvalidFormat(
+                    "Only Ed25519 signatures are supported for non-sponsored transactions"
+                        .to_string(),
+                ));
+            }
+        };
+
+        SignedTransaction::new(verification.raw_transaction.clone(), public_key, signature)
+    };
+
+    // Compute transaction hash after signing
+    let tx_hash = signed_txn.committed_hash();
+    let tx_hash_bytes: [u8; 32] = tx_hash.to_vec().try_into().map_err(|_| {
+        PaymentVerificationError::InvalidFormat("Invalid transaction hash".to_string())
+    })?;
+
+    // Submit transaction
+    provider
+        .rest_client()
+        .submit_bcs(&signed_txn)
+        .await
+        .map_err(|e| {
+            PaymentVerificationError::TransactionSimulation(format!(
+                "Transaction submission failed: {}",
+                e
+            ))
+        })?;
+
+    Ok(tx_hash_bytes)
+}
+
+/// Deserialize Aptos transaction from base64-encoded JSON
+fn deserialize_aptos_transaction(
+    transaction_b64: &str,
+) -> Result<(RawTransaction, Vec<u8>, EntryFunction), PaymentVerificationError> {
+    // Base64 decode
+    let json_bytes = Base64Bytes::from(transaction_b64.as_bytes())
+        .decode()
+        .map_err(|e| {
+            PaymentVerificationError::InvalidFormat(format!("Base64 decode failed: {}", e))
+        })?;
+
+    // Parse JSON
+    let json_payload: serde_json::Value = serde_json::from_slice(&json_bytes).map_err(|e| {
+        PaymentVerificationError::InvalidFormat(format!("JSON parse failed: {}", e))
+    })?;
+
+    // Extract transaction and authenticator byte arrays
+    let transaction_bytes = json_payload
+        .get("transaction")
+        .and_then(|v| v.as_array())
+        .ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat("Missing transaction field".to_string())
+        })?
+        .iter()
+        .map(|v| v.as_u64().unwrap_or(0) as u8)
+        .collect::<Vec<u8>>();
+
+    let authenticator_bytes = json_payload
+        .get("senderAuthenticator")
+        .and_then(|v| v.as_array())
+        .ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat("Missing senderAuthenticator field".to_string())
+        })?
+        .iter()
+        .map(|v| v.as_u64().unwrap_or(0) as u8)
+        .collect::<Vec<u8>>();
+
+    // Deserialize RawTransaction from BCS
+    // The transaction bytes are a SimpleTransaction which contains RawTransaction + optional fee payer
+    // For fee payer transactions, we need to extract just the RawTransaction
+    let raw_transaction: RawTransaction = if transaction_bytes.len() > 33 {
+        // Check if this might be a fee payer transaction (has Some variant at end)
+        let maybe_option_tag = transaction_bytes[transaction_bytes.len() - 33];
+        if maybe_option_tag == 1 {
+            // Fee payer transaction - extract raw transaction (everything except last 33 bytes)
+            let raw_tx_bytes = &transaction_bytes[..transaction_bytes.len() - 33];
+            bcs::from_bytes(raw_tx_bytes).map_err(|e| {
+                PaymentVerificationError::InvalidFormat(format!(
+                    "Failed to deserialize RawTransaction: {}",
+                    e
+                ))
+            })?
+        } else {
+            bcs::from_bytes(&transaction_bytes).map_err(|e| {
+                PaymentVerificationError::InvalidFormat(format!(
+                    "Failed to deserialize RawTransaction: {}",
+                    e
+                ))
+            })?
+        }
+    } else {
+        bcs::from_bytes(&transaction_bytes).map_err(|e| {
+            PaymentVerificationError::InvalidFormat(format!(
+                "Failed to deserialize RawTransaction: {}",
+                e
+            ))
+        })?
+    };
+
+    // Clone raw_transaction before consuming it with into_payload
+    let raw_transaction_clone = raw_transaction.clone();
+
+    // Extract entry function from payload (consumes raw_transaction)
+    let entry_function = match raw_transaction.into_payload() {
+        aptos_types::transaction::TransactionPayload::EntryFunction(ef) => ef,
+        _ => {
+            return Err(PaymentVerificationError::InvalidFormat(
+                "Expected EntryFunction payload".to_string(),
+            ));
+        }
+    };
+
+    Ok((raw_transaction_clone, authenticator_bytes, entry_function))
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/mod.rs
new file mode 100644
index 0000000..59feffd
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/mod.rs
@@ -0,0 +1,47 @@
+//! V2 Aptos "exact" payment scheme implementation.
+//!
+//! This module implements the "exact" payment scheme for Aptos using
+//! the V2 x402 protocol. It uses CAIP-2 chain identifiers (aptos:1, aptos:2).
+//!
+//! # Features
+//!
+//! - Fungible asset transfers using `0x1::primary_fungible_store::transfer`
+//! - Sponsored (gasless) transactions where the facilitator pays gas fees
+//! - Transaction simulation before settlement
+//! - BCS-encoded transaction validation
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_aptos::v2_aptos_exact::V2AptosExact;
+//! use x402_chain_aptos::networks::{KnownNetworkAptos, USDC};
+//!
+//! // Create a price tag for 1 USDC on Aptos mainnet
+//! let usdc = USDC::aptos();
+//! let price = V2AptosExact::price_tag(
+//!     "0x1234...",  // pay_to address
+//!     usdc.amount(1_000_000),  // 1 USDC
+//! );
+//! ```
+
+#[cfg(feature = "facilitator")]
+pub mod facilitator;
+#[cfg(feature = "facilitator")]
+pub use facilitator::*;
+
+pub mod types;
+pub use types::*;
+
+use x402_types::scheme::X402SchemeId;
+
+pub struct V2AptosExact;
+
+impl X402SchemeId for V2AptosExact {
+    fn namespace(&self) -> &str {
+        "aptos"
+    }
+
+    fn scheme(&self) -> &str {
+        ExactScheme.as_ref()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/types.rs
new file mode 100644
index 0000000..4956180
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-aptos/src/v2_aptos_exact/types.rs
@@ -0,0 +1,40 @@
+//! V2 Aptos "exact" payment scheme types.
+
+use serde::{Deserialize, Serialize};
+use x402_types::lit_str;
+use x402_types::proto::v2;
+
+use crate::chain::Address;
+
+lit_str!(ExactScheme, "exact");
+
+/// The V2 Aptos exact scheme verify request.
+pub type VerifyRequest = v2::VerifyRequest<PaymentPayload, PaymentRequirements>;
+
+/// The V2 Aptos exact scheme settle request.
+pub type SettleRequest = VerifyRequest;
+
+/// The payment payload for Aptos exact scheme.
+pub type PaymentPayload = v2::PaymentPayload<PaymentRequirements, ExactAptosPayload>;
+
+/// The payment requirements for Aptos exact scheme.
+pub type PaymentRequirements =
+    v2::PaymentRequirements<ExactScheme, String, Address, SupportedPaymentKindExtra>;
+
+/// The transaction payload containing the base64-encoded BCS transaction.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ExactAptosPayload {
+    /// Base64-encoded JSON containing the BCS transaction and authenticator.
+    pub transaction: String,
+}
+
+/// Extra requirements for sponsored transactions.
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+#[serde(rename_all = "camelCase")]
+pub struct SupportedPaymentKindExtra {
+    /// The address of the fee payer (facilitator).
+    pub fee_payer: Address,
+    /// Whether this is a sponsored (gasless) transaction.
+    pub sponsored: bool,
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/Cargo.toml b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/Cargo.toml
new file mode 100644
index 0000000..432e5f8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/Cargo.toml
@@ -0,0 +1,68 @@
+[package]
+name = "x402-chain-eip155"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+keywords.workspace = true
+categories.workspace = true
+description = "EIP-155 (EVM) chain support for the x402 payment protocol"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[features]
+default = []
+telemetry = ["tracing", "tracing-core", "x402-types/telemetry"]
+client = ["alloy-signer", "alloy-signer-local", "rand", "async-trait"]
+server = []
+facilitator = [
+  "alloy-signer",
+  "alloy-signer-local",
+  "alloy-provider",
+  "alloy-network",
+  "alloy-rpc-client",
+  "alloy-rpc-types-eth",
+  "alloy-transport",
+  "alloy-transport-http",
+  "alloy-contract",
+  "dashmap",
+  "tokio",
+  "tower",
+  "async-trait",
+  "url"
+]
+full = ["telemetry", "client", "server", "facilitator"]
+
+[dependencies]
+x402-types = { workspace = true }
+serde = { workspace = true }
+async-trait = { workspace = true, optional = true }
+tokio = { workspace = true, optional = true }
+tower = { workspace = true, optional = true }
+thiserror = { workspace = true }
+serde_json = { workspace = true }
+
+dashmap = { version = "6.1.0", optional = true }
+rand = { version = "0.9.2", optional = true }
+url = { workspace = true, optional = true }
+
+# Alloy
+alloy-primitives = { version = "1.4" }
+alloy-provider = { version = "1.4", optional = true }
+alloy-network = { version = "1.4", optional = true }
+alloy-rpc-client = { version = "1.4", optional = true }
+alloy-rpc-types-eth = { version = "1.4", optional = true }
+alloy-transport = { version = "1.4", features = ["throttle"], optional = true }
+alloy-transport-http = { version = "1.4", optional = true }
+alloy-signer = { version = "1.4", optional = true }
+alloy-signer-local = { version = "1.4", optional = true }
+alloy-contract = { version = "1.4", optional = true }
+alloy-sol-types = { version = "1.4", features = ["json"] }
+
+tracing = { workspace = true, optional = true }
+tracing-core = { workspace = true, optional = true }
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/README.md b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/README.md
new file mode 100644
index 0000000..cabeed6
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/README.md
@@ -0,0 +1,150 @@
+# x402-chain-eip155
+
+[![Crates.io](https://img.shields.io/crates/v/x402-chain-eip155.svg)](https://crates.io/crates/x402-chain-eip155)
+[![Docs.rs](https://docs.rs/x402-chain-eip155/badge.svg)](https://docs.rs/x402-chain-eip155)
+
+EIP-155 (EVM) chain support for the [x402](https://www.x402.org) payment protocol.
+
+This crate provides implementations of the [x402](https://www.x402.org) payment protocol for EVM-compatible blockchains using the EIP-155 chain
+ID standard. It supports both V1 and V2 protocol versions with the "exact" payment scheme based on ERC-3009
+`transferWithAuthorization`.
+
+## Features
+
+- **V1 and V2 Protocol Support**: Implements both protocol versions with network name (V1) and CAIP-2 chain ID (V2)
+  addressing
+- **ERC-3009 Payments**: Gasless token transfers using `transferWithAuthorization`
+- **Smart Wallet Support**:
+  - EIP-1271 for deployed smart wallets
+  - EIP-6492 for counterfactual (not-yet-deployed) smart wallets
+  - EOA (Externally Owned Account) signatures
+- **Multiple Signers**: Round-robin signer selection for load distribution
+- **Nonce Management**: Automatic nonce tracking with pending transaction awareness
+- **Gas Management**: Automatic gas estimation with EIP-1559 and legacy support
+
+## Architecture
+
+The crate is organized into several modules:
+
+- **`chain`** - Core EVM chain types, providers, and configuration
+- **`v1_eip155_exact`** - V1 protocol implementation with network names
+- **`v2_eip155_exact`** - V2 protocol implementation with CAIP-2 chain IDs
+
+## Feature Flags
+
+- `server` - Server-side price tag generation
+- `client` - Client-side payment signing
+- `facilitator` - Facilitator-side payment verification and settlement
+- `telemetry` - OpenTelemetry tracing support
+
+## Usage
+
+### Server: Creating a Price Tag
+
+```rust
+use x402_chain_eip155::{V1Eip155Exact, KnownNetworkEip155};
+use x402_types::networks::USDC;
+
+// Get USDC deployment on Base
+let usdc = USDC::base();
+
+// Create a price tag for 1 USDC
+let price_tag = V1Eip155Exact::price_tag(
+"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
+usdc.amount(1_000_000u64),
+);
+```
+
+### Client: Signing a Payment
+
+```rust
+use x402_chain_eip155::V1Eip155ExactClient;
+use alloy_signer_local::PrivateKeySigner;
+
+let signer = PrivateKeySigner::random();
+let client = V1Eip155ExactClient::new(signer);
+
+// Use client to sign payment candidates
+let candidates = client.accept( & payment_required);
+```
+
+### Facilitator: Verifying and Settling
+
+```rust
+use x402_chain_eip155::{V1Eip155Exact, Eip155ChainProvider};
+use x402_types::scheme::X402SchemeFacilitatorBuilder;
+
+let provider = Eip155ChainProvider::from_config( & config).await?;
+let facilitator = V1Eip155Exact.build(provider, None) ?;
+
+// Verify payment
+let verify_response = facilitator.verify( & verify_request).await?;
+
+// Settle payment
+let settle_response = facilitator.settle( & settle_request).await?;
+```
+
+## Supported Networks
+
+The crate includes built-in support for many EVM networks through the `KnownNetworkEip155` trait:
+
+- **Base** (mainnet and Sepolia testnet)
+- **Polygon** (mainnet and Amoy testnet)
+- **Avalanche** (C-Chain and Fuji testnet)
+- **Sei** (mainnet and testnet)
+- **XDC Network**
+- **XRPL EVM**
+- **Peaq**
+- **IoTeX**
+- **Celo** (mainnet and Sepolia testnet)
+
+Each network includes USDC token deployment information with proper EIP-712 domain parameters.
+
+## ERC-3009 and Signature Handling
+
+The facilitator intelligently dispatches to different `transferWithAuthorization` contract functions or other onchain functions based on the
+signature format:
+
+- **EOA signatures (64-65 bytes)**: Parsed as (r, s, v) components and dispatched to the standard EIP-3009 function
+- **EIP-1271 signatures**: Passed as full signature bytes for contract wallet verification
+- **EIP-6492 signatures**: Detected by the 32-byte magic suffix and validated via the universal EIP-6492 validator
+  contract
+
+For EIP-6492 counterfactual signatures, the facilitator can deploy the smart wallet on-chain if needed before settling
+the payment.
+
+## Configuration
+
+### Facilitator Configuration Example
+
+```json
+{
+  "eip155:8453": {
+    "eip1559": true,
+    "flashblocks": false,
+    "receipt_timeout_secs": 30,
+    "signers": [
+      "$FACILITATOR_PRIVATE_KEY"
+    ],
+    "rpc": [
+      {
+        "http": "https://mainnet.base.org",
+        "rate_limit": 100
+      }
+    ]
+  }
+}
+```
+
+## Dependencies
+
+This crate uses the [Alloy](https://github.com/alloy-rs/alloy) library for Ethereum interactions, providing:
+
+- Type-safe contract bindings
+- EIP-712 typed data signing
+- Transaction building and signing
+- RPC provider with fallback and rate limiting
+
+## License
+
+Apache 2.0
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IEIP3009.json b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IEIP3009.json
new file mode 100644
index 0000000..6c53798
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IEIP3009.json
@@ -0,0 +1,1388 @@
+[
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "owner",
+        "type": "address"
+      },
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      }
+    ],
+    "name": "Approval",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "authorizer",
+        "type": "address"
+      },
+      {
+        "indexed": true,
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      }
+    ],
+    "name": "AuthorizationCanceled",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "authorizer",
+        "type": "address"
+      },
+      {
+        "indexed": true,
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      }
+    ],
+    "name": "AuthorizationUsed",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "_account",
+        "type": "address"
+      }
+    ],
+    "name": "Blacklisted",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "newBlacklister",
+        "type": "address"
+      }
+    ],
+    "name": "BlacklisterChanged",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "burner",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "uint256",
+        "name": "amount",
+        "type": "uint256"
+      }
+    ],
+    "name": "Burn",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "newMasterMinter",
+        "type": "address"
+      }
+    ],
+    "name": "MasterMinterChanged",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "minter",
+        "type": "address"
+      },
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "uint256",
+        "name": "amount",
+        "type": "uint256"
+      }
+    ],
+    "name": "Mint",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "minter",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "uint256",
+        "name": "minterAllowedAmount",
+        "type": "uint256"
+      }
+    ],
+    "name": "MinterConfigured",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "oldMinter",
+        "type": "address"
+      }
+    ],
+    "name": "MinterRemoved",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": false,
+        "internalType": "address",
+        "name": "previousOwner",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "address",
+        "name": "newOwner",
+        "type": "address"
+      }
+    ],
+    "name": "OwnershipTransferred",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [],
+    "name": "Pause",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "newAddress",
+        "type": "address"
+      }
+    ],
+    "name": "PauserChanged",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "newRescuer",
+        "type": "address"
+      }
+    ],
+    "name": "RescuerChanged",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      }
+    ],
+    "name": "Transfer",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": true,
+        "internalType": "address",
+        "name": "_account",
+        "type": "address"
+      }
+    ],
+    "name": "UnBlacklisted",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [],
+    "name": "Unpause",
+    "type": "event"
+  },
+  {
+    "inputs": [],
+    "name": "CANCEL_AUTHORIZATION_TYPEHASH",
+    "outputs": [
+      {
+        "internalType": "bytes32",
+        "name": "",
+        "type": "bytes32"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "DOMAIN_SEPARATOR",
+    "outputs": [
+      {
+        "internalType": "bytes32",
+        "name": "",
+        "type": "bytes32"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "PERMIT_TYPEHASH",
+    "outputs": [
+      {
+        "internalType": "bytes32",
+        "name": "",
+        "type": "bytes32"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "RECEIVE_WITH_AUTHORIZATION_TYPEHASH",
+    "outputs": [
+      {
+        "internalType": "bytes32",
+        "name": "",
+        "type": "bytes32"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "TRANSFER_WITH_AUTHORIZATION_TYPEHASH",
+    "outputs": [
+      {
+        "internalType": "bytes32",
+        "name": "",
+        "type": "bytes32"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "owner",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      }
+    ],
+    "name": "allowance",
+    "outputs": [
+      {
+        "internalType": "uint256",
+        "name": "",
+        "type": "uint256"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      }
+    ],
+    "name": "approve",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "authorizer",
+        "type": "address"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      }
+    ],
+    "name": "authorizationState",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "account",
+        "type": "address"
+      }
+    ],
+    "name": "balanceOf",
+    "outputs": [
+      {
+        "internalType": "uint256",
+        "name": "",
+        "type": "uint256"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_account",
+        "type": "address"
+      }
+    ],
+    "name": "blacklist",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "blacklister",
+    "outputs": [
+      {
+        "internalType": "address",
+        "name": "",
+        "type": "address"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "uint256",
+        "name": "_amount",
+        "type": "uint256"
+      }
+    ],
+    "name": "burn",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "authorizer",
+        "type": "address"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "uint8",
+        "name": "v",
+        "type": "uint8"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "r",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "s",
+        "type": "bytes32"
+      }
+    ],
+    "name": "cancelAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "authorizer",
+        "type": "address"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes",
+        "name": "signature",
+        "type": "bytes"
+      }
+    ],
+    "name": "cancelAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "minter",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "minterAllowedAmount",
+        "type": "uint256"
+      }
+    ],
+    "name": "configureMinter",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "currency",
+    "outputs": [
+      {
+        "internalType": "string",
+        "name": "",
+        "type": "string"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "decimals",
+    "outputs": [
+      {
+        "internalType": "uint8",
+        "name": "",
+        "type": "uint8"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "decrement",
+        "type": "uint256"
+      }
+    ],
+    "name": "decreaseAllowance",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "increment",
+        "type": "uint256"
+      }
+    ],
+    "name": "increaseAllowance",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "string",
+        "name": "tokenName",
+        "type": "string"
+      },
+      {
+        "internalType": "string",
+        "name": "tokenSymbol",
+        "type": "string"
+      },
+      {
+        "internalType": "string",
+        "name": "tokenCurrency",
+        "type": "string"
+      },
+      {
+        "internalType": "uint8",
+        "name": "tokenDecimals",
+        "type": "uint8"
+      },
+      {
+        "internalType": "address",
+        "name": "newMasterMinter",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "newPauser",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "newBlacklister",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "newOwner",
+        "type": "address"
+      }
+    ],
+    "name": "initialize",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "string",
+        "name": "newName",
+        "type": "string"
+      }
+    ],
+    "name": "initializeV2",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "lostAndFound",
+        "type": "address"
+      }
+    ],
+    "name": "initializeV2_1",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address[]",
+        "name": "accountsToBlacklist",
+        "type": "address[]"
+      },
+      {
+        "internalType": "string",
+        "name": "newSymbol",
+        "type": "string"
+      }
+    ],
+    "name": "initializeV2_2",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_account",
+        "type": "address"
+      }
+    ],
+    "name": "isBlacklisted",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "account",
+        "type": "address"
+      }
+    ],
+    "name": "isMinter",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "masterMinter",
+    "outputs": [
+      {
+        "internalType": "address",
+        "name": "",
+        "type": "address"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "_amount",
+        "type": "uint256"
+      }
+    ],
+    "name": "mint",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "minter",
+        "type": "address"
+      }
+    ],
+    "name": "minterAllowance",
+    "outputs": [
+      {
+        "internalType": "uint256",
+        "name": "",
+        "type": "uint256"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "name",
+    "outputs": [
+      {
+        "internalType": "string",
+        "name": "",
+        "type": "string"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "owner",
+        "type": "address"
+      }
+    ],
+    "name": "nonces",
+    "outputs": [
+      {
+        "internalType": "uint256",
+        "name": "",
+        "type": "uint256"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "owner",
+    "outputs": [
+      {
+        "internalType": "address",
+        "name": "",
+        "type": "address"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "pause",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "paused",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "pauser",
+    "outputs": [
+      {
+        "internalType": "address",
+        "name": "",
+        "type": "address"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "owner",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "deadline",
+        "type": "uint256"
+      },
+      {
+        "internalType": "bytes",
+        "name": "signature",
+        "type": "bytes"
+      }
+    ],
+    "name": "permit",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "owner",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "spender",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "deadline",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint8",
+        "name": "v",
+        "type": "uint8"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "r",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "s",
+        "type": "bytes32"
+      }
+    ],
+    "name": "permit",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validAfter",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validBefore",
+        "type": "uint256"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes",
+        "name": "signature",
+        "type": "bytes"
+      }
+    ],
+    "name": "receiveWithAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validAfter",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validBefore",
+        "type": "uint256"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "uint8",
+        "name": "v",
+        "type": "uint8"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "r",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "s",
+        "type": "bytes32"
+      }
+    ],
+    "name": "receiveWithAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "minter",
+        "type": "address"
+      }
+    ],
+    "name": "removeMinter",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "contract IERC20",
+        "name": "tokenContract",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "amount",
+        "type": "uint256"
+      }
+    ],
+    "name": "rescueERC20",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "rescuer",
+    "outputs": [
+      {
+        "internalType": "address",
+        "name": "",
+        "type": "address"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "symbol",
+    "outputs": [
+      {
+        "internalType": "string",
+        "name": "",
+        "type": "string"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "totalSupply",
+    "outputs": [
+      {
+        "internalType": "uint256",
+        "name": "",
+        "type": "uint256"
+      }
+    ],
+    "stateMutability": "view",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      }
+    ],
+    "name": "transfer",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      }
+    ],
+    "name": "transferFrom",
+    "outputs": [
+      {
+        "internalType": "bool",
+        "name": "",
+        "type": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "newOwner",
+        "type": "address"
+      }
+    ],
+    "name": "transferOwnership",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validAfter",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validBefore",
+        "type": "uint256"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes",
+        "name": "signature",
+        "type": "bytes"
+      }
+    ],
+    "name": "transferWithAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "from",
+        "type": "address"
+      },
+      {
+        "internalType": "address",
+        "name": "to",
+        "type": "address"
+      },
+      {
+        "internalType": "uint256",
+        "name": "value",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validAfter",
+        "type": "uint256"
+      },
+      {
+        "internalType": "uint256",
+        "name": "validBefore",
+        "type": "uint256"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "nonce",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "uint8",
+        "name": "v",
+        "type": "uint8"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "r",
+        "type": "bytes32"
+      },
+      {
+        "internalType": "bytes32",
+        "name": "s",
+        "type": "bytes32"
+      }
+    ],
+    "name": "transferWithAuthorization",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_account",
+        "type": "address"
+      }
+    ],
+    "name": "unBlacklist",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "unpause",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_newBlacklister",
+        "type": "address"
+      }
+    ],
+    "name": "updateBlacklister",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_newMasterMinter",
+        "type": "address"
+      }
+    ],
+    "name": "updateMasterMinter",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "_newPauser",
+        "type": "address"
+      }
+    ],
+    "name": "updatePauser",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [
+      {
+        "internalType": "address",
+        "name": "newRescuer",
+        "type": "address"
+      }
+    ],
+    "name": "updateRescuer",
+    "outputs": [],
+    "stateMutability": "nonpayable",
+    "type": "function"
+  },
+  {
+    "inputs": [],
+    "name": "version",
+    "outputs": [
+      {
+        "internalType": "string",
+        "name": "",
+        "type": "string"
+      }
+    ],
+    "stateMutability": "pure",
+    "type": "function"
+  }
+]
\ No newline at end of file
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IPermit2.json b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IPermit2.json
new file mode 100644
index 0000000..435ead8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/IPermit2.json
@@ -0,0 +1,131 @@
+[
+  {
+    "type": "function",
+    "name": "permit",
+    "inputs": [
+      {
+        "name": "owner",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "permitSingle",
+        "type": "tuple",
+        "internalType": "struct PermitSingle",
+        "components": [
+          {
+            "name": "details",
+            "type": "tuple",
+            "internalType": "struct PermitDetails",
+            "components": [
+              {
+                "name": "token",
+                "type": "address",
+                "internalType": "address"
+              },
+              {
+                "name": "amount",
+                "type": "uint160",
+                "internalType": "uint160"
+              },
+              {
+                "name": "expiration",
+                "type": "uint48",
+                "internalType": "uint48"
+              },
+              {
+                "name": "nonce",
+                "type": "uint48",
+                "internalType": "uint48"
+              }
+            ]
+          },
+          {
+            "name": "spender",
+            "type": "address",
+            "internalType": "address"
+          },
+          {
+            "name": "sigDeadline",
+            "type": "uint256",
+            "internalType": "uint256"
+          }
+        ]
+      },
+      {
+        "name": "signature",
+        "type": "bytes",
+        "internalType": "bytes"
+      }
+    ],
+    "outputs": [],
+    "stateMutability": "nonpayable"
+  },
+  {
+    "type": "function",
+    "name": "transferFrom",
+    "inputs": [
+      {
+        "name": "from",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "to",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "amount",
+        "type": "uint160",
+        "internalType": "uint160"
+      },
+      {
+        "name": "token",
+        "type": "address",
+        "internalType": "address"
+      }
+    ],
+    "outputs": [],
+    "stateMutability": "nonpayable"
+  },
+  {
+    "type": "function",
+    "name": "allowance",
+    "inputs": [
+      {
+        "name": "owner",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "token",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "spender",
+        "type": "address",
+        "internalType": "address"
+      }
+    ],
+    "outputs": [
+      {
+        "name": "amount",
+        "type": "uint160",
+        "internalType": "uint160"
+      },
+      {
+        "name": "expiration",
+        "type": "uint48",
+        "internalType": "uint48"
+      },
+      {
+        "name": "nonce",
+        "type": "uint48",
+        "internalType": "uint48"
+      }
+    ],
+    "stateMutability": "view"
+  }
+]
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/Validator6492.json b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/Validator6492.json
new file mode 100644
index 0000000..15fb046
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/abi/Validator6492.json
@@ -0,0 +1,82 @@
+[
+  {
+    "type": "function",
+    "name": "isValidSig",
+    "inputs": [
+      {
+        "name": "_signer",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "_hash",
+        "type": "bytes32",
+        "internalType": "bytes32"
+      },
+      {
+        "name": "_signature",
+        "type": "bytes",
+        "internalType": "bytes"
+      }
+    ],
+    "outputs": [
+      {
+        "name": "",
+        "type": "bool",
+        "internalType": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable"
+  },
+  {
+    "type": "function",
+    "name": "isValidSigWithSideEffects",
+    "inputs": [
+      {
+        "name": "_signer",
+        "type": "address",
+        "internalType": "address"
+      },
+      {
+        "name": "_hash",
+        "type": "bytes32",
+        "internalType": "bytes32"
+      },
+      {
+        "name": "_signature",
+        "type": "bytes",
+        "internalType": "bytes"
+      }
+    ],
+    "outputs": [
+      {
+        "name": "",
+        "type": "bool",
+        "internalType": "bool"
+      }
+    ],
+    "stateMutability": "nonpayable"
+  },
+  {
+    "type": "error",
+    "name": "ERC1271Revert",
+    "inputs": [
+      {
+        "name": "error",
+        "type": "bytes",
+        "internalType": "bytes"
+      }
+    ]
+  },
+  {
+    "type": "error",
+    "name": "ERC6492DeployFailed",
+    "inputs": [
+      {
+        "name": "error",
+        "type": "bytes",
+        "internalType": "bytes"
+      }
+    ]
+  }
+]
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/config.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/config.rs
new file mode 100644
index 0000000..3ef29dc
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/config.rs
@@ -0,0 +1,163 @@
+use alloy_primitives::B256;
+use serde::{Deserialize, Serialize};
+use std::str::FromStr;
+use url::Url;
+use x402_types::chain::ChainId;
+use x402_types::config::LiteralOrEnv;
+
+use crate::chain::Eip155ChainReference;
+
+/// Configuration for an EVM-compatible chain in the x402 facilitator.
+///
+/// This struct combines a chain reference with chain-specific configuration
+/// including RPC endpoints, signers, and network capabilities.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_eip155::chain::{Eip155ChainConfig, Eip155ChainReference};
+///
+/// let config = Eip155ChainConfig {
+///     chain_reference: Eip155ChainReference::new(8453), // Base
+///     inner: config_inner,
+/// };
+/// ```
+#[derive(Debug, Clone)]
+pub struct Eip155ChainConfig {
+    /// The numeric chain ID for this EVM network.
+    pub chain_reference: Eip155ChainReference,
+    /// Chain-specific configuration details.
+    pub inner: Eip155ChainConfigInner,
+}
+
+impl Eip155ChainConfig {
+    /// Returns the CAIP-2 chain ID for this configuration.
+    pub fn chain_id(&self) -> ChainId {
+        self.chain_reference.into()
+    }
+    /// Returns whether this chain supports EIP-1559 gas pricing.
+    pub fn eip1559(&self) -> bool {
+        self.inner.eip1559
+    }
+
+    /// Returns whether this chain supports flashblocks (immediate block finality).
+    pub fn flashblocks(&self) -> bool {
+        self.inner.flashblocks
+    }
+
+    /// Returns the transaction receipt timeout in seconds.
+    pub fn receipt_timeout_secs(&self) -> u64 {
+        self.inner.receipt_timeout_secs
+    }
+
+    /// Returns the signer configuration for this chain.
+    pub fn signers(&self) -> &Eip155SignersConfig {
+        &self.inner.signers
+    }
+
+    /// Returns the RPC endpoint configurations for this chain.
+    pub fn rpc(&self) -> &Vec<RpcConfig> {
+        &self.inner.rpc
+    }
+
+    /// Returns the numeric chain reference.
+    pub fn chain_reference(&self) -> Eip155ChainReference {
+        self.chain_reference
+    }
+}
+
+/// Configuration specific to EVM-compatible chains.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct Eip155ChainConfigInner {
+    /// Whether the chain supports EIP-1559 gas pricing.
+    #[serde(default = "eip155_chain_config::default_eip1559")]
+    pub eip1559: bool,
+    /// Whether the chain supports flashblocks.
+    #[serde(default = "eip155_chain_config::default_flashblocks")]
+    pub flashblocks: bool,
+    /// Signer configuration for this chain (required).
+    /// Array of private keys (hex format) or env var references.
+    pub signers: Eip155SignersConfig,
+    /// RPC provider configuration for this chain (required).
+    pub rpc: Vec<RpcConfig>,
+    /// How long to wait till the transaction receipt is available (optional)
+    #[serde(default = "eip155_chain_config::default_receipt_timeout_secs")]
+    pub receipt_timeout_secs: u64,
+}
+
+mod eip155_chain_config {
+    pub fn default_eip1559() -> bool {
+        true
+    }
+    pub fn default_flashblocks() -> bool {
+        false
+    }
+    pub fn default_receipt_timeout_secs() -> u64 {
+        30
+    }
+}
+
+/// RPC provider configuration for a single provider.
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct RpcConfig {
+    /// HTTP URL for the RPC endpoint.
+    pub http: Url,
+    /// Rate limit for requests per second (optional).
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub rate_limit: Option<u32>,
+}
+
+/// Configuration for EVM signers.
+///
+/// Deserializes an array of private key strings (hex format, 0x-prefixed) and
+/// validates them as valid 32-byte private keys. The `EthereumWallet` is created
+/// lazily when needed via the `wallet()` method.
+///
+/// Each string can be:
+/// - A literal hex private key: `"0xcafe..."`
+/// - An environment variable reference: `"$PRIVATE_KEY"` or `"${PRIVATE_KEY}"`
+///
+/// Example JSON:
+/// ```json
+/// {
+///   "signers": [
+///     "$HOT_WALLET_KEY",
+///     "0xcafe000000000000000000000000000000000000000000000000000000000001"
+///   ]
+/// }
+/// ```
+pub type Eip155SignersConfig = Vec<LiteralOrEnv<EvmPrivateKey>>;
+
+// ============================================================================
+// EVM Private Key
+// ============================================================================
+
+/// A validated EVM private key (32 bytes).
+///
+/// This type represents a raw private key that has been validated as a proper
+/// 32-byte hex value. It can be converted to a `PrivateKeySigner` when needed.
+#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
+pub struct EvmPrivateKey(B256);
+
+impl EvmPrivateKey {
+    /// Get the raw 32 bytes of the private key.
+    pub fn as_bytes(&self) -> &[u8; 32] {
+        self.0.as_ref()
+    }
+}
+
+impl PartialEq for EvmPrivateKey {
+    fn eq(&self, other: &Self) -> bool {
+        self.0 == other.0
+    }
+}
+
+impl FromStr for EvmPrivateKey {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        B256::from_str(s)
+            .map(Self)
+            .map_err(|e| format!("Invalid evm private key: {}", e))
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/mod.rs
new file mode 100644
index 0000000..885b534
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/mod.rs
@@ -0,0 +1,54 @@
+//! EVM chain support for x402 payments via EIP-155.
+//!
+//! This module provides types and providers for interacting with EVM-compatible blockchains
+//! in the x402 protocol. It supports ERC-3009 `transferWithAuthorization` for gasless
+//! token transfers, which is the foundation of x402 payments on EVM chains.
+//!
+//! # Key Types
+//!
+//! - [`Eip155ChainReference`] - A numeric chain ID for EVM networks (e.g., `8453` for Base)
+//! - [`Eip155ChainProvider`] - Provider for interacting with EVM chains
+//! - [`Eip155TokenDeployment`] - Token deployment information including address and decimals
+//! - [`MetaTransaction`] - Parameters for sending meta-transactions
+//!
+//! # Submodules
+//!
+//! - [`types`] - Wire format types like [`ChecksummedAddress`](types::ChecksummedAddress) and [`TokenAmount`](types::TokenAmount)
+//! - [`pending_nonce_manager`] - Nonce management for concurrent transaction submission
+//!
+//! # ERC-3009 Support
+//!
+//! The x402 protocol uses ERC-3009 `transferWithAuthorization` for payments. This allows
+//! users to sign payment authorizations off-chain, which the facilitator then submits
+//! on-chain. The facilitator pays the gas fees and is reimbursed through the payment.
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_rs::chain::eip155::{Eip155ChainReference, Eip155TokenDeployment};
+//! use x402_rs::networks::{KnownNetworkEip155, USDC};
+//!
+//! // Get USDC deployment on Base
+//! let usdc = USDC::base();
+//! assert_eq!(usdc.decimals, 6);
+//!
+//! // Parse a human-readable amount
+//! let amount = usdc.parse("10.50").unwrap();
+//! // amount.amount is now 10_500_000 (10.50 * 10^6)
+//! ```
+
+pub mod types;
+
+#[cfg(feature = "facilitator")]
+pub mod config;
+#[cfg(feature = "facilitator")]
+pub mod pending_nonce_manager;
+#[cfg(feature = "facilitator")]
+pub mod provider;
+
+#[cfg(feature = "facilitator")]
+pub use pending_nonce_manager::*;
+#[cfg(feature = "facilitator")]
+pub use provider::*;
+
+pub use types::*;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/pending_nonce_manager.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/pending_nonce_manager.rs
new file mode 100644
index 0000000..529d99e
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/pending_nonce_manager.rs
@@ -0,0 +1,94 @@
+//! Nonce management for concurrent EVM transaction submission.
+//!
+//! This module provides [`PendingNonceManager`], a custom nonce manager that improves
+//! upon Alloy's default implementation by querying pending transactions when fetching
+//! the initial nonce. This prevents "nonce too low" errors when the application restarts
+//! while transactions are still in the mempool.
+
+use alloy_primitives::Address;
+use alloy_provider::Provider;
+use alloy_provider::fillers::NonceManager;
+use alloy_transport::TransportResult;
+use async_trait::async_trait;
+use dashmap::DashMap;
+use std::sync::Arc;
+use tokio::sync::Mutex;
+
+/// A nonce manager that caches nonces locally and queries pending transactions on initialization.
+///
+/// This implementation attempts to improve upon Alloy's `CachedNonceManager` by using `.pending()` when
+/// fetching the initial nonce, which includes pending transactions in the mempool. This prevents
+/// "nonce too low" errors when the application restarts while transactions are still pending.
+///
+/// # How it works
+///
+/// - **First call for an address**: Fetches the nonce using `.pending()`, which includes
+///   transactions in the mempool, not just confirmed transactions.
+/// - **Subsequent calls**: Increments the cached nonce locally without querying the RPC.
+/// - **Per-address tracking**: Each address has its own cached nonce, allowing concurrent
+///   transaction submission from multiple addresses.
+///
+/// # Thread Safety
+///
+/// The nonce cache is shared across all clones using `Arc<DashMap>`, ensuring that concurrent
+/// requests see consistent nonce values. Each address's nonce is protected by its own `Mutex`
+/// to prevent race conditions during allocation.
+/// ```
+#[derive(Clone, Debug, Default)]
+pub struct PendingNonceManager {
+    /// Cache of nonces per address. Each address has its own mutex-protected nonce value.
+    nonces: Arc<DashMap<Address, Arc<Mutex<u64>>>>,
+}
+
+#[async_trait]
+impl NonceManager for PendingNonceManager {
+    async fn get_next_nonce<P, N>(&self, provider: &P, address: Address) -> TransportResult<u64>
+    where
+        P: Provider<N>,
+        N: alloy_network::Network,
+    {
+        // Use `u64::MAX` as a sentinel value to indicate that the nonce has not been fetched yet.
+        const NONE: u64 = u64::MAX;
+
+        // Locks dashmap internally for a short duration to clone the `Arc`.
+        // We also don't want to hold the dashmap lock through the await point below.
+        let nonce = {
+            let rm = self
+                .nonces
+                .entry(address)
+                .or_insert_with(|| Arc::new(Mutex::new(NONE)));
+            Arc::clone(rm.value())
+        };
+
+        let mut nonce = nonce.lock().await;
+        let new_nonce = if *nonce == NONE {
+            // Initialize the nonce if we haven't seen this account before.
+            #[cfg(feature = "telemetry")]
+            tracing::trace!(%address, "fetching nonce");
+            provider.get_transaction_count(address).pending().await?
+        } else {
+            #[cfg(feature = "telemetry")]
+            tracing::trace!(%address, current_nonce = *nonce, "incrementing nonce");
+            *nonce + 1
+        };
+        *nonce = new_nonce;
+        Ok(new_nonce)
+    }
+}
+
+impl PendingNonceManager {
+    /// Resets the cached nonce for a given address, forcing a fresh query on next use.
+    ///
+    /// This should be called when a transaction fails, as we cannot be certain of the
+    /// actual on-chain state (the transaction may or may not have reached the mempool).
+    /// By resetting to the sentinel value, the next call to `get_next_nonce` will query
+    /// the RPC provider using `.pending()`, which includes mempool transactions.
+    pub async fn reset_nonce(&self, address: Address) {
+        if let Some(nonce_lock) = self.nonces.get(&address) {
+            let mut nonce = nonce_lock.lock().await;
+            *nonce = u64::MAX; // NONE sentinel - will trigger fresh query
+            #[cfg(feature = "telemetry")]
+            tracing::debug!(%address, "reset nonce cache, will requery on next use");
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/provider.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/provider.rs
new file mode 100644
index 0000000..a618c3c
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/provider.rs
@@ -0,0 +1,407 @@
+use alloy_network::{Ethereum as AlloyEthereum, EthereumWallet, NetworkWallet, TransactionBuilder};
+use alloy_primitives::{Address, B256, Bytes};
+use alloy_provider::fillers::{
+    BlobGasFiller, ChainIdFiller, FillProvider, GasFiller, JoinFill, NonceFiller, WalletFiller,
+};
+use alloy_provider::{
+    Identity, PendingTransactionError, Provider, ProviderBuilder, RootProvider, WalletProvider,
+};
+use alloy_rpc_client::RpcClient;
+use alloy_rpc_types_eth::{BlockId, TransactionReceipt, TransactionRequest};
+use alloy_signer::Signer;
+use alloy_signer_local::PrivateKeySigner;
+use alloy_transport::TransportError;
+use alloy_transport::layers::{FallbackLayer, ThrottleLayer};
+use alloy_transport_http::Http;
+use std::num::NonZeroUsize;
+use std::sync::Arc;
+use std::sync::atomic::{AtomicUsize, Ordering};
+use tower::ServiceBuilder;
+use x402_types::chain::{ChainId, ChainProviderOps, FromConfig};
+
+#[cfg(feature = "telemetry")]
+use tracing::Instrument;
+
+use crate::chain::config::{Eip155ChainConfig, RpcConfig};
+use crate::chain::pending_nonce_manager::PendingNonceManager;
+use crate::chain::types::Eip155ChainReference;
+
+/// Combined filler type for gas, blob gas, nonce, and chain ID.
+pub type InnerFiller = JoinFill<
+    GasFiller,
+    JoinFill<BlobGasFiller, JoinFill<NonceFiller<PendingNonceManager>, ChainIdFiller>>,
+>;
+
+/// The fully composed Ethereum provider type used in this project.
+///
+/// Combines multiple filler layers for gas, nonce, chain ID, blob gas, and wallet signing,
+/// and wraps a [`RootProvider`] for actual JSON-RPC communication.
+pub type InnerProvider = FillProvider<
+    JoinFill<JoinFill<Identity, InnerFiller>, WalletFiller<EthereumWallet>>,
+    RootProvider,
+>;
+
+/// Provider for interacting with EVM-compatible blockchains.
+///
+/// This provider handles:
+/// - Transaction signing with multiple signers (round-robin selection)
+/// - Nonce management with automatic reset on failures
+/// - Gas estimation and pricing (EIP-1559 and legacy)
+/// - Transaction receipt fetching with configurable timeouts
+///
+/// # Multiple Signers
+///
+/// The provider supports multiple signers for load distribution. When sending
+/// transactions, signers are selected in round-robin fashion to distribute
+/// the transaction load and avoid nonce conflicts.
+///
+/// # Nonce Management
+///
+/// Uses [`PendingNonceManager`] to track nonces locally and query pending
+/// transactions on initialization. If a transaction fails, the nonce is
+/// automatically reset to force a fresh query on the next transaction.
+#[derive(Debug)]
+pub struct Eip155ChainProvider {
+    chain: Eip155ChainReference,
+    eip1559: bool,
+    flashblocks: bool,
+    receipt_timeout_secs: u64,
+    inner: InnerProvider,
+    /// Available signer addresses for round-robin selection.
+    signer_addresses: Arc<Vec<Address>>,
+    /// Current position in round-robin signer rotation.
+    signer_cursor: Arc<AtomicUsize>,
+    /// Nonce manager for resetting nonces on transaction failures.
+    nonce_manager: PendingNonceManager,
+}
+
+impl Eip155ChainProvider {
+    #[allow(unused_variables)] // chain_id is needed for tracing only here
+    pub fn rpc_client(chain_id: ChainId, rpc: &[RpcConfig]) -> RpcClient {
+        let transports = rpc
+            .iter()
+            .filter_map(|provider_config| {
+                let scheme = provider_config.http.scheme();
+                let is_http = scheme == "http" || scheme == "https";
+                if !is_http {
+                    return None;
+                }
+                let rpc_url = provider_config.http.clone();
+                #[cfg(feature = "telemetry")]
+                tracing::info!(chain=%chain_id, rpc_url=%rpc_url, rate_limit=?provider_config.rate_limit, "Using HTTP transport");
+                let rate_limit = provider_config.rate_limit.unwrap_or(u32::MAX);
+                let service = ServiceBuilder::new()
+                    .layer(ThrottleLayer::new(rate_limit))
+                    .service(Http::new(rpc_url));
+                Some(service)
+            })
+            .collect::<Vec<_>>();
+        let fallback = ServiceBuilder::new()
+            .layer(
+                FallbackLayer::default().with_active_transport_count(
+                    NonZeroUsize::new(transports.len())
+                        .expect("Non-zero amount of stateless transports"),
+                ),
+            )
+            .service(transports);
+        RpcClient::new(fallback, false)
+    }
+
+    /// Round-robin selection of next signer from wallet.
+    fn next_signer_address(&self) -> Address {
+        debug_assert!(!self.signer_addresses.is_empty());
+        if self.signer_addresses.len() == 1 {
+            self.signer_addresses[0]
+        } else {
+            let next =
+                self.signer_cursor.fetch_add(1, Ordering::Relaxed) % self.signer_addresses.len();
+            self.signer_addresses[next]
+        }
+    }
+}
+
+/// Creates a new provider from configuration.
+///
+/// Initializes signers, RPC transports, and the nonce manager.
+///
+/// # Errors
+///
+/// Returns an error if:
+/// - No signers are configured
+/// - Signer private keys are invalid
+/// - RPC transport initialization fails
+#[async_trait::async_trait]
+impl FromConfig<Eip155ChainConfig> for Eip155ChainProvider {
+    async fn from_config(config: &Eip155ChainConfig) -> Result<Self, Box<dyn std::error::Error>> {
+        // 1. Signers
+        let signers = config
+            .signers()
+            .iter()
+            .map(|s| B256::from_slice(s.inner().as_bytes()))
+            .map(|b| {
+                PrivateKeySigner::from_bytes(&b)
+                    .map(|s| s.with_chain_id(Some(config.chain_reference().inner())))
+            })
+            .collect::<Result<Vec<_>, _>>()?;
+        if signers.is_empty() {
+            return Err("at least one signer should be provided".into());
+        }
+        let wallet = {
+            let mut iter = signers.into_iter();
+            let first_signer = iter
+                .next()
+                .expect("iterator contains at least one element by construction");
+            let mut wallet = EthereumWallet::from(first_signer);
+            for signer in iter {
+                wallet.register_signer(signer);
+            }
+            wallet
+        };
+        let signer_addresses =
+            NetworkWallet::<AlloyEthereum>::signer_addresses(&wallet).collect::<Vec<_>>();
+        let signer_addresses = Arc::new(signer_addresses);
+        let signer_cursor = Arc::new(AtomicUsize::new(0));
+
+        // 2. Transports
+        let client = Self::rpc_client(config.chain_id(), config.rpc());
+
+        // 3. Provider
+        // Create nonce manager explicitly so we can store a reference for error handling
+        let nonce_manager = PendingNonceManager::default();
+        // Build the filler stack: Gas -> BlobGas -> Nonce -> ChainId
+        // This mirrors the InnerFiller type but with our custom nonce manager
+        let filler = JoinFill::new(
+            GasFiller,
+            JoinFill::new(
+                BlobGasFiller::default(),
+                JoinFill::new(
+                    NonceFiller::new(nonce_manager.clone()),
+                    ChainIdFiller::default(),
+                ),
+            ),
+        );
+        let inner: InnerProvider = ProviderBuilder::default()
+            .filler(filler)
+            .wallet(wallet)
+            .connect_client(client);
+
+        #[cfg(feature = "telemetry")]
+        tracing::info!(chain=%config.chain_id(), signers=?signer_addresses, "Using EVM provider");
+
+        Ok(Self {
+            chain: config.chain_reference(),
+            eip1559: config.eip1559(),
+            flashblocks: config.flashblocks(),
+            receipt_timeout_secs: config.receipt_timeout_secs(),
+            inner,
+            signer_addresses,
+            signer_cursor,
+            nonce_manager,
+        })
+    }
+}
+
+impl Eip155MetaTransactionProvider for Eip155ChainProvider {
+    type Error = MetaTransactionSendError;
+    type Inner = InnerProvider;
+
+    fn inner(&self) -> &Self::Inner {
+        &self.inner
+    }
+
+    fn chain(&self) -> &Eip155ChainReference {
+        &self.chain
+    }
+
+    /// Send a meta-transaction with provided `to`, `calldata`, and automatically selected signer.
+    ///
+    /// This method constructs a transaction from the provided [`MetaTransaction`], automatically
+    /// selects the next available signer using round-robin selection, and handles gas pricing
+    /// based on whether the network supports EIP-1559.
+    ///
+    /// If the transaction fails at any point (during submission or receipt fetching), the nonce
+    /// for the sending address is reset to force a fresh query on the next transaction. This
+    /// ensures correctness even when transactions partially succeed (e.g., submitted but receipt
+    /// fetch times out).
+    ///
+    /// # Gas Pricing Strategy
+    ///
+    /// - **EIP-1559 networks**: Uses automatic gas pricing via the provider's fillers.
+    /// - **Legacy networks**: Fetches the current gas price using `get_gas_price()` and sets it explicitly.
+    ///
+    /// # Timeout Configuration
+    ///
+    /// Receipt fetching is subject to a configurable timeout:
+    /// - Default: 30 seconds
+    /// - Override via `TX_RECEIPT_TIMEOUT_SECS` environment variable
+    /// - If the timeout expires, the nonce is reset and an error is returned
+    ///
+    /// # Parameters
+    ///
+    /// - `tx`: A [`MetaTransaction`] containing the target address and calldata.
+    ///
+    /// # Returns
+    ///
+    /// A [`TransactionReceipt`] once the transaction has been mined and confirmed.
+    ///
+    /// # Errors
+    ///
+    /// Returns [`FacilitatorLocalError::ContractCall`] if:
+    /// - Gas price fetching fails (on legacy networks)
+    /// - Transaction sending fails
+    /// - Receipt retrieval fails or times out
+    async fn send_transaction(
+        &self,
+        tx: MetaTransaction,
+    ) -> Result<TransactionReceipt, Self::Error> {
+        let from_address = self.next_signer_address();
+        tracing::info!("[DEBUG] send_transaction START: from={}, to={}", from_address, tx.to);
+        
+        let mut txr = TransactionRequest::default()
+            .with_to(tx.to)
+            .with_from(from_address)
+            .with_input(tx.calldata);
+
+        if !self.eip1559 {
+            tracing::info!("[DEBUG] fetching gas price (non-EIP1559)...");
+            let provider = &self.inner;
+            let gas_fut = provider.get_gas_price();
+            #[cfg(feature = "telemetry")]
+            let gas: u128 = gas_fut
+                .instrument(tracing::info_span!("get_gas_price"))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            let gas: u128 = gas_fut.await?;
+            tracing::info!("[DEBUG] gas price fetched: {}", gas);
+            txr.set_gas_price(gas);
+        }
+
+        // Estimate gas if not provided
+        if txr.gas.is_none() {
+            tracing::info!("[DEBUG] estimating gas...");
+            let block_id = if self.flashblocks {
+                BlockId::latest()
+            } else {
+                BlockId::pending()
+            };
+            let gas_limit = match self.inner.estimate_gas(txr.clone()).block(block_id).await {
+                Ok(limit) => {
+                    tracing::info!("[DEBUG] gas estimated: {}", limit);
+                    limit
+                }
+                Err(e) => {
+                    tracing::error!("[DEBUG] gas estimation FAILED: {:?}", e);
+                    return Err(MetaTransactionSendError::Transport(e));
+                }
+            };
+            txr.set_gas_limit(gas_limit)
+        }
+
+        // Send transaction with error handling for nonce reset
+        tracing::info!("[DEBUG] sending transaction...");
+        let pending_tx = match self.inner.send_transaction(txr).await {
+            Ok(pending) => {
+                tracing::info!("[DEBUG] tx submitted, hash={}", pending.tx_hash());
+                pending
+            }
+            Err(e) => {
+                tracing::error!("[DEBUG] tx submission FAILED: {:?}", e);
+                self.nonce_manager.reset_nonce(from_address).await;
+                return Err(MetaTransactionSendError::Transport(e));
+            }
+        };
+
+        // Get receipt with timeout and error handling for nonce reset
+        let timeout = std::time::Duration::from_secs(self.receipt_timeout_secs);
+        tracing::info!("[DEBUG] waiting for receipt (timeout={}s)...", self.receipt_timeout_secs);
+
+        let watcher = pending_tx
+            .with_required_confirmations(tx.confirmations)
+            .with_timeout(Some(timeout));
+
+        match watcher.get_receipt().await {
+            Ok(receipt) => {
+                tracing::info!("[DEBUG] receipt received! status={}, block={:?}", receipt.status(), receipt.block_number);
+                Ok(receipt)
+            }
+            Err(e) => {
+                tracing::error!("[DEBUG] receipt wait FAILED: {:?}", e);
+                self.nonce_manager.reset_nonce(from_address).await;
+                Err(MetaTransactionSendError::PendingTransaction(e))
+            }
+        }
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+pub enum MetaTransactionSendError {
+    #[error(transparent)]
+    Transport(#[from] TransportError),
+    #[error(transparent)]
+    PendingTransaction(#[from] PendingTransactionError),
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    #[error("{0}")]
+    Custom(String),
+}
+
+impl ChainProviderOps for Eip155ChainProvider {
+    fn signer_addresses(&self) -> Vec<String> {
+        self.inner
+            .signer_addresses()
+            .map(|a| a.to_string())
+            .collect()
+    }
+
+    fn chain_id(&self) -> ChainId {
+        self.chain.into()
+    }
+}
+
+/// Meta-transaction parameters: target address, calldata, and required confirmations.
+pub struct MetaTransaction {
+    /// Target contract address.
+    pub to: Address,
+    /// Transaction calldata (encoded function call).
+    pub calldata: Bytes,
+    /// Number of block confirmations to wait for.
+    pub confirmations: u64,
+}
+
+/// Trait for sending meta-transactions with custom target and calldata.
+pub trait Eip155MetaTransactionProvider {
+    /// Error type for operations.
+    type Error;
+    /// Underlying provider type.
+    type Inner: Provider;
+
+    /// Returns reference to underlying provider.
+    fn inner(&self) -> &Self::Inner;
+    /// Returns reference to chain descriptor.
+    fn chain(&self) -> &Eip155ChainReference;
+
+    /// Sends a meta-transaction to the network.
+    fn send_transaction(
+        &self,
+        tx: MetaTransaction,
+    ) -> impl Future<Output = Result<TransactionReceipt, Self::Error>> + Send;
+}
+
+impl<T: Eip155MetaTransactionProvider> Eip155MetaTransactionProvider for Arc<T> {
+    type Error = T::Error;
+    type Inner = T::Inner;
+
+    fn inner(&self) -> &Self::Inner {
+        (**self).inner()
+    }
+
+    fn chain(&self) -> &Eip155ChainReference {
+        (**self).chain()
+    }
+
+    fn send_transaction(
+        &self,
+        tx: MetaTransaction,
+    ) -> impl Future<Output = Result<TransactionReceipt, Self::Error>> + Send {
+        (**self).send_transaction(tx)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/types.rs
new file mode 100644
index 0000000..fec7149
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/chain/types.rs
@@ -0,0 +1,463 @@
+//! Wire format types for EVM chain interactions.
+//!
+//! This module provides types that handle serialization and deserialization
+//! of EVM-specific values in the x402 protocol wire format.
+
+use alloy_primitives::{Address, U256, hex};
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::fmt::{Display, Formatter};
+use std::ops::Mul;
+use std::str::FromStr;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::util::money_amount::{MoneyAmount, MoneyAmountParseError};
+
+/// An Ethereum address that serializes with EIP-55 checksum encoding.
+///
+/// This wrapper ensures addresses are always serialized in checksummed format
+/// (e.g., `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`) for compatibility
+/// with the x402 protocol wire format.
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_eip155::chain::ChecksummedAddress;
+///
+/// let addr: ChecksummedAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045".parse().unwrap();
+/// assert_eq!(addr.to_string(), "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
+/// ```
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct ChecksummedAddress(pub Address);
+
+impl FromStr for ChecksummedAddress {
+    type Err = hex::FromHexError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let address = Address::from_str(s)?;
+        Ok(Self(address))
+    }
+}
+
+impl Display for ChecksummedAddress {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0.to_checksum(None))
+    }
+}
+
+impl Serialize for ChecksummedAddress {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.0.to_checksum(None))
+    }
+}
+
+impl<'de> Deserialize<'de> for ChecksummedAddress {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        s.parse().map_err(serde::de::Error::custom)
+    }
+}
+
+impl From<ChecksummedAddress> for Address {
+    fn from(value: ChecksummedAddress) -> Self {
+        value.0
+    }
+}
+
+impl From<Address> for ChecksummedAddress {
+    fn from(address: Address) -> Self {
+        Self(address)
+    }
+}
+
+impl PartialEq<ChecksummedAddress> for Address {
+    fn eq(&self, other: &ChecksummedAddress) -> bool {
+        self.eq(&other.0)
+    }
+}
+
+/// A token amount represented as a U256, serialized as a decimal string.
+///
+/// This wrapper ensures token amounts are serialized as decimal strings
+/// (e.g., `"1000000"`) rather than hex to maintain compatibility with
+/// the x402 protocol wire format and avoid precision issues in JSON.
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_eip155::chain::TokenAmount;
+/// use alloy_primitives::U256;
+///
+/// let amount = TokenAmount(U256::from(1_000_000u64));
+/// let json = serde_json::to_string(&amount).unwrap();
+/// assert_eq!(json, "\"1000000\"");
+/// ```
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct TokenAmount(pub U256);
+
+impl FromStr for TokenAmount {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let u256 = U256::from_str_radix(s, 10).map_err(|_| "invalid token amount".to_string())?;
+        Ok(Self(u256))
+    }
+}
+
+impl Serialize for TokenAmount {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.0.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for TokenAmount {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        Self::from_str(&s).map_err(serde::de::Error::custom)
+    }
+}
+
+impl From<TokenAmount> for U256 {
+    fn from(value: TokenAmount) -> Self {
+        value.0
+    }
+}
+
+impl From<U256> for TokenAmount {
+    fn from(value: U256) -> Self {
+        Self(value)
+    }
+}
+
+impl From<u128> for TokenAmount {
+    fn from(value: u128) -> Self {
+        Self(U256::from(value))
+    }
+}
+
+impl From<u64> for TokenAmount {
+    fn from(value: u64) -> Self {
+        Self(U256::from(value))
+    }
+}
+
+/// The CAIP-2 namespace for EVM-compatible chains.
+pub const EIP155_NAMESPACE: &str = "eip155";
+
+/// A numeric chain ID for EVM-compatible networks.
+///
+/// This type wraps the numeric chain ID used by EVM networks (e.g., `1` for Ethereum mainnet,
+/// `8453` for Base). It can be converted to/from a [`ChainId`] for use with the x402 protocol.
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_eip155::chain::Eip155ChainReference;
+/// use x402_types::chain::ChainId;
+///
+/// let base = Eip155ChainReference::new(8453);
+/// let chain_id: ChainId = base.into();
+/// assert_eq!(chain_id.to_string(), "eip155:8453");
+/// ```
+#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
+pub struct Eip155ChainReference(u64);
+
+impl Eip155ChainReference {
+    /// Converts this chain reference to a CAIP-2 [`ChainId`].
+    pub fn as_chain_id(&self) -> ChainId {
+        ChainId::new(EIP155_NAMESPACE, self.0.to_string())
+    }
+}
+
+impl From<Eip155ChainReference> for ChainId {
+    fn from(value: Eip155ChainReference) -> Self {
+        ChainId::new(EIP155_NAMESPACE, value.0.to_string())
+    }
+}
+
+impl From<&Eip155ChainReference> for ChainId {
+    fn from(value: &Eip155ChainReference) -> Self {
+        ChainId::new(EIP155_NAMESPACE, value.0.to_string())
+    }
+}
+
+impl TryFrom<ChainId> for Eip155ChainReference {
+    type Error = Eip155ChainReferenceFormatError;
+
+    fn try_from(value: ChainId) -> Result<Self, Self::Error> {
+        if value.namespace != EIP155_NAMESPACE {
+            return Err(Eip155ChainReferenceFormatError::InvalidNamespace(
+                value.namespace,
+            ));
+        }
+        let chain_id: u64 = value.reference.parse().map_err(|_| {
+            Eip155ChainReferenceFormatError::InvalidReference(value.reference.clone())
+        })?;
+        Ok(Eip155ChainReference(chain_id))
+    }
+}
+
+impl TryFrom<&ChainId> for Eip155ChainReference {
+    type Error = Eip155ChainReferenceFormatError;
+
+    fn try_from(value: &ChainId) -> Result<Self, Self::Error> {
+        if value.namespace != EIP155_NAMESPACE {
+            return Err(Eip155ChainReferenceFormatError::InvalidNamespace(
+                value.namespace.clone(),
+            ));
+        }
+        let chain_id: u64 = value.reference.parse().map_err(|_| {
+            Eip155ChainReferenceFormatError::InvalidReference(value.reference.clone())
+        })?;
+        Ok(Eip155ChainReference(chain_id))
+    }
+}
+
+/// Error returned when converting a [`ChainId`] to an [`Eip155ChainReference`].
+#[derive(Debug, thiserror::Error)]
+pub enum Eip155ChainReferenceFormatError {
+    /// The chain ID namespace is not `eip155`.
+    #[error("Invalid namespace {0}, expected eip155")]
+    InvalidNamespace(String),
+    /// The chain reference is not a valid numeric value.
+    #[error("Invalid eip155 chain reference {0}")]
+    InvalidReference(String),
+}
+
+impl Eip155ChainReference {
+    /// Creates a new chain reference from a numeric chain ID.
+    pub fn new(chain_id: u64) -> Self {
+        Self(chain_id)
+    }
+
+    /// Returns the numeric chain ID.
+    pub fn inner(&self) -> u64 {
+        self.0
+    }
+}
+
+impl Display for Eip155ChainReference {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+/// Information about a token deployment on an EVM chain.
+///
+/// This type contains all the information needed to interact with a token contract,
+/// including its address, decimal places, and optional EIP-712 domain parameters
+/// for signature verification.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_rs::networks::{KnownNetworkEip155, USDC};
+///
+/// // Get USDC deployment on Base
+/// let usdc = USDC::base();
+/// assert_eq!(usdc.decimals, 6);
+///
+/// // Parse a human-readable amount to token units
+/// let amount = usdc.parse("10.50").unwrap();
+/// assert_eq!(amount.amount, U256::from(10_500_000u64));
+/// ```
+#[derive(Debug, Clone, Eq, PartialEq, Hash)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct Eip155TokenDeployment {
+    /// The chain this token is deployed on.
+    pub chain_reference: Eip155ChainReference,
+    /// The token contract address.
+    pub address: Address,
+    /// Number of decimal places for the token (e.g., 6 for USDC, 18 for most ERC-20s).
+    pub decimals: u8,
+    /// Optional EIP-712 domain parameters for signature verification.
+    pub eip712: Option<TokenDeploymentEip712>,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl Eip155TokenDeployment {
+    /// Creates a token amount from a raw value.
+    ///
+    /// The value should already be in the token's smallest unit (e.g., wei).
+    pub fn amount<V: Into<TokenAmount>>(
+        &self,
+        v: V,
+    ) -> DeployedTokenAmount<U256, Eip155TokenDeployment> {
+        DeployedTokenAmount {
+            amount: v.into().0,
+            token: self.clone(),
+        }
+    }
+
+    /// Parses a human-readable amount string into token units.
+    ///
+    /// Accepts formats like `"10.50"`, `"$10.50"`, `"1,000"`, etc.
+    /// The amount is scaled by the token's decimal places.
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if:
+    /// - The input cannot be parsed as a number
+    /// - The input has more decimal places than the token supports
+    /// - The value is out of range
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_rs::networks::{KnownNetworkEip155, USDC};
+    ///
+    /// let usdc = USDC::base();
+    /// let amount = usdc.parse("10.50").unwrap();
+    /// // 10.50 USDC = 10,500,000 units (6 decimals)
+    /// assert_eq!(amount.amount, U256::from(10_500_000u64));
+    /// ```
+    pub fn parse<V>(
+        &self,
+        v: V,
+    ) -> Result<DeployedTokenAmount<U256, Eip155TokenDeployment>, MoneyAmountParseError>
+    where
+        V: TryInto<MoneyAmount>,
+        MoneyAmountParseError: From<<V as TryInto<MoneyAmount>>::Error>,
+    {
+        let money_amount = v.try_into()?;
+        let scale = money_amount.scale();
+        let token_scale = self.decimals as u32;
+        if scale > token_scale {
+            return Err(MoneyAmountParseError::WrongPrecision {
+                money: scale,
+                token: token_scale,
+            });
+        }
+        let scale_diff = token_scale - scale;
+        let multiplier = U256::from(10).pow(U256::from(scale_diff));
+        let digits = money_amount.mantissa();
+        let value = U256::from(digits).mul(multiplier);
+        Ok(DeployedTokenAmount {
+            amount: value,
+            token: self.clone(),
+        })
+    }
+}
+
+/// EIP-712 domain parameters for a token deployment.
+///
+/// These parameters are used when verifying EIP-712 typed data signatures
+/// for ERC-3009 `transferWithAuthorization` calls.
+#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct TokenDeploymentEip712 {
+    /// The token name as specified in the EIP-712 domain.
+    pub name: String,
+    /// The token version as specified in the EIP-712 domain.
+    pub version: String,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn create_test_deployment(decimals: u8) -> Eip155TokenDeployment {
+        let chain_ref = Eip155ChainReference::new(1); // Mainnet
+        Eip155TokenDeployment {
+            chain_reference: chain_ref,
+            address: alloy_primitives::Address::ZERO,
+            decimals,
+            eip712: None,
+        }
+    }
+
+    #[test]
+    fn test_parse_whole_number() {
+        let deployment = create_test_deployment(6); // 6 decimals like USDC
+        let result = deployment.parse("100");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(100_000_000u64)); // 100 * 10^6
+    }
+
+    #[test]
+    fn test_parse_with_decimals() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("1.50");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(1_500_000u64)); // 1.50 * 10^6
+    }
+
+    #[test]
+    fn test_parse_zero_decimals() {
+        let deployment = create_test_deployment(0);
+        let result = deployment.parse("42");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(42u64));
+    }
+
+    #[test]
+    fn test_parse_precision_too_high() {
+        let deployment = create_test_deployment(2); // Only 2 decimals
+        let result = deployment.parse("1.234"); // 3 decimals - should fail
+        assert!(result.is_err());
+        let err = result.unwrap_err();
+        assert!(matches!(err, MoneyAmountParseError::WrongPrecision { .. }));
+    }
+
+    #[test]
+    fn test_parse_exact_precision() {
+        let deployment = create_test_deployment(9); // 9 decimals
+        let result = deployment.parse("0.123456789");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(123_456_789u64));
+    }
+
+    #[test]
+    fn test_parse_smallest_amount() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("0.000001");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(1u64));
+    }
+
+    #[test]
+    fn test_parse_with_currency_symbol() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("$10.50");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(10_500_000u64));
+    }
+
+    #[test]
+    fn test_parse_with_commas() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("1,000");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, U256::from(1_000_000_000u64));
+    }
+
+    #[test]
+    fn test_parse_large_amount() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("999999999");
+        assert!(result.is_ok());
+        // 999999999 * 10^6 = 999999999000000
+        assert_eq!(result.unwrap().amount, U256::from(999_999_999_000_000u64));
+    }
+
+    #[test]
+    fn test_parse_very_large_amount_with_high_decimals() {
+        // EIP155 uses U256, so we can handle much larger amounts than Solana
+        let deployment = create_test_deployment(18); // 18 decimals like ETH
+        let result = deployment.parse("999999999"); // 9 digits, 0 decimals
+        assert!(result.is_ok());
+        // 999999999 * 10^18 = 999999999000000000000000000
+        let expected = U256::from(999_999_999u64) * U256::from(10).pow(U256::from(18));
+        assert_eq!(result.unwrap().amount, expected);
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/lib.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/lib.rs
new file mode 100644
index 0000000..29566b0
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/lib.rs
@@ -0,0 +1,93 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! EIP-155 (EVM) chain support for the x402 payment protocol.
+//!
+//! This crate provides implementations of the x402 payment protocol for EVM-compatible
+//! blockchains using the EIP-155 chain ID standard. It supports both V1 and V2 protocol
+//! versions with the "exact" payment scheme based on ERC-3009 `transferWithAuthorization`.
+//!
+//! # Features
+//!
+//! - **V1 and V2 Protocol Support**: Implements both protocol versions with network name
+//!   (V1) and CAIP-2 chain ID (V2) addressing
+//! - **ERC-3009 Payments**: Gasless token transfers using `transferWithAuthorization`
+//! - **Smart Wallet Support**: EIP-1271 for deployed wallets, EIP-6492 for counterfactual wallets
+//! - **Multiple Signers**: Round-robin signer selection for load distribution
+//! - **Nonce Management**: Automatic nonce tracking with pending transaction awareness
+//!
+//! # Architecture
+//!
+//! The crate is organized into several modules:
+//!
+//! - [`chain`] - Core EVM chain types, providers, and configuration
+//! - [`v1_eip155_exact`] - V1 protocol implementation with network names
+//! - [`v2_eip155_exact`] - V2 protocol implementation with CAIP-2 chain IDs
+//!
+//! # Feature Flags
+//!
+//! - `server` - Server-side price tag generation
+//! - `client` - Client-side payment signing
+//! - `facilitator` - Facilitator-side payment verification and settlement
+//! - `telemetry` - OpenTelemetry tracing support
+//!
+//! # Usage Examples
+//!
+//! ## Server: Creating a Price Tag
+//!
+//! ```ignore
+//! use x402_chain_eip155::{V1Eip155Exact, KnownNetworkEip155};
+//! use x402_types::networks::USDC;
+//!
+//! // Get USDC deployment on Base
+//! let usdc = USDC::base();
+//!
+//! // Create a price tag for 1 USDC
+//! let price_tag = V1Eip155Exact::price_tag(
+//!     "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
+//!     usdc.amount(1_000_000u64),
+//! );
+//! ```
+//!
+//! ## Client: Signing a Payment
+//!
+//! ```ignore
+//! use x402_chain_eip155::V1Eip155ExactClient;
+//! use alloy_signer_local::PrivateKeySigner;
+//!
+//! let signer = PrivateKeySigner::random();
+//! let client = V1Eip155ExactClient::new(signer);
+//!
+//! // Use client to sign payment candidates
+//! let candidates = client.accept(&payment_required);
+//! ```
+//!
+//! ## Facilitator: Verifying and Settling
+//!
+//! ```ignore
+//! use x402_chain_eip155::{V1Eip155Exact, Eip155ChainProvider};
+//! use x402_types::scheme::X402SchemeFacilitatorBuilder;
+//!
+//! let provider = Eip155ChainProvider::from_config(&config).await?;
+//! let facilitator = V1Eip155Exact.build(provider, None)?;
+//!
+//! // Verify payment
+//! let verify_response = facilitator.verify(&verify_request).await?;
+//!
+//! // Settle payment
+//! let settle_response = facilitator.settle(&settle_request).await?;
+//! ```
+
+pub mod chain;
+pub mod v1_eip155_exact;
+pub mod v2_eip155_exact;
+
+mod networks;
+pub use networks::*;
+
+pub use v1_eip155_exact::V1Eip155Exact;
+pub use v2_eip155_exact::V2Eip155Exact;
+
+#[cfg(feature = "client")]
+pub use v1_eip155_exact::client::V1Eip155ExactClient;
+#[cfg(feature = "client")]
+pub use v2_eip155_exact::client::V2Eip155ExactClient;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/networks.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/networks.rs
new file mode 100644
index 0000000..3190c58
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/networks.rs
@@ -0,0 +1,312 @@
+use x402_types::chain::ChainId;
+use x402_types::networks::USDC;
+
+use crate::chain::{Eip155ChainReference, Eip155TokenDeployment, TokenDeploymentEip712};
+
+/// Trait providing convenient methods to get instances for well-known EVM networks (eip155 namespace).
+///
+/// This trait can be implemented for any type to provide static methods that create
+/// instances for well-known EVM blockchain networks. Each method returns `Self`, allowing
+/// the trait to be used with different types that need per-network configuration.
+///
+/// # Use Cases
+///
+/// - **ChainId**: Get CAIP-2 chain identifiers for EVM networks
+/// - **Token Deployments**: Get per-chain token addresses (e.g., USDC on different EVM chains)
+/// - **Network Configuration**: Get network-specific configuration objects for EVM chains
+/// - **Any Per-Network Data**: Any type that needs EVM network-specific instances
+///
+/// # Examples
+///
+/// ```ignore
+/// use x402_rs::chain::ChainId;
+/// use x402_rs::known::KnownNetworkEip155;
+///
+/// // Get Base mainnet chain ID
+/// let base = ChainId::base();
+/// assert_eq!(base.namespace, "eip155");
+/// assert_eq!(base.reference, "8453");
+///
+/// // Get Polygon mainnet chain ID
+/// let polygon = ChainId::polygon();
+/// assert_eq!(polygon.namespace, "eip155");
+/// assert_eq!(polygon.reference, "137");
+///
+/// // Can also be implemented for other types like token addresses
+/// // let usdc_base = UsdcAddress::base();
+/// // let usdc_polygon = UsdcAddress::polygon();
+/// ```
+#[allow(dead_code)]
+pub trait KnownNetworkEip155<A> {
+    /// Returns the instance for Base mainnet (eip155:8453)
+    fn base() -> A;
+    /// Returns the instance for Base Sepolia testnet (eip155:84532)
+    fn base_sepolia() -> A;
+
+    /// Returns the instance for Polygon mainnet (eip155:137)
+    fn polygon() -> A;
+    /// Returns the instance for Polygon Amoy testnet (eip155:80002)
+    fn polygon_amoy() -> A;
+
+    /// Returns the instance for Avalanche C-Chain mainnet (eip155:43114)
+    fn avalanche() -> A;
+    /// Returns the instance for Avalanche Fuji testnet (eip155:43113)
+    fn avalanche_fuji() -> A;
+
+    /// Returns the instance for Sei mainnet (eip155:1329)
+    fn sei() -> A;
+    /// Returns the instance for Sei testnet (eip155:1328)
+    fn sei_testnet() -> A;
+
+    /// Returns the instance for XDC Network (eip155:50)
+    fn xdc() -> A;
+
+    /// Returns the instance for XRPL EVM (eip155:1440000)
+    fn xrpl_evm() -> A;
+
+    /// Returns the instance for Peaq (eip155:3338)
+    fn peaq() -> A;
+
+    /// Returns the instance for IoTeX (eip155:4689)
+    fn iotex() -> A;
+
+    /// Returns the instance for Celo mainnet (eip155:42220)
+    fn celo() -> A;
+
+    /// Returns the instance for Celo testnet (eip155:11142220)
+    fn celo_sepolia() -> A;
+}
+
+/// Implementation of KnownNetworkEip155 for ChainId.
+///
+/// Provides convenient static methods to create ChainId instances for well-known
+/// EVM blockchain networks. Each method returns a properly configured ChainId with the
+/// "eip155" namespace and the correct chain reference.
+///
+/// This is one example of implementing the KnownNetworkEip155 trait. Other types
+/// (such as token address types) can also implement this trait to provide
+/// per-network instances with better developer experience.
+impl KnownNetworkEip155<ChainId> for ChainId {
+    fn base() -> ChainId {
+        ChainId::new("eip155", "8453")
+    }
+
+    fn base_sepolia() -> ChainId {
+        ChainId::new("eip155", "84532")
+    }
+
+    fn polygon() -> ChainId {
+        ChainId::new("eip155", "137")
+    }
+
+    fn polygon_amoy() -> ChainId {
+        ChainId::new("eip155", "80002")
+    }
+
+    fn avalanche() -> ChainId {
+        ChainId::new("eip155", "43114")
+    }
+
+    fn avalanche_fuji() -> ChainId {
+        ChainId::new("eip155", "43113")
+    }
+
+    fn sei() -> ChainId {
+        ChainId::new("eip155", "1329")
+    }
+
+    fn sei_testnet() -> ChainId {
+        ChainId::new("eip155", "1328")
+    }
+
+    fn xdc() -> ChainId {
+        ChainId::new("eip155", "50")
+    }
+
+    fn xrpl_evm() -> ChainId {
+        ChainId::new("eip155", "1440000")
+    }
+
+    fn peaq() -> ChainId {
+        ChainId::new("eip155", "3338")
+    }
+
+    fn iotex() -> ChainId {
+        ChainId::new("eip155", "4689")
+    }
+
+    fn celo() -> ChainId {
+        ChainId::new("eip155", "42220")
+    }
+
+    fn celo_sepolia() -> ChainId {
+        ChainId::new("eip155", "11142220")
+    }
+}
+
+impl KnownNetworkEip155<Eip155TokenDeployment> for USDC {
+    fn base() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(8453),
+            address: alloy_primitives::address!("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USD Coin".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn base_sepolia() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(84532),
+            address: alloy_primitives::address!("0x036CbD53842c5426634e7929541eC2318f3dCF7e"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn polygon() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(137),
+            address: alloy_primitives::address!("0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn polygon_amoy() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(80002),
+            address: alloy_primitives::address!("0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn avalanche() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(43114),
+            address: alloy_primitives::address!("0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USD Coin".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn avalanche_fuji() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(43113),
+            address: alloy_primitives::address!("0x5425890298aed601595a70AB815c96711a31Bc65"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USD Coin".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn sei() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(1329),
+            address: alloy_primitives::address!("0xe15fC38F6D8c56aF07bbCBe3BAf5708A2Bf42392"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn sei_testnet() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(1328),
+            address: alloy_primitives::address!("0x4fCF1784B31630811181f670Aea7A7bEF803eaED"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn xdc() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(50),
+            address: alloy_primitives::address!("0xfA2958CB79b0491CC627c1557F441eF849Ca8eb1"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn xrpl_evm() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(1440000),
+            address: alloy_primitives::address!("0xDaF4556169c4F3f2231d8ab7BC8772Ddb7D4c84C"),
+            decimals: 6,
+            eip712: None,
+        }
+    }
+
+    fn peaq() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(3338),
+            address: alloy_primitives::address!("0xbbA60da06c2c5424f03f7434542280FCAd453d10"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn iotex() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(4689),
+            address: alloy_primitives::address!("0xcdf79194c6c285077a58da47641d4dbe51f63542"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "Bridged USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn celo() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(42220),
+            address: alloy_primitives::address!("0xcebA9300f2b948710d2653dD7B07f33A8B32118C"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+
+    fn celo_sepolia() -> Eip155TokenDeployment {
+        Eip155TokenDeployment {
+            chain_reference: Eip155ChainReference::new(11142220),
+            address: alloy_primitives::address!("0x01C5C0122039549AD1493B8220cABEdD739BC44E"),
+            decimals: 6,
+            eip712: Some(TokenDeploymentEip712 {
+                name: "USDC".into(),
+                version: "2".into(),
+            }),
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/client.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/client.rs
new file mode 100644
index 0000000..d07e221
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/client.rs
@@ -0,0 +1,289 @@
+//! Client-side payment signing for the V1 EIP-155 "exact" scheme.
+//!
+//! This module provides [`V1Eip155ExactClient`] for signing ERC-3009
+//! `transferWithAuthorization` payments on EVM chains.
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_eip155::v1_eip155_exact::client::V1Eip155ExactClient;
+//! use alloy_signer_local::PrivateKeySigner;
+//!
+//! let signer = PrivateKeySigner::random();
+//! let client = V1Eip155ExactClient::new(signer);
+//! ```
+
+use alloy_primitives::{Address, Bytes, FixedBytes, Signature, U256};
+use alloy_signer_local::PrivateKeySigner;
+use alloy_sol_types::{SolStruct, eip712_domain};
+use async_trait::async_trait;
+use rand::{Rng, rng};
+use std::sync::Arc;
+use x402_types::chain::ChainId;
+use x402_types::proto::PaymentRequired;
+use x402_types::proto::v1::X402Version1;
+use x402_types::scheme::X402SchemeId;
+use x402_types::scheme::client::{
+    PaymentCandidate, PaymentCandidateSigner, X402Error, X402SchemeClient,
+};
+use x402_types::timestamp::UnixTimestamp;
+use x402_types::util::Base64Bytes;
+
+use crate::v1_eip155_exact::{
+    ExactEvmPayload, ExactEvmPayloadAuthorization, ExactScheme, PaymentRequirementsExtra,
+    TransferWithAuthorization, V1Eip155Exact, types,
+};
+
+use crate::chain::Eip155ChainReference;
+
+/// Client for signing V1 EIP-155 exact scheme payments.
+///
+/// This client handles the creation and signing of ERC-3009 `transferWithAuthorization`
+/// payments for EVM chains. It accepts payment requirements from servers and produces
+/// signed payment payloads that can be verified and settled by facilitators.
+///
+/// # Type Parameters
+///
+/// - `S`: The signer type, which must implement [`SignerLike`]
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_eip155::V1Eip155ExactClient;
+/// use alloy_signer_local::PrivateKeySigner;
+///
+/// let signer = PrivateKeySigner::random();
+/// let client = V1Eip155ExactClient::new(signer);
+/// ```
+#[derive(Debug)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct V1Eip155ExactClient<S> {
+    signer: S,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl<S> V1Eip155ExactClient<S> {
+    /// Creates a new V1 EIP-155 exact scheme client with the given signer.
+    pub fn new(signer: S) -> Self {
+        Self { signer }
+    }
+}
+
+impl<S> X402SchemeId for V1Eip155ExactClient<S> {
+    fn namespace(&self) -> &str {
+        V1Eip155Exact.namespace()
+    }
+
+    fn scheme(&self) -> &str {
+        V1Eip155Exact.scheme()
+    }
+}
+
+impl<S> X402SchemeClient for V1Eip155ExactClient<S>
+where
+    S: SignerLike + Clone + Send + Sync + 'static,
+{
+    fn accept(&self, payment_required: &PaymentRequired) -> Vec<PaymentCandidate> {
+        let payment_required = match payment_required {
+            PaymentRequired::V1(payment_required) => payment_required,
+            PaymentRequired::V2(_) => {
+                return vec![];
+            }
+        };
+        payment_required
+            .accepts
+            .iter()
+            .filter_map(|v| {
+                let requirements: types::PaymentRequirements = v.as_concrete()?;
+                let chain_id = ChainId::from_network_name(&requirements.network)?;
+                let chain_reference = Eip155ChainReference::try_from(chain_id.clone()).ok()?;
+                let candidate = PaymentCandidate {
+                    chain_id,
+                    asset: requirements.asset.to_string(),
+                    amount: requirements.max_amount_required,
+                    scheme: self.scheme().to_string(),
+                    x402_version: self.x402_version(),
+                    pay_to: requirements.pay_to.to_string(),
+                    signer: Box::new(PayloadSigner {
+                        signer: self.signer.clone(),
+                        chain_reference,
+                        requirements,
+                    }),
+                };
+                Some(candidate)
+            })
+            .collect::<Vec<_>>()
+    }
+}
+
+/// Shared EIP-712 signing parameters for ERC-3009 authorization.
+/// Used by both v1 and v2 EIP-155 exact scheme clients.
+#[derive(Debug, Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct Eip3009SigningParams {
+    /// The EIP-155 chain ID (numeric)
+    pub chain_id: u64,
+    /// The token contract address (verifying contract for EIP-712)
+    pub asset_address: Address,
+    /// The recipient address for the transfer
+    pub pay_to: Address,
+    /// The amount to transfer
+    pub amount: U256,
+    /// Maximum timeout in seconds for the authorization validity window
+    pub max_timeout_seconds: u64,
+    /// Optional EIP-712 domain name and version override
+    pub extra: Option<PaymentRequirementsExtra>,
+}
+
+/// Signs an ERC-3009 TransferWithAuthorization using EIP-712.
+///
+/// This is the shared signing logic used by both v1 and v2 EIP-155 exact scheme clients.
+/// It constructs the EIP-712 domain, builds the authorization struct with appropriate
+/// timing parameters, and signs the resulting hash.
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub async fn sign_erc3009_authorization<S: SignerLike + Sync>(
+    signer: &S,
+    params: &Eip3009SigningParams,
+) -> Result<ExactEvmPayload, X402Error> {
+    // Extract name/version from extra, defaulting to empty strings
+    let (name, version) = match &params.extra {
+        None => ("".to_string(), "".to_string()),
+        Some(extra) => (extra.name.clone(), extra.version.clone()),
+    };
+
+    // Build EIP-712 domain
+    let domain = eip712_domain! {
+        name: name,
+        version: version,
+        chain_id: params.chain_id,
+        verifying_contract: params.asset_address,
+    };
+
+    // Build authorization with timing
+    let now = UnixTimestamp::now();
+    // valid_after should be in the past (10 minutes ago) to ensure the payment is immediately valid
+    let valid_after_secs = now.as_secs().saturating_sub(10 * 60);
+    let valid_after = UnixTimestamp::from_secs(valid_after_secs);
+    let valid_before = now + params.max_timeout_seconds;
+    let nonce: [u8; 32] = rng().random();
+    let nonce = FixedBytes(nonce);
+
+    let authorization = ExactEvmPayloadAuthorization {
+        from: signer.address(),
+        to: params.pay_to,
+        value: params.amount,
+        valid_after,
+        valid_before,
+        nonce,
+    };
+
+    // Create the EIP-712 struct for signing
+    // IMPORTANT: The values here MUST match the authorization struct exactly,
+    // as the facilitator will reconstruct this struct from the authorization
+    // to verify the signature.
+    let transfer_with_authorization = TransferWithAuthorization {
+        from: authorization.from,
+        to: authorization.to,
+        value: authorization.value,
+        validAfter: U256::from(authorization.valid_after.as_secs()),
+        validBefore: U256::from(authorization.valid_before.as_secs()),
+        nonce: authorization.nonce,
+    };
+
+    let eip712_hash = transfer_with_authorization.eip712_signing_hash(&domain);
+    let signature = signer
+        .sign_hash(&eip712_hash)
+        .await
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+
+    Ok(ExactEvmPayload {
+        signature: Some(Bytes::from(signature.as_bytes().to_vec())),
+        authorization: Some(authorization),
+        permit2: None,
+    })
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+struct PayloadSigner<S> {
+    signer: S,
+    chain_reference: Eip155ChainReference,
+    requirements: types::PaymentRequirements,
+}
+
+#[async_trait]
+impl<S> PaymentCandidateSigner for PayloadSigner<S>
+where
+    S: SignerLike + Sync,
+{
+    async fn sign_payment(&self) -> Result<String, X402Error> {
+        let params = Eip3009SigningParams {
+            chain_id: self.chain_reference.inner(),
+            asset_address: self.requirements.asset,
+            pay_to: self.requirements.pay_to,
+            amount: self.requirements.max_amount_required,
+            max_timeout_seconds: self.requirements.max_timeout_seconds,
+            extra: self.requirements.extra.clone(),
+        };
+
+        let evm_payload = sign_erc3009_authorization(&self.signer, &params).await?;
+
+        // Build the payment payload
+        let payload = types::PaymentPayload {
+            x402_version: X402Version1,
+            scheme: ExactScheme,
+            network: self.requirements.network.clone(),
+            payload: evm_payload,
+        };
+        let json = serde_json::to_vec(&payload)?;
+        let b64 = Base64Bytes::encode(&json);
+
+        Ok(b64.to_string())
+    }
+}
+
+/// A trait that abstracts signing operations, allowing both owned signers and Arc-wrapped signers.
+///
+/// This is necessary because Alloy's `Signer` trait is not implemented for `Arc<T>`,
+/// but users may want to share signers via `Arc` (especially when `PrivateKeySigner` doesn't implement `Clone`).
+///
+/// # Example
+///
+/// ```ignore
+/// use std::sync::Arc;
+/// use alloy_signer_local::PrivateKeySigner;
+/// use x402_rs::scheme::v1_eip155_exact::SignerLike;
+///
+/// let signer: PrivateKeySigner = ...;
+/// let signer = Arc::new(signer);
+/// // Now you can use `signer` anywhere `SignerLike` is expected
+/// ```
+#[async_trait]
+pub trait SignerLike {
+    /// Returns the address of the signer.
+    fn address(&self) -> Address;
+
+    /// Signs the given hash.
+    async fn sign_hash(&self, hash: &FixedBytes<32>) -> Result<Signature, alloy_signer::Error>;
+}
+
+#[async_trait]
+impl SignerLike for PrivateKeySigner {
+    fn address(&self) -> Address {
+        PrivateKeySigner::address(self)
+    }
+
+    async fn sign_hash(&self, hash: &FixedBytes<32>) -> Result<Signature, alloy_signer::Error> {
+        alloy_signer::Signer::sign_hash(self, hash).await
+    }
+}
+
+#[async_trait]
+impl<T: SignerLike + Send + Sync> SignerLike for Arc<T> {
+    fn address(&self) -> Address {
+        (**self).address()
+    }
+
+    async fn sign_hash(&self, hash: &FixedBytes<32>) -> Result<Signature, alloy_signer::Error> {
+        (**self).sign_hash(hash).await
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/facilitator.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/facilitator.rs
new file mode 100644
index 0000000..a8afd51
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/facilitator.rs
@@ -0,0 +1,1428 @@
+//! Facilitator-side payment verification and settlement for V1 EIP-155 exact scheme.
+//!
+//! This module implements the facilitator logic for verifying and settling ERC-3009
+//! payments on EVM chains. It handles:
+//!
+//! - Signature verification (EOA, EIP-1271, EIP-6492)
+//! - Balance and amount validation
+//! - EIP-712 domain construction
+//! - On-chain settlement with gas management
+//! - Smart wallet deployment for counterfactual signatures
+
+use alloy_contract::SolCallBuilder;
+use alloy_primitives::{Address, B256, Bytes, Signature, TxHash, U160, U256, address, hex};
+use alloy_primitives::aliases::U48;
+use alloy_provider::bindings::IMulticall3;
+use alloy_provider::{
+    MULTICALL3_ADDRESS, MulticallError, MulticallItem, PendingTransactionError, Provider,
+};
+use alloy_sol_types::{Eip712Domain, SolCall, SolStruct, SolType, eip712_domain, sol};
+use alloy_transport::TransportError;
+use std::collections::HashMap;
+use x402_types::chain::{ChainId, ChainProviderOps};
+use x402_types::proto;
+use x402_types::proto::{PaymentVerificationError, v1};
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorBuilder, X402SchemeFacilitatorError,
+};
+use x402_types::timestamp::UnixTimestamp;
+
+#[cfg(feature = "telemetry")]
+use tracing::{Instrument, instrument};
+#[cfg(feature = "telemetry")]
+use tracing_core::Level;
+
+use crate::V1Eip155Exact;
+use crate::chain::{
+    Eip155ChainReference, Eip155MetaTransactionProvider, MetaTransaction, MetaTransactionSendError,
+};
+use crate::v1_eip155_exact::{
+    ExactScheme, PaymentRequirementsExtra, TransferWithAuthorization, types,
+};
+use crate::v1_eip155_exact::types::{
+    PermitDetails as PermitDetailsEip712,
+    PermitSingle as PermitSingleEip712,
+};
+
+/// Signature verifier for EIP-6492, EIP-1271, EOA, universally deployed on the supported EVM chains
+/// If absent on a target chain, verification will fail; you should deploy the validator there.
+pub const VALIDATOR_ADDRESS: Address = address!("0xdAcD51A54883eb67D95FAEb2BBfdC4a9a6BD2a3B");
+
+/// Permit2 contract address (canonical CREATE2 deployment).
+pub const PERMIT2_ADDRESS: Address = address!("0x000000000022D473030F116dDEE9F6B43aC78BA3");
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V1Eip155Exact
+where
+    P: Eip155MetaTransactionProvider + ChainProviderOps + Send + Sync + 'static,
+    Eip155ExactError: From<P::Error>,
+{
+    fn build(
+        &self,
+        provider: P,
+        _config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        Ok(Box::new(V1Eip155ExactFacilitator::new(provider)))
+    }
+}
+
+/// Facilitator for V1 EIP-155 exact scheme payments.
+///
+/// This struct implements the [`X402SchemeFacilitator`] trait to provide payment
+/// verification and settlement services for ERC-3009 based payments on EVM chains.
+///
+/// # Type Parameters
+///
+/// - `P`: The provider type, which must implement [`Eip155MetaTransactionProvider`]
+///   and [`ChainProviderOps`]
+pub struct V1Eip155ExactFacilitator<P> {
+    provider: P,
+}
+
+impl<P> V1Eip155ExactFacilitator<P> {
+    /// Creates a new V1 EIP-155 exact scheme facilitator with the given provider.
+    pub fn new(provider: P) -> Self {
+        Self { provider }
+    }
+}
+
+#[async_trait::async_trait]
+impl<P> X402SchemeFacilitator for V1Eip155ExactFacilitator<P>
+where
+    P: Eip155MetaTransactionProvider + ChainProviderOps + Send + Sync,
+    P::Inner: Provider,
+    Eip155ExactError: From<P::Error>,
+{
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError> {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        let payload = &request.payment_payload;
+        let requirements = &request.payment_requirements;
+        let context = assert_valid_payment(
+            self.provider.inner(),
+            self.provider.chain(),
+            payload,
+            requirements,
+        )
+        .await?;
+
+        let payer = match context {
+            PaymentContext::Eip3009 {
+                contract,
+                payment,
+                domain,
+            } => verify_payment(self.provider.inner(), &contract, &payment, &domain).await?,
+            PaymentContext::Permit2 {
+                contract,
+                payment,
+                domain,
+            } => verify_payment_permit2(self.provider.inner(), &contract, &payment, &domain).await?,
+        };
+
+        Ok(v1::VerifyResponse::valid(payer.to_string()).into())
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError> {
+        let request = types::SettleRequest::from_proto(request.clone())?;
+        let payload = &request.payment_payload;
+        let requirements = &request.payment_requirements;
+        let context = assert_valid_payment(
+            self.provider.inner(),
+            self.provider.chain(),
+            payload,
+            requirements,
+        )
+        .await?;
+
+        let (payer, tx_hash) = match context {
+            PaymentContext::Eip3009 {
+                contract,
+                payment,
+                domain,
+            } => (
+                payment.from,
+                settle_payment(&self.provider, &contract, &payment, &domain).await?,
+            ),
+            PaymentContext::Permit2 {
+                contract,
+                payment,
+                domain,
+            } => (
+                payment.owner,
+                settle_payment_permit2(&self.provider, &contract, &payment, &domain).await?,
+            ),
+        };
+        Ok(v1::SettleResponse::Success {
+            payer: payer.to_string(),
+            transaction: tx_hash.to_string(),
+            network: payload.network.clone(),
+        }
+        .into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+        let kinds = {
+            let mut kinds = Vec::with_capacity(1);
+            let network = chain_id.as_network_name();
+            if let Some(network) = network {
+                kinds.push(proto::SupportedPaymentKind {
+                    x402_version: v1::X402Version1.into(),
+                    scheme: ExactScheme.to_string(),
+                    network: network.to_string(),
+                    extra: None,
+                });
+            }
+            kinds
+        };
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+/// A fully specified ERC-3009 authorization payload for EVM settlement.
+#[derive(Debug)]
+pub struct ExactEvmPayment {
+    /// Authorized sender (`from`) â€” EOA or smart wallet.
+    pub from: Address,
+    /// Authorized recipient (`to`).
+    pub to: Address,
+    /// Transfer amount (token units).
+    pub value: U256,
+    /// Not valid before this timestamp (inclusive).
+    pub valid_after: UnixTimestamp,
+    /// Not valid at/after this timestamp (exclusive).
+    pub valid_before: UnixTimestamp,
+    /// Unique 32-byte nonce (prevents replay).
+    pub nonce: B256,
+    /// Raw signature bytes (EIP-1271 or EIP-6492-wrapped).
+    pub signature: Bytes,
+}
+
+#[derive(Debug)]
+pub struct Permit2Payment {
+    /// Permit2 owner authorizing the allowance.
+    pub owner: Address,
+    /// Permit2 spender authorized to transfer.
+    pub spender: Address,
+    /// Token address being authorized.
+    pub token: Address,
+    /// Permitted allowance amount (uint160 bounded).
+    pub amount: U256,
+    /// Permit2 allowance expiration timestamp.
+    pub expiration: u64,
+    /// Permit2 nonce (uint48 bounded).
+    pub nonce: u64,
+    /// Signature deadline timestamp.
+    pub sig_deadline: u64,
+    /// Raw Permit2 signature bytes.
+    pub signature: Bytes,
+    /// Amount to transfer for the settlement.
+    pub transfer_amount: U256,
+}
+
+#[derive(Debug)]
+enum PaymentContext<'a, P: Provider> {
+    Eip3009 {
+        contract: IEIP3009::IEIP3009Instance<&'a P>,
+        payment: ExactEvmPayment,
+        domain: Eip712Domain,
+    },
+    Permit2 {
+        contract: IPermit2::IPermit2Instance<&'a P>,
+        payment: Permit2Payment,
+        domain: Eip712Domain,
+    },
+}
+
+sol!(
+    #[allow(missing_docs)]
+    #[allow(clippy::too_many_arguments)]
+    #[derive(Debug)]
+    #[sol(rpc)]
+    IEIP3009,
+    "abi/IEIP3009.json"
+);
+
+sol!(
+    #[allow(missing_docs)]
+    #[allow(clippy::too_many_arguments)]
+    #[derive(Debug)]
+    #[sol(rpc)]
+    IPermit2,
+    "abi/IPermit2.json"
+);
+
+sol! {
+    #[allow(missing_docs)]
+    #[allow(clippy::too_many_arguments)]
+    #[derive(Debug)]
+    #[sol(rpc)]
+    Validator6492,
+    "abi/Validator6492.json"
+}
+
+/// Runs all preconditions needed for a successful payment:
+/// - Valid scheme, network, and receiver.
+/// - Valid time window (validAfter/validBefore).
+/// - Correct EIP-712 domain construction.
+/// - Sufficient on-chain balance.
+/// - Sufficient value in payload.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err))]
+async fn assert_valid_payment<'a, P: Provider>(
+    provider: &'a P,
+    chain: &Eip155ChainReference,
+    payload: &types::PaymentPayload,
+    requirements: &types::PaymentRequirements,
+) -> Result<PaymentContext<'a, P>, Eip155ExactError> {
+    let chain_id: ChainId = chain.into();
+    let payload_chain_id = ChainId::from_network_name(&payload.network)
+        .ok_or(PaymentVerificationError::UnsupportedChain)?;
+    if payload_chain_id != chain_id {
+        return Err(PaymentVerificationError::ChainIdMismatch.into());
+    }
+    let requirements_chain_id = ChainId::from_network_name(&requirements.network)
+        .ok_or(PaymentVerificationError::UnsupportedChain)?;
+    if requirements_chain_id != chain_id {
+        return Err(PaymentVerificationError::ChainIdMismatch.into());
+    }
+    if let Some(permit2) = payload.payload.permit2.as_ref() {
+        let permit_single = &permit2.permit_single;
+        let details = &permit_single.details;
+
+        if details.token != requirements.asset {
+            return Err(PaymentVerificationError::AssetMismatch.into());
+        }
+        if permit_single.spender != requirements.pay_to {
+            return Err(PaymentVerificationError::RecipientMismatch.into());
+        }
+
+        let sig_deadline = UnixTimestamp::from_secs(permit_single.sig_deadline);
+        let expiration = UnixTimestamp::from_secs(details.expiration);
+        assert_permit2_time(sig_deadline, expiration)?;
+
+        let amount_required = requirements.max_amount_required;
+        assert_enough_value(&details.amount, &amount_required)?;
+
+        let erc20_contract = IEIP3009::new(details.token, provider);
+        assert_enough_balance(&erc20_contract, &permit2.owner, amount_required).await?;
+
+        let domain = assert_permit2_domain(chain);
+        let contract = IPermit2::new(PERMIT2_ADDRESS, provider);
+        let payment = Permit2Payment {
+            owner: permit2.owner,
+            spender: permit_single.spender,
+            token: details.token,
+            amount: details.amount,
+            expiration: details.expiration,
+            nonce: details.nonce,
+            sig_deadline: permit_single.sig_deadline,
+            signature: permit2.signature.clone(),
+            transfer_amount: amount_required,
+        };
+        Ok(PaymentContext::Permit2 {
+            contract,
+            payment,
+            domain,
+        })
+    } else if let Some(authorization) = payload.payload.authorization.as_ref() {
+        if authorization.to != requirements.pay_to {
+            return Err(PaymentVerificationError::RecipientMismatch.into());
+        }
+        let valid_after = authorization.valid_after;
+        let valid_before = authorization.valid_before;
+        assert_time(valid_after, valid_before)?;
+        let asset_address = requirements.asset;
+        let contract = IEIP3009::new(asset_address, provider);
+
+        let domain = assert_domain(chain, &contract, &asset_address, &requirements.extra).await?;
+
+        let amount_required = requirements.max_amount_required;
+        assert_enough_balance(&contract, &authorization.from, amount_required).await?;
+        assert_enough_value(&authorization.value, &amount_required)?;
+
+        let signature = payload.payload.signature.clone().ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat("Missing signature".to_string())
+        })?;
+        let payment = ExactEvmPayment {
+            from: authorization.from,
+            to: authorization.to,
+            value: authorization.value,
+            valid_after: authorization.valid_after,
+            valid_before: authorization.valid_before,
+            nonce: authorization.nonce,
+            signature,
+        };
+
+        Ok(PaymentContext::Eip3009 {
+            contract,
+            payment,
+            domain,
+        })
+    } else {
+        Err(PaymentVerificationError::InvalidFormat(
+            "Missing authorization or permit2 payload".to_string(),
+        )
+        .into())
+    }
+}
+
+/// Validates that the current time is within the `validAfter` and `validBefore` bounds.
+///
+/// Adds a 6-second grace buffer when checking expiration to account for latency.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err))]
+pub fn assert_time(
+    valid_after: UnixTimestamp,
+    valid_before: UnixTimestamp,
+) -> Result<(), PaymentVerificationError> {
+    let now = UnixTimestamp::now();
+    if valid_before < now + 6 {
+        return Err(PaymentVerificationError::Expired);
+    }
+    if valid_after > now {
+        return Err(PaymentVerificationError::Early);
+    }
+    Ok(())
+}
+
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err))]
+pub fn assert_permit2_time(
+    sig_deadline: UnixTimestamp,
+    expiration: UnixTimestamp,
+) -> Result<(), PaymentVerificationError> {
+    let now = UnixTimestamp::now();
+    if sig_deadline < now + 6 {
+        return Err(PaymentVerificationError::Expired);
+    }
+    if expiration < now + 6 {
+        return Err(PaymentVerificationError::Expired);
+    }
+    Ok(())
+}
+
+pub fn assert_permit2_domain(chain: &Eip155ChainReference) -> Eip712Domain {
+    eip712_domain! {
+        name: "Permit2",
+        version: "1",
+        chain_id: chain.inner(),
+        verifying_contract: PERMIT2_ADDRESS,
+    }
+}
+
+fn permit2_amount(amount: U256) -> Result<U160, PaymentVerificationError> {
+    if amount > U256::from(U160::MAX) {
+        return Err(PaymentVerificationError::InvalidFormat(
+            "Permit2 amount exceeds uint160".to_string(),
+        ));
+    }
+    let limbs = amount.as_limbs();
+    Ok(U160::from_limbs([limbs[0], limbs[1], limbs[2]]))
+}
+
+const PERMIT2_U48_MAX: u64 = (1u64 << 48) - 1;
+
+fn permit2_u48(value: u64, field: &str) -> Result<U48, PaymentVerificationError> {
+    if value > PERMIT2_U48_MAX {
+        return Err(PaymentVerificationError::InvalidFormat(format!(
+            "Permit2 {field} exceeds uint48"
+        )));
+    }
+    Ok(U48::from(value))
+}
+
+fn build_permit2_single_eip712(
+    payment: &Permit2Payment,
+) -> Result<PermitSingleEip712, PaymentVerificationError> {
+    let details = PermitDetailsEip712 {
+        token: payment.token,
+        amount: permit2_amount(payment.amount)?,
+        expiration: permit2_u48(payment.expiration, "expiration")?,
+        nonce: permit2_u48(payment.nonce, "nonce")?,
+    };
+    Ok(PermitSingleEip712 {
+        details,
+        spender: payment.spender,
+        sigDeadline: U256::from(payment.sig_deadline),
+    })
+}
+
+fn build_permit2_single_call(
+    payment: &Permit2Payment,
+) -> Result<IPermit2::PermitSingle, PaymentVerificationError> {
+    let details = IPermit2::PermitDetails {
+        token: payment.token,
+        amount: permit2_amount(payment.amount)?,
+        expiration: permit2_u48(payment.expiration, "expiration")?,
+        nonce: permit2_u48(payment.nonce, "nonce")?,
+    };
+    Ok(IPermit2::PermitSingle {
+        details,
+        spender: payment.spender,
+        sigDeadline: U256::from(payment.sig_deadline),
+    })
+}
+
+fn permit2_signature_bytes(signature: &StructuredSignature) -> Bytes {
+    match signature {
+        StructuredSignature::EIP6492 { original, .. } => original.clone(),
+        StructuredSignature::EIP1271(bytes) => bytes.clone(),
+        StructuredSignature::EOA(signature) => Bytes::from(signature.as_bytes().to_vec()),
+    }
+}
+
+/// Constructs the correct EIP-712 domain for signature verification.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err, fields(
+    network = %chain.as_chain_id(),
+    asset = %asset_address
+)))]
+pub async fn assert_domain<P: Provider>(
+    chain: &Eip155ChainReference,
+    token_contract: &IEIP3009::IEIP3009Instance<P>,
+    asset_address: &Address,
+    extra: &Option<PaymentRequirementsExtra>,
+) -> Result<Eip712Domain, Eip155ExactError> {
+    let name = extra.as_ref().map(|extra| extra.name.clone());
+    let name = if let Some(name) = name {
+        name
+    } else {
+        let name_b = token_contract.name();
+        let name_fut = name_b.call().into_future();
+        #[cfg(feature = "telemetry")]
+        let name = name_fut
+            .instrument(tracing::info_span!(
+                "fetch_eip712_name",
+                otel.kind = "client",
+            ))
+            .await?;
+        #[cfg(not(feature = "telemetry"))]
+        let name = name_fut.await?;
+        name
+    };
+    let version = extra.as_ref().map(|extra| extra.version.clone());
+    let version = if let Some(version) = version {
+        version
+    } else {
+        let version_b = token_contract.version();
+        let version_fut = version_b.call().into_future();
+        #[cfg(feature = "telemetry")]
+        let version = version_fut
+            .instrument(tracing::info_span!(
+                "fetch_eip712_version",
+                otel.kind = "client",
+            ))
+            .await?;
+        #[cfg(not(feature = "telemetry"))]
+        let version = version_fut.await?;
+        version
+    };
+    let domain = eip712_domain! {
+        name: name,
+        version: version,
+        chain_id: chain.inner(),
+        verifying_contract: *asset_address,
+    };
+    Ok(domain)
+}
+
+/// Checks if the payer has enough on-chain token balance to meet the `maxAmountRequired`.
+///
+/// Performs an `ERC20.balanceOf()` call using the token contract instance.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err, fields(
+    sender = %sender,
+    max_required = %max_amount_required,
+    token_contract = %ieip3009_token_contract.address()
+)))]
+pub async fn assert_enough_balance<P: Provider>(
+    ieip3009_token_contract: &IEIP3009::IEIP3009Instance<P>,
+    sender: &Address,
+    max_amount_required: U256,
+) -> Result<(), Eip155ExactError> {
+    let balance_of = ieip3009_token_contract.balanceOf(*sender);
+    let balance_fut = balance_of.call().into_future();
+    #[cfg(feature = "telemetry")]
+    let balance = balance_fut
+        .instrument(tracing::info_span!(
+            "fetch_token_balance",
+            token_contract = %ieip3009_token_contract.address(),
+            sender = %sender,
+            otel.kind = "client"
+        ))
+        .await?;
+    #[cfg(not(feature = "telemetry"))]
+    let balance = balance_fut.await?;
+
+    if balance < max_amount_required {
+        Err(PaymentVerificationError::InsufficientFunds.into())
+    } else {
+        Ok(())
+    }
+}
+
+/// Verifies that the declared `value` in the payload is sufficient for the required amount.
+///
+/// This is a static check (not on-chain) that compares two numbers.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err, fields(
+    sent = %sent,
+    max_amount_required = %max_amount_required
+)))]
+pub fn assert_enough_value(
+    sent: &U256,
+    max_amount_required: &U256,
+) -> Result<(), PaymentVerificationError> {
+    if sent < max_amount_required {
+        Err(PaymentVerificationError::InvalidPaymentAmount)
+    } else {
+        Ok(())
+    }
+}
+
+/// Canonical data required to verify a signature.
+#[derive(Debug, Clone)]
+struct SignedMessage {
+    /// Expected signer (an EOA or contract wallet).
+    address: Address,
+    /// 32-byte digest that was signed (typically an EIP-712 hash).
+    hash: B256,
+    /// Structured signature, either EIP-6492 or EIP-1271.
+    signature: StructuredSignature,
+}
+
+impl SignedMessage {
+    /// Construct a [`SignedMessage`] from an [`ExactEvmPayment`] and its
+    /// corresponding [`Eip712Domain`].
+    ///
+    /// This helper ties together:
+    /// - The **payment intent** (an ERC-3009 `TransferWithAuthorization` struct),
+    /// - The **EIP-712 domain** used for signing,
+    /// - And the raw signature bytes attached to the payment.
+    ///
+    /// Steps performed:
+    /// 1. Build an in-memory [`TransferWithAuthorization`] struct from the
+    ///    `ExactEvmPayment` fields (`from`, `to`, `value`, validity window, `nonce`).
+    /// 2. Compute the **EIP-712 struct hash** for that transfer under the given
+    ///    `domain`. This becomes the `hash` field of the signed message.
+    /// 3. Parse the raw signature bytes into a [`StructuredSignature`], which
+    ///    distinguishes between:
+    ///    - EIP-1271 (plain signature), and
+    ///    - EIP-6492 (counterfactual signature wrapper).
+    /// 4. Assemble all parts into a [`SignedMessage`] and return it.
+    pub fn extract(
+        payment: &ExactEvmPayment,
+        domain: &Eip712Domain,
+    ) -> Result<Self, StructuredSignatureFormatError> {
+        let transfer_with_authorization = TransferWithAuthorization {
+            from: payment.from,
+            to: payment.to,
+            value: payment.value,
+            validAfter: U256::from(payment.valid_after.as_secs()),
+            validBefore: U256::from(payment.valid_before.as_secs()),
+            nonce: payment.nonce,
+        };
+        let eip712_hash = transfer_with_authorization.eip712_signing_hash(domain);
+        let structured_signature: StructuredSignature = StructuredSignature::try_from_bytes(
+            payment.signature.clone(),
+            payment.from,
+            &eip712_hash,
+        )?;
+        let signed_message = Self {
+            address: payment.from,
+            hash: eip712_hash,
+            signature: structured_signature,
+        };
+        Ok(signed_message)
+    }
+
+    pub fn extract_permit2(
+        payment: &Permit2Payment,
+        domain: &Eip712Domain,
+    ) -> Result<Self, Eip155ExactError> {
+        let permit_single = build_permit2_single_eip712(payment)?;
+        let eip712_hash = permit_single.eip712_signing_hash(domain);
+        let structured_signature: StructuredSignature = StructuredSignature::try_from_bytes(
+            payment.signature.clone(),
+            payment.owner,
+            &eip712_hash,
+        )?;
+        let signed_message = Self {
+            address: payment.owner,
+            hash: eip712_hash,
+            signature: structured_signature,
+        };
+        Ok(signed_message)
+    }
+}
+
+/// A structured representation of an Ethereum signature.
+///
+/// This enum normalizes two supported cases:
+///
+/// - **EIP-6492 wrapped signatures**: used for counterfactual contract wallets.
+///   They include deployment metadata (factory + calldata) plus the inner
+///   signature that the wallet contract will validate after deployment.
+/// - **EIP-1271 signatures**: plain contract (or EOA-style) signatures.
+#[derive(Debug, Clone)]
+enum StructuredSignature {
+    /// An EIP-6492 wrapped signature.
+    EIP6492 {
+        /// Factory contract that can deploy the wallet deterministically
+        factory: Address,
+        /// Calldata to invoke on the factory (often a CREATE2 deployment).
+        factory_calldata: Bytes,
+        /// Inner signature for the wallet itself, probably EIP-1271.
+        inner: Bytes,
+        /// Full original bytes including the 6492 wrapper and magic bytes suffix.
+        original: Bytes,
+    },
+    /// Normalized EOA signature.
+    #[allow(clippy::upper_case_acronyms)]
+    EOA(Signature),
+    /// A plain EIP-1271 or EOA signature (no 6492 wrappers).
+    EIP1271(Bytes),
+}
+
+/// The fixed 32-byte magic suffix defined by [EIP-6492](https://eips.ethereum.org/EIPS/eip-6492).
+///
+/// Any signature ending with this constant is treated as a 6492-wrapped
+/// signature; the preceding bytes are ABI-decoded as `(address factory, bytes factoryCalldata, bytes innerSig)`.
+const EIP6492_MAGIC_SUFFIX: [u8; 32] =
+    hex!("6492649264926492649264926492649264926492649264926492649264926492");
+
+sol! {
+    /// Solidity-compatible struct for decoding the prefix of an EIP-6492 signature.
+    ///
+    /// Matches the tuple `(address factory, bytes factoryCalldata, bytes innerSig)`.
+    #[derive(Debug)]
+    struct Sig6492 {
+        address factory;
+        bytes   factoryCalldata;
+        bytes   innerSig;
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+pub enum StructuredSignatureFormatError {
+    #[error(transparent)]
+    InvalidEIP6492Format(alloy_sol_types::Error),
+}
+
+impl StructuredSignature {
+    pub fn try_from_bytes(
+        bytes: Bytes,
+        expected_signer: Address,
+        prehash: &B256,
+    ) -> Result<Self, StructuredSignatureFormatError> {
+        let is_eip6492 = bytes.len() >= 32 && bytes[bytes.len() - 32..] == EIP6492_MAGIC_SUFFIX;
+        let signature = if is_eip6492 {
+            let body = &bytes[..bytes.len() - 32];
+            let sig6492 = Sig6492::abi_decode_params(body)
+                .map_err(StructuredSignatureFormatError::InvalidEIP6492Format)?;
+            StructuredSignature::EIP6492 {
+                factory: sig6492.factory,
+                factory_calldata: sig6492.factoryCalldata,
+                inner: sig6492.innerSig,
+                original: bytes,
+            }
+        } else {
+            // Let's see if it is a EOA signature
+            let eoa_signature = if bytes.len() == 65 {
+                Signature::from_raw(&bytes).ok().map(|s| s.normalized_s())
+            } else if bytes.len() == 64 {
+                Some(Signature::from_erc2098(&bytes).normalized_s())
+            } else {
+                None
+            };
+            match eoa_signature {
+                None => StructuredSignature::EIP1271(bytes),
+                Some(s) => {
+                    let is_expected_signer = s
+                        .recover_address_from_prehash(prehash)
+                        .ok()
+                        .map(|r| r == expected_signer)
+                        .unwrap_or(false);
+                    if is_expected_signer {
+                        StructuredSignature::EOA(s)
+                    } else {
+                        StructuredSignature::EIP1271(bytes)
+                    }
+                }
+            }
+        };
+        Ok(signature)
+    }
+}
+
+impl TryFrom<Bytes> for StructuredSignature {
+    type Error = StructuredSignatureFormatError;
+
+    /// Parse raw signature bytes into a `StructuredSignature`.
+    ///
+    /// Rules:
+    /// - If the last 32 bytes equal [`EIP6492_MAGIC_SUFFIX`], the prefix is
+    ///   decoded as a [`Sig6492`] struct and returned as
+    ///   [`StructuredSignature::EIP6492`].
+    /// - Otherwise, the bytes are returned as [`StructuredSignature::EIP1271`].
+    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {
+        let is_eip6492 = bytes.len() >= 32 && bytes[bytes.len() - 32..] == EIP6492_MAGIC_SUFFIX;
+        let signature = if is_eip6492 {
+            let body = &bytes[..bytes.len() - 32];
+            let sig6492 = Sig6492::abi_decode_params(body)
+                .map_err(StructuredSignatureFormatError::InvalidEIP6492Format)?;
+            StructuredSignature::EIP6492 {
+                factory: sig6492.factory,
+                factory_calldata: sig6492.factoryCalldata,
+                inner: sig6492.innerSig,
+                original: bytes,
+            }
+        } else {
+            StructuredSignature::EIP1271(bytes)
+        };
+        Ok(signature)
+    }
+}
+
+pub struct TransferWithAuthorization0Call<P>(
+    pub TransferWithAuthorizationCall<P, IEIP3009::transferWithAuthorization_0Call, Bytes>,
+);
+
+impl<'a, P: Provider> TransferWithAuthorization0Call<&'a P> {
+    /// Constructs a full `transferWithAuthorization` call for a verified payment payload.
+    ///
+    /// This function prepares the transaction builder with gas pricing adapted to the network's
+    /// capabilities (EIP-1559 or legacy) and packages it together with signature metadata
+    /// into a [`TransferWithAuthorization0Call`] structure.
+    ///
+    /// This function does not perform any validation â€” it assumes inputs are already checked.
+    pub fn new(
+        contract: &'a IEIP3009::IEIP3009Instance<P>,
+        payment: &ExactEvmPayment,
+        signature: Bytes,
+    ) -> Self {
+        let from = payment.from;
+        let to = payment.to;
+        let value = payment.value;
+        let valid_after = U256::from(payment.valid_after.as_secs());
+        let valid_before = U256::from(payment.valid_before.as_secs());
+        let nonce = payment.nonce;
+        let tx = contract.transferWithAuthorization_0(
+            from,
+            to,
+            value,
+            valid_after,
+            valid_before,
+            nonce,
+            signature.clone(),
+        );
+        TransferWithAuthorization0Call(TransferWithAuthorizationCall {
+            tx,
+            from,
+            to,
+            value,
+            valid_after,
+            valid_before,
+            nonce,
+            signature,
+            contract_address: *contract.address(),
+        })
+    }
+}
+
+pub struct TransferWithAuthorization1Call<P>(
+    pub TransferWithAuthorizationCall<P, IEIP3009::transferWithAuthorization_1Call, Signature>,
+);
+
+impl<'a, P: Provider> TransferWithAuthorization1Call<&'a P> {
+    /// Constructs a full `transferWithAuthorization` call for a verified payment payload
+    /// using split signature components (v, r, s).
+    ///
+    /// This function prepares the transaction builder with gas pricing adapted to the network's
+    /// capabilities (EIP-1559 or legacy) and packages it together with signature metadata
+    /// into a [`TransferWithAuthorization1Call`] structure.
+    ///
+    /// This function does not perform any validation â€” it assumes inputs are already checked.
+    pub fn new(
+        contract: &'a IEIP3009::IEIP3009Instance<P>,
+        payment: &ExactEvmPayment,
+        signature: Signature,
+    ) -> Self {
+        let from = payment.from;
+        let to = payment.to;
+        let value = payment.value;
+        let valid_after = U256::from(payment.valid_after.as_secs());
+        let valid_before = U256::from(payment.valid_before.as_secs());
+        let nonce = payment.nonce;
+        let v = 27 + (signature.v() as u8);
+        let r = B256::from(signature.r());
+        let s = B256::from(signature.s());
+        let tx = contract.transferWithAuthorization_1(
+            from,
+            to,
+            value,
+            valid_after,
+            valid_before,
+            nonce,
+            v,
+            r,
+            s,
+        );
+        TransferWithAuthorization1Call(TransferWithAuthorizationCall {
+            tx,
+            from,
+            to,
+            value,
+            valid_after,
+            valid_before,
+            nonce,
+            signature,
+            contract_address: *contract.address(),
+        })
+    }
+}
+
+/// A prepared call to `transferWithAuthorization` (ERC-3009) including all derived fields.
+///
+/// This struct wraps the assembled call builder, making it reusable across verification
+/// (`.call()`) and settlement (`.send()`) flows, along with context useful for tracing/logging.
+pub struct TransferWithAuthorizationCall<P, TCall, TSignature> {
+    /// The prepared call builder that can be `.call()`ed or `.send()`ed.
+    pub tx: SolCallBuilder<P, TCall>,
+    /// The sender (`from`) address for the authorization.
+    pub from: Address,
+    /// The recipient (`to`) address for the authorization.
+    pub to: Address,
+    /// The amount to transfer (value).
+    pub value: U256,
+    /// Start of the validity window (inclusive).
+    pub valid_after: U256,
+    /// End of the validity window (exclusive).
+    pub valid_before: U256,
+    /// 32-byte authorization nonce (prevents replay).
+    pub nonce: B256,
+    /// EIP-712 signature for the transfer authorization.
+    pub signature: TSignature,
+    /// Address of the token contract used for this transfer.
+    pub contract_address: Address,
+}
+
+/// Check whether contract code is present at `address`.
+///
+/// Uses `eth_getCode` against this provider. This is useful after a counterfactual
+/// deployment to confirm visibility on the sending RPC before submitting a
+/// follow-up transaction.
+async fn is_contract_deployed<P: Provider>(
+    provider: &P,
+    address: &Address,
+) -> Result<bool, TransportError> {
+    let bytes_fut = provider.get_code_at(*address).into_future();
+    #[cfg(feature = "telemetry")]
+    let bytes = bytes_fut
+        .instrument(tracing::info_span!("get_code_at",
+            address = %address,
+            otel.kind = "client",
+        ))
+        .await?;
+    #[cfg(not(feature = "telemetry"))]
+    let bytes = bytes_fut.await?;
+    Ok(!bytes.is_empty())
+}
+
+pub async fn verify_payment<P: Provider>(
+    provider: &P,
+    contract: &IEIP3009::IEIP3009Instance<&P>,
+    payment: &ExactEvmPayment,
+    eip712_domain: &Eip712Domain,
+) -> Result<Address, Eip155ExactError> {
+    let signed_message = SignedMessage::extract(payment, eip712_domain)?;
+
+    let payer = signed_message.address;
+    let hash = signed_message.hash;
+    match signed_message.signature {
+        StructuredSignature::EIP6492 {
+            factory: _,
+            factory_calldata: _,
+            inner,
+            original,
+        } => {
+            // Prepare the call to validate EIP-6492 signature
+            let validator6492 = Validator6492::new(VALIDATOR_ADDRESS, &provider);
+            let is_valid_signature_call =
+                validator6492.isValidSigWithSideEffects(payer, hash, original);
+            // Prepare the call to simulate transfer the funds
+            let transfer_call = TransferWithAuthorization0Call::new(contract, payment, inner);
+            let transfer_call = transfer_call.0;
+            // Execute both calls in a single transaction simulation to accommodate for possible smart wallet creation
+            let aggregate3 = provider
+                .multicall()
+                .add(is_valid_signature_call)
+                .add(transfer_call.tx);
+            let aggregate3_call = aggregate3.aggregate3();
+            #[cfg(feature = "telemetry")]
+            let (is_valid_signature_result, transfer_result) = aggregate3_call
+                .instrument(tracing::info_span!("call_transferWithAuthorization_0",
+                        from = %transfer_call.from,
+                        to = %transfer_call.to,
+                        value = %transfer_call.value,
+                        valid_after = %transfer_call.valid_after,
+                        valid_before = %transfer_call.valid_before,
+                        nonce = %transfer_call.nonce,
+                        signature = %transfer_call.signature,
+                        token_contract = %transfer_call.contract_address,
+                        otel.kind = "client",
+                ))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            let (is_valid_signature_result, transfer_result) = aggregate3_call.await?;
+            let is_valid_signature_result = is_valid_signature_result
+                .map_err(|e| PaymentVerificationError::InvalidSignature(e.to_string()))?;
+            if !is_valid_signature_result {
+                return Err(PaymentVerificationError::InvalidSignature(
+                    "Chain reported signature to be invalid".to_string(),
+                )
+                .into());
+            }
+            transfer_result
+                .map_err(|e| PaymentVerificationError::TransactionSimulation(e.to_string()))?;
+        }
+        StructuredSignature::EIP1271(signature) => {
+            // It is EIP-1271 signature, which we can pass to the transfer simulation
+            let transfer_call = TransferWithAuthorization0Call::new(contract, payment, signature);
+            let transfer_call = transfer_call.0;
+            let transfer_call_fut = transfer_call.tx.call().into_future();
+            #[cfg(feature = "telemetry")]
+            transfer_call_fut
+                .instrument(tracing::info_span!("call_transferWithAuthorization_0",
+                        from = %transfer_call.from,
+                        to = %transfer_call.to,
+                        value = %transfer_call.value,
+                        valid_after = %transfer_call.valid_after,
+                        valid_before = %transfer_call.valid_before,
+                        nonce = %transfer_call.nonce,
+                        signature = %transfer_call.signature,
+                        token_contract = %transfer_call.contract_address,
+                        otel.kind = "client",
+                ))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            transfer_call_fut.await?;
+        }
+        StructuredSignature::EOA(signature) => {
+            // It is EOA signature, which we can pass to the transfer simulation of (r,s,v)-based transferWithAuthorization function
+            let transfer_call = TransferWithAuthorization1Call::new(contract, payment, signature);
+            let transfer_call = transfer_call.0;
+            let transfer_call_fut = transfer_call.tx.call().into_future();
+            #[cfg(feature = "telemetry")]
+            transfer_call_fut
+                .instrument(tracing::info_span!("call_transferWithAuthorization_1",
+                        from = %transfer_call.from,
+                        to = %transfer_call.to,
+                        value = %transfer_call.value,
+                        valid_after = %transfer_call.valid_after,
+                        valid_before = %transfer_call.valid_before,
+                        nonce = %transfer_call.nonce,
+                        signature = %transfer_call.signature,
+                        token_contract = %transfer_call.contract_address,
+                        otel.kind = "client",
+                ))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            transfer_call_fut.await?;
+        }
+    }
+
+    Ok(payer)
+}
+
+pub async fn verify_payment_permit2<P: Provider>(
+    provider: &P,
+    contract: &IPermit2::IPermit2Instance<&P>,
+    payment: &Permit2Payment,
+    eip712_domain: &Eip712Domain,
+) -> Result<Address, Eip155ExactError> {
+    let _ = eip712_domain;
+    let payer = payment.owner;
+    let signature_bytes = payment.signature.clone();
+    let permit_single = build_permit2_single_call(payment)?;
+    let transfer_amount = permit2_amount(payment.transfer_amount)?;
+
+    let permit_call = contract.permit(payment.owner, permit_single, signature_bytes);
+    let transfer_call =
+        contract.transferFrom(payment.owner, payment.spender, transfer_amount, payment.token);
+    let aggregate3 = provider.multicall().add(permit_call).add(transfer_call);
+    let aggregate3_call = aggregate3.aggregate3();
+
+    #[cfg(feature = "telemetry")]
+    let (permit_result, transfer_result) = aggregate3_call
+        .instrument(tracing::info_span!(
+            "call_permit2_permit_and_transfer",
+            owner = %payment.owner,
+            spender = %payment.spender,
+            token = %payment.token,
+            transfer_amount = %payment.transfer_amount,
+            otel.kind = "client",
+        ))
+        .await?;
+    #[cfg(not(feature = "telemetry"))]
+    let (permit_result, transfer_result) = aggregate3_call.await?;
+
+    permit_result
+        .map_err(|e| PaymentVerificationError::InvalidSignature(e.to_string()))?;
+    transfer_result
+        .map_err(|e| PaymentVerificationError::TransactionSimulation(e.to_string()))?;
+
+    Ok(payer)
+}
+
+pub async fn settle_payment<P, E>(
+    provider: &P,
+    contract: &IEIP3009::IEIP3009Instance<&P::Inner>,
+    payment: &ExactEvmPayment,
+    eip712_domain: &Eip712Domain,
+) -> Result<TxHash, Eip155ExactError>
+where
+    P: Eip155MetaTransactionProvider<Error = E>,
+    Eip155ExactError: From<E>,
+{
+    let signed_message = SignedMessage::extract(payment, eip712_domain)?;
+    let payer = payment.from;
+    let receipt = match signed_message.signature {
+        StructuredSignature::EIP6492 {
+            factory,
+            factory_calldata,
+            inner,
+            original: _,
+        } => {
+            let is_contract_deployed = is_contract_deployed(provider.inner(), &payer).await?;
+            let transfer_call = TransferWithAuthorization0Call::new(contract, payment, inner);
+            let transfer_call = transfer_call.0;
+            if is_contract_deployed {
+                // transferWithAuthorization with inner signature
+                let tx_fut = Eip155MetaTransactionProvider::send_transaction(
+                    provider,
+                    MetaTransaction {
+                        to: transfer_call.tx.target(),
+                        calldata: transfer_call.tx.calldata().clone(),
+                        confirmations: 1,
+                    },
+                );
+                #[cfg(feature = "telemetry")]
+                let receipt = tx_fut
+                    .instrument(tracing::info_span!("call_transferWithAuthorization_0",
+                        from = %transfer_call.from,
+                        to = %transfer_call.to,
+                        value = %transfer_call.value,
+                        valid_after = %transfer_call.valid_after,
+                        valid_before = %transfer_call.valid_before,
+                        nonce = %transfer_call.nonce,
+                        signature = %transfer_call.signature,
+                        token_contract = %transfer_call.contract_address,
+                        sig_kind="EIP6492.deployed",
+                        otel.kind = "client",
+                    ))
+                    .await?;
+                #[cfg(not(feature = "telemetry"))]
+                let receipt = tx_fut.await?;
+                receipt
+            } else {
+                // deploy the smart wallet, and transferWithAuthorization with inner signature
+                let deployment_call = IMulticall3::Call3 {
+                    allowFailure: true,
+                    target: factory,
+                    callData: factory_calldata,
+                };
+                let transfer_with_authorization_call = IMulticall3::Call3 {
+                    allowFailure: false,
+                    target: transfer_call.tx.target(),
+                    callData: transfer_call.tx.calldata().clone(),
+                };
+                let aggregate_call = IMulticall3::aggregate3Call {
+                    calls: vec![deployment_call, transfer_with_authorization_call],
+                };
+                let tx_fut = Eip155MetaTransactionProvider::send_transaction(
+                    provider,
+                    MetaTransaction {
+                        to: MULTICALL3_ADDRESS,
+                        calldata: aggregate_call.abi_encode().into(),
+                        confirmations: 1,
+                    },
+                );
+                #[cfg(feature = "telemetry")]
+                let receipt = tx_fut
+                    .instrument(tracing::info_span!("call_transferWithAuthorization_0",
+                        from = %transfer_call.from,
+                        to = %transfer_call.to,
+                        value = %transfer_call.value,
+                        valid_after = %transfer_call.valid_after,
+                        valid_before = %transfer_call.valid_before,
+                        nonce = %transfer_call.nonce,
+                        signature = %transfer_call.signature,
+                        token_contract = %transfer_call.contract_address,
+                        sig_kind="EIP6492.counterfactual",
+                        otel.kind = "client",
+                    ))
+                    .await?;
+                #[cfg(not(feature = "telemetry"))]
+                let receipt = tx_fut.await?;
+                receipt
+            }
+        }
+        StructuredSignature::EIP1271(eip1271_signature) => {
+            let transfer_call =
+                TransferWithAuthorization0Call::new(contract, payment, eip1271_signature);
+            let transfer_call = transfer_call.0;
+            // transferWithAuthorization with eip1271 signature
+            let tx_fut = Eip155MetaTransactionProvider::send_transaction(
+                provider,
+                MetaTransaction {
+                    to: transfer_call.tx.target(),
+                    calldata: transfer_call.tx.calldata().clone(),
+                    confirmations: 1,
+                },
+            );
+            #[cfg(feature = "telemetry")]
+            let receipt = tx_fut
+                .instrument(tracing::info_span!("call_transferWithAuthorization_0",
+                    from = %transfer_call.from,
+                    to = %transfer_call.to,
+                    value = %transfer_call.value,
+                    valid_after = %transfer_call.valid_after,
+                    valid_before = %transfer_call.valid_before,
+                    nonce = %transfer_call.nonce,
+                    signature = %transfer_call.signature,
+                    token_contract = %transfer_call.contract_address,
+                    sig_kind="EIP1271",
+                    otel.kind = "client",
+                ))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            let receipt = tx_fut.await?;
+            receipt
+        }
+        StructuredSignature::EOA(signature) => {
+            let transfer_call = TransferWithAuthorization1Call::new(contract, payment, signature);
+            let transfer_call = transfer_call.0;
+            // transferWithAuthorization with EOA signature
+            let tx_fut = Eip155MetaTransactionProvider::send_transaction(
+                provider,
+                MetaTransaction {
+                    to: transfer_call.tx.target(),
+                    calldata: transfer_call.tx.calldata().clone(),
+                    confirmations: 1,
+                },
+            );
+            #[cfg(feature = "telemetry")]
+            let receipt = tx_fut
+                .instrument(tracing::info_span!("call_transferWithAuthorization_1",
+                    from = %transfer_call.from,
+                    to = %transfer_call.to,
+                    value = %transfer_call.value,
+                    valid_after = %transfer_call.valid_after,
+                    valid_before = %transfer_call.valid_before,
+                    nonce = %transfer_call.nonce,
+                    signature = %transfer_call.signature,
+                    token_contract = %transfer_call.contract_address,
+                    sig_kind="EOA",
+                    otel.kind = "client",
+                ))
+                .await?;
+            #[cfg(not(feature = "telemetry"))]
+            let receipt = tx_fut.await?;
+            receipt
+        }
+    };
+    let success = receipt.status();
+    if success {
+        #[cfg(feature = "telemetry")]
+        tracing::event!(Level::INFO,
+            status = "ok",
+            tx = %receipt.transaction_hash,
+            "transferWithAuthorization_0 succeeded"
+        );
+        Ok(receipt.transaction_hash)
+    } else {
+        #[cfg(feature = "telemetry")]
+        tracing::event!(
+            Level::WARN,
+            status = "failed",
+            tx = %receipt.transaction_hash,
+            "transferWithAuthorization_0 failed"
+        );
+        Err(Eip155ExactError::TransactionReverted(
+            receipt.transaction_hash,
+        ))
+    }
+}
+
+pub async fn settle_payment_permit2<P, E>(
+    provider: &P,
+    contract: &IPermit2::IPermit2Instance<&P::Inner>,
+    payment: &Permit2Payment,
+    eip712_domain: &Eip712Domain,
+) -> Result<TxHash, Eip155ExactError>
+where
+    P: Eip155MetaTransactionProvider<Error = E>,
+    Eip155ExactError: From<E>,
+{
+    let _ = eip712_domain;
+    tracing::info!("[DEBUG] settle_payment_permit2 START: owner={}, spender={}, token={}, amount={}", 
+        payment.owner, payment.spender, payment.token, payment.amount);
+    
+    let signature_bytes = payment.signature.clone();
+    let permit_single = build_permit2_single_call(payment)?;
+    let transfer_amount = permit2_amount(payment.transfer_amount)?;
+
+    tracing::info!("[DEBUG] calling permit() on Permit2 contract...");
+    let permit_tx = contract.permit(payment.owner, permit_single, signature_bytes);
+    let permit_tx_fut = Eip155MetaTransactionProvider::send_transaction(
+        provider,
+        MetaTransaction {
+            to: permit_tx.target(),
+            calldata: permit_tx.calldata().clone(),
+            confirmations: 1,
+        },
+    );
+    #[cfg(feature = "telemetry")]
+    let permit_receipt = permit_tx_fut
+        .instrument(tracing::info_span!(
+            "call_permit2_permit",
+            owner = %payment.owner,
+            spender = %payment.spender,
+            token = %payment.token,
+            amount = %payment.amount,
+            otel.kind = "client",
+        ))
+        .await?;
+    #[cfg(not(feature = "telemetry"))]
+    let permit_receipt = permit_tx_fut.await?;
+
+    tracing::info!("[DEBUG] permit() completed, status={}", permit_receipt.status());
+    if !permit_receipt.status() {
+        tracing::error!("[DEBUG] permit() REVERTED!");
+        return Err(Eip155ExactError::TransactionReverted(
+            permit_receipt.transaction_hash,
+        ));
+    }
+
+    tracing::info!("[DEBUG] calling transferFrom() on Permit2 contract...");
+    let transfer_tx =
+        contract.transferFrom(payment.owner, payment.spender, transfer_amount, payment.token);
+    let transfer_tx_fut = Eip155MetaTransactionProvider::send_transaction(
+        provider,
+        MetaTransaction {
+            to: transfer_tx.target(),
+            calldata: transfer_tx.calldata().clone(),
+            confirmations: 1,
+        },
+    );
+    #[cfg(feature = "telemetry")]
+    let transfer_receipt = transfer_tx_fut
+        .instrument(tracing::info_span!(
+            "call_permit2_transferFrom",
+            owner = %payment.owner,
+            to = %payment.spender,
+            token = %payment.token,
+            amount = %payment.transfer_amount,
+            otel.kind = "client",
+        ))
+        .await?;
+    #[cfg(not(feature = "telemetry"))]
+    let transfer_receipt = transfer_tx_fut.await?;
+
+    tracing::info!("[DEBUG] transferFrom() completed, status={}", transfer_receipt.status());
+    if transfer_receipt.status() {
+        tracing::info!("[DEBUG] settle_payment_permit2 SUCCESS, tx={}", transfer_receipt.transaction_hash);
+        Ok(transfer_receipt.transaction_hash)
+    } else {
+        tracing::error!("[DEBUG] transferFrom() REVERTED!");
+        Err(Eip155ExactError::TransactionReverted(
+            transfer_receipt.transaction_hash,
+        ))
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+pub enum Eip155ExactError {
+    #[error(transparent)]
+    Transport(#[from] TransportError),
+    #[error(transparent)]
+    PendingTransaction(#[from] PendingTransactionError),
+    #[error("Transaction {0} reverted")]
+    TransactionReverted(TxHash),
+    #[error("Contract call failed: {0}")]
+    ContractCall(String),
+    #[error(transparent)]
+    PaymentVerification(#[from] PaymentVerificationError),
+}
+
+impl From<Eip155ExactError> for X402SchemeFacilitatorError {
+    fn from(value: Eip155ExactError) -> Self {
+        match value {
+            Eip155ExactError::Transport(_) => Self::OnchainFailure(value.to_string()),
+            Eip155ExactError::PendingTransaction(_) => Self::OnchainFailure(value.to_string()),
+            Eip155ExactError::TransactionReverted(_) => Self::OnchainFailure(value.to_string()),
+            Eip155ExactError::ContractCall(_) => Self::OnchainFailure(value.to_string()),
+            Eip155ExactError::PaymentVerification(e) => Self::PaymentVerification(e),
+        }
+    }
+}
+
+impl From<StructuredSignatureFormatError> for Eip155ExactError {
+    fn from(e: StructuredSignatureFormatError) -> Self {
+        Self::PaymentVerification(PaymentVerificationError::InvalidSignature(e.to_string()))
+    }
+}
+
+impl From<MetaTransactionSendError> for Eip155ExactError {
+    fn from(e: MetaTransactionSendError) -> Self {
+        match e {
+            MetaTransactionSendError::Transport(e) => Self::Transport(e),
+            MetaTransactionSendError::PendingTransaction(e) => Self::PendingTransaction(e),
+            MetaTransactionSendError::Custom(e) => Self::ContractCall(e),
+        }
+    }
+}
+
+impl From<MulticallError> for Eip155ExactError {
+    fn from(e: MulticallError) -> Self {
+        match e {
+            MulticallError::ValueTx => Self::PaymentVerification(
+                PaymentVerificationError::TransactionSimulation(e.to_string()),
+            ),
+            MulticallError::DecodeError(_) => Self::PaymentVerification(
+                PaymentVerificationError::TransactionSimulation(e.to_string()),
+            ),
+            MulticallError::NoReturnData => Self::PaymentVerification(
+                PaymentVerificationError::TransactionSimulation(e.to_string()),
+            ),
+            MulticallError::CallFailed(_) => Self::PaymentVerification(
+                PaymentVerificationError::TransactionSimulation(e.to_string()),
+            ),
+            MulticallError::TransportError(transport_error) => Self::Transport(transport_error),
+        }
+    }
+}
+
+impl From<alloy_contract::Error> for Eip155ExactError {
+    fn from(e: alloy_contract::Error) -> Self {
+        match e {
+            alloy_contract::Error::UnknownFunction(_) => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::UnknownSelector(_) => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::NotADeploymentTransaction => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::ContractNotDeployed => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::ZeroData(_, _) => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::AbiError(_) => Self::ContractCall(e.to_string()),
+            alloy_contract::Error::TransportError(e) => Self::Transport(e),
+            alloy_contract::Error::PendingTransactionError(e) => Self::PendingTransaction(e),
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/mod.rs
new file mode 100644
index 0000000..97b817c
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/mod.rs
@@ -0,0 +1,78 @@
+//! V1 EIP-155 "exact" payment scheme implementation.
+//!
+//! This module implements the "exact" payment scheme for EVM chains using
+//! the V1 x402 protocol. It uses ERC-3009 `transferWithAuthorization` for
+//! gasless token transfers.
+//!
+//! # Features
+//!
+//! - EIP-712 typed data signing for payment authorization
+//! - EIP-6492 support for counterfactual smart wallet signatures
+//! - EIP-1271 support for deployed smart wallet signatures
+//! - EOA signature support with split (v, r, s) components
+//! - On-chain balance verification before settlement
+//!
+//! # Signature Handling
+//!
+//! The facilitator intelligently dispatches to different `transferWithAuthorization`
+//! contract functions based on the signature format provided:
+//!
+//! - **EOA signatures (64-65 bytes)**: Parsed as (r, s, v) components and dispatched to
+//!   `transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)`
+//!   (the standard EIP-3009 function signature).
+//!
+//! - **EIP-1271 signatures (any other length)**: Passed as full signature bytes to
+//!   `transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,bytes)`
+//!   (a non-standard variant that accepts arbitrary signature bytes for contract wallets).
+//!
+//! - **EIP-6492 signatures**: Detected by the 32-byte magic suffix and validated via
+//!   the universal EIP-6492 validator contract before settlement.
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_eip155::v1_eip155_exact::V1Eip155Exact;
+//! use x402_chain_eip155::networks::{KnownNetworkEip155, USDC};
+//!
+//! // Create a price tag for 1 USDC on Base
+//! let usdc = USDC::base();
+//! let price = V1Eip155Exact::price_tag(
+//!     "0x1234...",  // pay_to address
+//!     usdc.amount(1_000_000u64.into()),  // 1 USDC
+//! );
+//! ```
+
+use x402_types::scheme::X402SchemeId;
+
+#[cfg(feature = "server")]
+pub mod server;
+#[cfg(feature = "server")]
+#[allow(unused_imports)]
+pub use server::*;
+
+#[cfg(feature = "facilitator")]
+pub mod facilitator;
+#[cfg(feature = "facilitator")]
+pub use facilitator::*;
+
+#[cfg(feature = "client")]
+pub mod client;
+#[cfg(feature = "client")]
+pub use client::*;
+
+pub mod types;
+pub use types::*;
+
+pub struct V1Eip155Exact;
+
+impl X402SchemeId for V1Eip155Exact {
+    fn x402_version(&self) -> u8 {
+        1
+    }
+    fn namespace(&self) -> &str {
+        "eip155"
+    }
+    fn scheme(&self) -> &str {
+        ExactScheme.as_ref()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/server.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/server.rs
new file mode 100644
index 0000000..d287758
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/server.rs
@@ -0,0 +1,71 @@
+//! Server-side price tag generation for V1 EIP-155 exact scheme.
+//!
+//! This module provides functionality for servers to create price tags
+//! that clients can use to generate payment authorizations.
+
+use alloy_primitives::U256;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::proto::v1;
+
+use crate::V1Eip155Exact;
+use crate::chain::{ChecksummedAddress, Eip155TokenDeployment};
+use crate::v1_eip155_exact::ExactScheme;
+
+impl V1Eip155Exact {
+    /// Creates a V1 price tag for an ERC-3009 payment on an EVM chain.
+    ///
+    /// This function generates a price tag that specifies the payment requirements
+    /// for a resource. The price tag includes the recipient address, token details,
+    /// and amount required.
+    ///
+    /// # Parameters
+    ///
+    /// - `pay_to`: The recipient address (can be any type convertible to [`ChecksummedAddress`])
+    /// - `asset`: The token deployment and amount required
+    ///
+    /// # Returns
+    ///
+    /// A [`v1::PriceTag`] that can be included in a `PaymentRequired` response.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_chain_eip155::{V1Eip155Exact, KnownNetworkEip155};
+    /// use x402_types::networks::USDC;
+    ///
+    /// let usdc = USDC::base();
+    /// let price_tag = V1Eip155Exact::price_tag(
+    ///     "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
+    ///     usdc.amount(1_000_000u64), // 1 USDC
+    /// );
+    /// ```
+    ///
+    /// # Panics
+    ///
+    /// Panics if the chain ID cannot be converted to a network name. This should
+    /// only happen for unsupported or custom chains without registered network names.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn price_tag<A: Into<ChecksummedAddress>>(
+        pay_to: A,
+        asset: DeployedTokenAmount<U256, Eip155TokenDeployment>,
+    ) -> v1::PriceTag {
+        let chain_id: ChainId = asset.token.chain_reference.into();
+        let network = chain_id
+            .as_network_name()
+            .unwrap_or_else(|| panic!("Can not get network name for chain id {}", chain_id));
+        let extra = asset
+            .token
+            .eip712
+            .and_then(|eip712| serde_json::to_value(&eip712).ok());
+        v1::PriceTag {
+            scheme: ExactScheme.to_string(),
+            pay_to: pay_to.into().to_string(),
+            asset: asset.token.address.to_string(),
+            network: network.to_string(),
+            amount: asset.amount.to_string(),
+            max_timeout_seconds: 300,
+            extra,
+            enricher: None,
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/types.rs
new file mode 100644
index 0000000..7b3586a
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v1_eip155_exact/types.rs
@@ -0,0 +1,175 @@
+//! Type definitions for the V1 EIP-155 "exact" payment scheme.
+//!
+//! This module defines the wire format types for ERC-3009 based payments
+//! on EVM chains using the V1 x402 protocol.
+
+use alloy_primitives::{Address, B256, Bytes, U256};
+use serde::{Deserialize, Serialize};
+use x402_types::lit_str;
+use x402_types::proto::v1;
+use x402_types::timestamp::UnixTimestamp;
+
+#[cfg(any(feature = "facilitator", feature = "client"))]
+use alloy_sol_types::sol;
+
+lit_str!(ExactScheme, "exact");
+
+/// Type alias for V1 verify requests using the exact EVM payment scheme.
+pub type VerifyRequest = v1::VerifyRequest<PaymentPayload, PaymentRequirements>;
+
+/// Type alias for V1 settle requests (same structure as verify requests).
+pub type SettleRequest = VerifyRequest;
+
+/// Type alias for V1 payment payloads with EVM-specific data.
+pub type PaymentPayload = v1::PaymentPayload<ExactScheme, ExactEvmPayload>;
+
+/// Full payload required to authorize an ERC-3009 transfer.
+///
+/// This struct contains both the EIP-712 signature and the structured authorization
+/// data that was signed. Together, they provide everything needed to execute a
+/// `transferWithAuthorization` call on an ERC-3009 compliant token contract.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ExactEvmPayload {
+    /// The cryptographic signature authorizing the transfer.
+    ///
+    /// This can be:
+    /// - An EOA signature (64-65 bytes, split into r, s, v components)
+    /// - An EIP-1271 signature (arbitrary length, validated by contract)
+    /// - An EIP-6492 signature (wrapped with deployment data and magic suffix)
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub signature: Option<Bytes>,
+
+    /// The structured authorization data that was signed.
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub authorization: Option<ExactEvmPayloadAuthorization>,
+
+    /// Optional Permit2 payload (used instead of ERC-3009 authorization).
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub permit2: Option<Permit2Payload>,
+}
+
+/// EIP-712 structured data for ERC-3009 transfer authorization.
+///
+/// This struct defines the parameters of a `transferWithAuthorization` call:
+/// who can transfer tokens, to whom, how much, and during what time window.
+/// The struct is signed using EIP-712 typed data signing.
+#[derive(Debug, Copy, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ExactEvmPayloadAuthorization {
+    /// The address authorizing the transfer (token owner).
+    pub from: Address,
+
+    /// The recipient address for the transfer.
+    pub to: Address,
+
+    /// The amount of tokens to transfer (in token's smallest unit).
+    pub value: U256,
+
+    /// The authorization is not valid before this timestamp (inclusive).
+    pub valid_after: UnixTimestamp,
+
+    /// The authorization expires at this timestamp (exclusive).
+    pub valid_before: UnixTimestamp,
+
+    /// A unique 32-byte nonce to prevent replay attacks.
+    pub nonce: B256,
+}
+
+/// Permit2 authorization payload (AllowanceTransfer: PermitSingle).
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Permit2Payload {
+    /// Owner authorizing the Permit2 allowance.
+    pub owner: Address,
+
+    /// The Permit2 PermitSingle data structure.
+    pub permit_single: Permit2PermitSingle,
+
+    /// The cryptographic signature authorizing the Permit2 allowance.
+    pub signature: Bytes,
+}
+
+/// Permit2 PermitSingle data.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Permit2PermitSingle {
+    pub details: Permit2Details,
+    pub spender: Address,
+    pub sig_deadline: u64,
+}
+
+/// Permit2 PermitDetails data.
+#[derive(Debug, Copy, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Permit2Details {
+    pub token: Address,
+    pub amount: U256,
+    pub expiration: u64,
+    pub nonce: u64,
+}
+
+/// Type alias for V1 payment requirements with EVM-specific types.
+pub type PaymentRequirements =
+    v1::PaymentRequirements<ExactScheme, U256, Address, PaymentRequirementsExtra>;
+
+/// Extra EIP-712 domain parameters for token contracts.
+///
+/// Some token contracts require specific `name` and `version` values in their
+/// EIP-712 domain for signature verification. This struct allows servers to
+/// specify these values in the payment requirements, avoiding the need for
+/// the facilitator to query them from the contract.
+#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentRequirementsExtra {
+    /// The token name as used in the EIP-712 domain.
+    pub name: String,
+
+    /// The token version as used in the EIP-712 domain.
+    pub version: String,
+}
+
+#[cfg(any(feature = "facilitator", feature = "client"))]
+sol!(
+    /// Solidity-compatible struct definition for ERC-3009 `transferWithAuthorization`.
+    ///
+    /// This matches the EIP-3009 format used in EIP-712 typed data:
+    /// it defines the authorization to transfer tokens from `from` to `to`
+    /// for a specific `value`, valid only between `validAfter` and `validBefore`
+    /// and identified by a unique `nonce`.
+    ///
+    /// This struct is primarily used to reconstruct the typed data domain/message
+    /// when verifying a client's signature.
+    #[derive(Serialize, Deserialize)]
+    struct TransferWithAuthorization {
+        address from;
+        address to;
+        uint256 value;
+        uint256 validAfter;
+        uint256 validBefore;
+        bytes32 nonce;
+    }
+);
+
+#[cfg(any(feature = "facilitator", feature = "client"))]
+sol!(
+    /// Solidity-compatible struct for Permit2 `PermitDetails`.
+    #[derive(Serialize, Deserialize)]
+    struct PermitDetails {
+        address token;
+        uint160 amount;
+        uint48 expiration;
+        uint48 nonce;
+    }
+);
+
+#[cfg(any(feature = "facilitator", feature = "client"))]
+sol!(
+    /// Solidity-compatible struct for Permit2 `PermitSingle`.
+    #[derive(Serialize, Deserialize)]
+    struct PermitSingle {
+        PermitDetails details;
+        address spender;
+        uint256 sigDeadline;
+    }
+);
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/client.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/client.rs
new file mode 100644
index 0000000..f0b33cb
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/client.rs
@@ -0,0 +1,149 @@
+//! Client-side payment signing for the V2 EIP-155 "exact" scheme.
+//!
+//! This module provides [`V2Eip155ExactClient`] for signing ERC-3009
+//! `transferWithAuthorization` payments on EVM chains using the V2 protocol.
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_eip155::v2_eip155_exact::client::V2Eip155ExactClient;
+//! use alloy_signer_local::PrivateKeySigner;
+//!
+//! let signer = PrivateKeySigner::random();
+//! let client = V2Eip155ExactClient::new(signer);
+//! ```
+
+use async_trait::async_trait;
+use x402_types::proto::v2::ResourceInfo;
+use x402_types::proto::{PaymentRequired, v2};
+use x402_types::scheme::X402SchemeId;
+use x402_types::scheme::client::{
+    PaymentCandidate, PaymentCandidateSigner, X402Error, X402SchemeClient,
+};
+use x402_types::util::Base64Bytes;
+
+use crate::chain::Eip155ChainReference;
+use crate::v1_eip155_exact::client::{
+    Eip3009SigningParams, SignerLike, sign_erc3009_authorization,
+};
+use crate::v2_eip155_exact::V2Eip155Exact;
+use crate::v2_eip155_exact::types;
+
+/// Client for signing V2 EIP-155 exact scheme payments.
+///
+/// This client handles the creation and signing of ERC-3009 `transferWithAuthorization`
+/// payments for EVM chains using the V2 protocol. Unlike V1, V2 uses CAIP-2 chain IDs
+/// and embeds the accepted requirements directly in the payment payload.
+///
+/// # Type Parameters
+///
+/// - `S`: The signer type, which must implement [`SignerLike`](crate::v1_eip155_exact::client::SignerLike)
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_eip155::V2Eip155ExactClient;
+/// use alloy_signer_local::PrivateKeySigner;
+///
+/// let signer = PrivateKeySigner::random();
+/// let client = V2Eip155ExactClient::new(signer);
+/// ```
+#[derive(Debug)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct V2Eip155ExactClient<S> {
+    signer: S,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl<S> V2Eip155ExactClient<S> {
+    /// Creates a new V2 EIP-155 exact scheme client with the given signer.
+    pub fn new(signer: S) -> Self {
+        Self { signer }
+    }
+}
+
+impl<S> X402SchemeId for V2Eip155ExactClient<S> {
+    fn namespace(&self) -> &str {
+        V2Eip155Exact.namespace()
+    }
+
+    fn scheme(&self) -> &str {
+        V2Eip155Exact.scheme()
+    }
+}
+
+impl<S> X402SchemeClient for V2Eip155ExactClient<S>
+where
+    S: SignerLike + Clone + Send + Sync + 'static,
+{
+    fn accept(&self, payment_required: &PaymentRequired) -> Vec<PaymentCandidate> {
+        let payment_required = match payment_required {
+            PaymentRequired::V2(payment_required) => payment_required,
+            PaymentRequired::V1(_) => {
+                return vec![];
+            }
+        };
+        payment_required
+            .accepts
+            .iter()
+            .filter_map(|v| {
+                let requirements: types::PaymentRequirements = v.as_concrete()?;
+                let chain_reference = Eip155ChainReference::try_from(&requirements.network).ok()?;
+                let candidate = PaymentCandidate {
+                    chain_id: requirements.network.clone(),
+                    asset: requirements.asset.to_string(),
+                    amount: requirements.amount.into(),
+                    scheme: self.scheme().to_string(),
+                    x402_version: self.x402_version(),
+                    pay_to: requirements.pay_to.to_string(),
+                    signer: Box::new(PayloadSigner {
+                        resource_info: Some(payment_required.resource.clone()),
+                        signer: self.signer.clone(),
+                        chain_reference,
+                        requirements,
+                    }),
+                };
+                Some(candidate)
+            })
+            .collect::<Vec<_>>()
+    }
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+struct PayloadSigner<S> {
+    signer: S,
+    resource_info: Option<ResourceInfo>,
+    chain_reference: Eip155ChainReference,
+    requirements: types::PaymentRequirements,
+}
+
+#[async_trait]
+impl<S> PaymentCandidateSigner for PayloadSigner<S>
+where
+    S: Sync + SignerLike,
+{
+    async fn sign_payment(&self) -> Result<String, X402Error> {
+        let params = Eip3009SigningParams {
+            chain_id: self.chain_reference.inner(),
+            asset_address: self.requirements.asset.0,
+            pay_to: self.requirements.pay_to.into(),
+            amount: self.requirements.amount.into(),
+            max_timeout_seconds: self.requirements.max_timeout_seconds,
+            extra: self.requirements.extra.clone(),
+        };
+
+        let evm_payload = sign_erc3009_authorization(&self.signer, &params).await?;
+
+        // Build the payment payload
+        let payload = types::PaymentPayload {
+            x402_version: v2::X402Version2,
+            accepted: self.requirements.clone(),
+            resource: self.resource_info.clone(),
+            payload: evm_payload,
+        };
+        let json = serde_json::to_vec(&payload)?;
+        let b64 = Base64Bytes::encode(&json);
+
+        Ok(b64.to_string())
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/facilitator.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/facilitator.rs
new file mode 100644
index 0000000..788c7e8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/facilitator.rs
@@ -0,0 +1,285 @@
+//! Facilitator-side payment verification and settlement for V2 EIP-155 exact scheme.
+//!
+//! This module implements the facilitator logic for V2 protocol payments on EVM chains.
+//! It reuses most of the V1 verification and settlement logic but handles V2-specific
+//! payload structures with embedded requirements and CAIP-2 chain IDs.
+
+use alloy_provider::Provider;
+use alloy_sol_types::Eip712Domain;
+use std::collections::HashMap;
+use x402_types::chain::{ChainId, ChainProviderOps};
+use x402_types::proto;
+use x402_types::proto::{PaymentVerificationError, v2};
+use x402_types::timestamp::UnixTimestamp;
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorBuilder, X402SchemeFacilitatorError,
+};
+
+#[cfg(feature = "telemetry")]
+use tracing::instrument;
+
+use crate::V2Eip155Exact;
+use crate::chain::{Eip155ChainReference, Eip155MetaTransactionProvider};
+use crate::v1_eip155_exact::ExactScheme;
+use crate::v1_eip155_exact::facilitator::{
+    Eip155ExactError, ExactEvmPayment, IEIP3009, IPermit2, Permit2Payment,
+    assert_domain, assert_enough_balance, assert_enough_value, assert_permit2_domain,
+    assert_permit2_time, assert_time, settle_payment, settle_payment_permit2,
+    verify_payment, verify_payment_permit2,
+};
+use crate::v2_eip155_exact::types;
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V2Eip155Exact
+where
+    P: Eip155MetaTransactionProvider + ChainProviderOps + Send + Sync + 'static,
+    Eip155ExactError: From<P::Error>,
+{
+    fn build(
+        &self,
+        provider: P,
+        _config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        Ok(Box::new(V2Eip155ExactFacilitator::new(provider)))
+    }
+}
+
+/// Facilitator for V2 EIP-155 exact scheme payments.
+///
+/// This struct implements the [`X402SchemeFacilitator`] trait to provide payment
+/// verification and settlement services for ERC-3009 based payments on EVM chains
+/// using the V2 protocol.
+///
+/// # Type Parameters
+///
+/// - `P`: The provider type, which must implement [`Eip155MetaTransactionProvider`]
+///   and [`ChainProviderOps`]
+pub struct V2Eip155ExactFacilitator<P> {
+    provider: P,
+}
+
+impl<P> V2Eip155ExactFacilitator<P> {
+    /// Creates a new V2 EIP-155 exact scheme facilitator with the given provider.
+    pub fn new(provider: P) -> Self {
+        Self { provider }
+    }
+}
+
+#[async_trait::async_trait]
+impl<P> X402SchemeFacilitator for V2Eip155ExactFacilitator<P>
+where
+    P: Eip155MetaTransactionProvider + ChainProviderOps + Send + Sync,
+    P::Inner: Provider,
+    Eip155ExactError: From<P::Error>,
+{
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError> {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        let payload = &request.payment_payload;
+        let requirements = &request.payment_requirements;
+        let context = assert_valid_payment(
+            self.provider.inner(),
+            self.provider.chain(),
+            payload,
+            requirements,
+        )
+        .await?;
+
+        let payer = match context {
+            PaymentContext::Eip3009 {
+                contract,
+                payment,
+                domain,
+            } => verify_payment(self.provider.inner(), &contract, &payment, &domain).await?,
+            PaymentContext::Permit2 {
+                contract,
+                payment,
+                domain,
+            } => verify_payment_permit2(self.provider.inner(), &contract, &payment, &domain).await?,
+        };
+        Ok(v2::VerifyResponse::valid(payer.to_string()).into())
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError> {
+        let request = types::SettleRequest::from_proto(request.clone())?;
+        let payload = &request.payment_payload;
+        let requirements = &request.payment_requirements;
+        let context = assert_valid_payment(
+            self.provider.inner(),
+            self.provider.chain(),
+            payload,
+            requirements,
+        )
+        .await?;
+
+        let (payer, tx_hash): (alloy_primitives::Address, alloy_primitives::TxHash) = match context {
+            PaymentContext::Eip3009 {
+                contract,
+                payment,
+                domain,
+            } => (
+                payment.from,
+                settle_payment(&self.provider, &contract, &payment, &domain).await?,
+            ),
+            PaymentContext::Permit2 {
+                contract,
+                payment,
+                domain,
+            } => (
+                payment.owner,
+                settle_payment_permit2(&self.provider, &contract, &payment, &domain).await?,
+            ),
+        };
+
+        Ok(v2::SettleResponse::Success {
+            payer: payer.to_string(),
+            transaction: tx_hash.to_string(),
+            network: payload.accepted.network.to_string(),
+        }
+        .into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+        let kinds = vec![proto::SupportedPaymentKind {
+            x402_version: v2::X402Version2.into(),
+            scheme: ExactScheme.to_string(),
+            network: chain_id.clone().into(),
+            extra: None,
+        }];
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+enum PaymentContext<'a, P: Provider> {
+    Eip3009 {
+        contract: IEIP3009::IEIP3009Instance<&'a P>,
+        payment: ExactEvmPayment,
+        domain: Eip712Domain,
+    },
+    Permit2 {
+        contract: IPermit2::IPermit2Instance<&'a P>,
+        payment: Permit2Payment,
+        domain: Eip712Domain,
+    },
+}
+
+/// Runs all preconditions needed for a successful payment:
+/// - Valid scheme, network, and receiver.
+/// - Valid time window (validAfter/validBefore).
+/// - Correct EIP-712 domain construction.
+/// - Sufficient on-chain balance.
+/// - Sufficient value in payload.
+#[cfg_attr(feature = "telemetry", instrument(skip_all, err))]
+async fn assert_valid_payment<'a, P: Provider>(
+    provider: &'a P,
+    chain: &'a Eip155ChainReference,
+    payload: &'a types::PaymentPayload,
+    requirements: &'a types::PaymentRequirements,
+) -> Result<PaymentContext<'a, P>, Eip155ExactError> {
+    let accepted = &payload.accepted;
+    if accepted != requirements {
+        return Err(PaymentVerificationError::AcceptedRequirementsMismatch.into());
+    }
+    let payload = &payload.payload;
+
+    let chain_id: ChainId = chain.into();
+    let payload_chain_id = &accepted.network;
+    if payload_chain_id != &chain_id {
+        return Err(PaymentVerificationError::ChainIdMismatch.into());
+    }
+    if let Some(permit2) = payload.permit2.as_ref() {
+        let permit_single = &permit2.permit_single;
+        let details = &permit_single.details;
+        let asset_address: alloy_primitives::Address = accepted.asset.into();
+
+        if details.token != asset_address {
+            return Err(PaymentVerificationError::AssetMismatch.into());
+        }
+        if permit_single.spender != accepted.pay_to {
+            return Err(PaymentVerificationError::RecipientMismatch.into());
+        }
+
+        let sig_deadline = UnixTimestamp::from_secs(permit_single.sig_deadline);
+        let expiration = UnixTimestamp::from_secs(details.expiration);
+        assert_permit2_time(sig_deadline, expiration)?;
+
+        let amount_required = accepted.amount;
+        assert_enough_value(&details.amount, &amount_required.into())?;
+
+        let erc20_contract = IEIP3009::new(asset_address, provider);
+        assert_enough_balance(&erc20_contract, &permit2.owner, amount_required.into()).await?;
+
+        let domain = assert_permit2_domain(chain);
+        let contract = IPermit2::new(
+            crate::v1_eip155_exact::facilitator::PERMIT2_ADDRESS,
+            provider,
+        );
+        let payment = Permit2Payment {
+            owner: permit2.owner,
+            spender: permit_single.spender,
+            token: details.token,
+            amount: details.amount,
+            expiration: details.expiration,
+            nonce: details.nonce,
+            sig_deadline: permit_single.sig_deadline,
+            signature: permit2.signature.clone(),
+            transfer_amount: amount_required.into(),
+        };
+
+        Ok(PaymentContext::Permit2 {
+            contract,
+            payment,
+            domain,
+        })
+    } else {
+        let authorization = payload.authorization.as_ref().ok_or_else(|| {
+            PaymentVerificationError::InvalidFormat("Missing authorization".to_string())
+        })?;
+        if authorization.to != accepted.pay_to {
+            return Err(PaymentVerificationError::RecipientMismatch.into());
+        }
+        let valid_after = authorization.valid_after;
+        let valid_before = authorization.valid_before;
+        assert_time(valid_after, valid_before)?;
+        let asset_address = accepted.asset;
+        let contract = IEIP3009::new(asset_address.into(), provider);
+
+        let domain = assert_domain(chain, &contract, &asset_address.into(), &accepted.extra).await?;
+
+        let amount_required = accepted.amount;
+        assert_enough_balance(&contract, &authorization.from, amount_required.into()).await?;
+        assert_enough_value(&authorization.value, &amount_required.into())?;
+
+        let payment = ExactEvmPayment {
+            from: authorization.from,
+            to: authorization.to,
+            value: authorization.value,
+            valid_after: authorization.valid_after,
+            valid_before: authorization.valid_before,
+            nonce: authorization.nonce,
+            signature: payload.signature.clone().ok_or_else(|| {
+                PaymentVerificationError::InvalidFormat("Missing signature".to_string())
+            })?,
+        };
+
+        Ok(PaymentContext::Eip3009 {
+            contract,
+            payment,
+            domain,
+        })
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/mod.rs
new file mode 100644
index 0000000..5be0113
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/mod.rs
@@ -0,0 +1,66 @@
+//! V2 EIP-155 "exact" payment scheme implementation.
+//!
+//! This module implements the "exact" payment scheme for EVM chains using
+//! the V2 x402 protocol. It builds on the V1 implementation but uses
+//! CAIP-2 chain identifiers instead of network names.
+//!
+//! # Differences from V1
+//!
+//! - Uses CAIP-2 chain IDs (e.g., `eip155:8453`) instead of network names
+//! - Payment requirements are embedded in the payload for verification
+//! - Cleaner separation between accepted requirements and authorization
+//!
+//! # Features
+//!
+//! - EIP-712 typed data signing for payment authorization
+//! - EIP-6492 support for counterfactual smart wallet signatures
+//! - EIP-1271 support for deployed smart wallet signatures
+//! - EOA signature support with split (v, r, s) components
+//! - On-chain balance verification before settlement
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_eip155::v2_eip155_exact::V2Eip155Exact;
+//! use x402_chain_eip155::networks::{KnownNetworkEip155, USDC};
+//!
+//! // Create a price tag for 1 USDC on Base
+//! let usdc = USDC::base();
+//! let price = V2Eip155Exact::price_tag(
+//!     "0x1234...",  // pay_to address
+//!     usdc.amount(1_000_000u64.into()),  // 1 USDC
+//! );
+//! ```
+
+#[cfg(feature = "server")]
+pub mod server;
+#[cfg(feature = "server")]
+#[allow(unused_imports)]
+pub use server::*;
+
+#[cfg(feature = "facilitator")]
+pub mod facilitator;
+#[cfg(feature = "facilitator")]
+pub use facilitator::*;
+
+#[cfg(feature = "client")]
+pub mod client;
+#[cfg(feature = "client")]
+pub use client::*;
+
+pub mod types;
+pub use types::*;
+
+use x402_types::scheme::X402SchemeId;
+
+pub struct V2Eip155Exact;
+
+impl X402SchemeId for V2Eip155Exact {
+    fn namespace(&self) -> &str {
+        "eip155"
+    }
+
+    fn scheme(&self) -> &str {
+        ExactScheme.as_ref()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/server.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/server.rs
new file mode 100644
index 0000000..84b22a8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/server.rs
@@ -0,0 +1,67 @@
+//! Server-side price tag generation for V2 EIP-155 exact scheme.
+//!
+//! This module provides functionality for servers to create V2 price tags
+//! that clients can use to generate payment authorizations. V2 uses CAIP-2
+//! chain IDs instead of network names.
+
+use alloy_primitives::U256;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::proto::v2;
+
+use crate::V2Eip155Exact;
+use crate::chain::{ChecksummedAddress, Eip155TokenDeployment};
+use crate::v1_eip155_exact::ExactScheme;
+
+impl V2Eip155Exact {
+    /// Creates a V2 price tag for an ERC-3009 payment on an EVM chain.
+    ///
+    /// This function generates a V2 price tag that specifies the payment requirements
+    /// for a resource. Unlike V1, V2 uses CAIP-2 chain IDs (e.g., `eip155:8453`) instead
+    /// of network names, and embeds the requirements directly in the price tag.
+    ///
+    /// # Parameters
+    ///
+    /// - `pay_to`: The recipient address (can be any type convertible to [`ChecksummedAddress`])
+    /// - `asset`: The token deployment and amount required
+    ///
+    /// # Returns
+    ///
+    /// A [`v2::PriceTag`] that can be included in a `PaymentRequired` response.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_chain_eip155::{V2Eip155Exact, KnownNetworkEip155};
+    /// use x402_types::networks::USDC;
+    ///
+    /// let usdc = USDC::base();
+    /// let price_tag = V2Eip155Exact::price_tag(
+    ///     "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
+    ///     usdc.amount(1_000_000u64), // 1 USDC
+    /// );
+    /// ```
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn price_tag<A: Into<ChecksummedAddress>>(
+        pay_to: A,
+        asset: DeployedTokenAmount<U256, Eip155TokenDeployment>,
+    ) -> v2::PriceTag {
+        let chain_id: ChainId = asset.token.chain_reference.into();
+        let extra = asset
+            .token
+            .eip712
+            .and_then(|eip712| serde_json::to_value(&eip712).ok());
+        let requirements = v2::PaymentRequirements {
+            scheme: ExactScheme.to_string(),
+            pay_to: pay_to.into().to_string(),
+            asset: asset.token.address.to_string(),
+            network: chain_id,
+            amount: asset.amount.to_string(),
+            max_timeout_seconds: 300,
+            extra,
+        };
+        v2::PriceTag {
+            requirements,
+            enricher: None,
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/types.rs
new file mode 100644
index 0000000..f6e59fa
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-eip155/src/v2_eip155_exact/types.rs
@@ -0,0 +1,29 @@
+//! Type definitions for the V2 EIP-155 "exact" payment scheme.
+//!
+//! This module re-exports types from V1 and defines V2-specific wire format
+//! types for ERC-3009 based payments on EVM chains.
+
+use crate::chain::{ChecksummedAddress, TokenAmount};
+use x402_types::proto::v2;
+
+/// Re-export the "exact" scheme identifier from V1 (same for both versions).
+pub use crate::v1_eip155_exact::types::ExactScheme;
+
+/// Re-export the EVM payload types from V1 (same structure for both versions).
+use crate::v1_eip155_exact::types::{ExactEvmPayload, PaymentRequirementsExtra};
+
+/// Type alias for V2 verify requests using the exact EVM payment scheme.
+pub type VerifyRequest = v2::VerifyRequest<PaymentPayload, PaymentRequirements>;
+
+/// Type alias for V2 settle requests (same structure as verify requests).
+pub type SettleRequest = VerifyRequest;
+
+/// Type alias for V2 payment payloads with embedded requirements and EVM-specific data.
+pub type PaymentPayload = v2::PaymentPayload<PaymentRequirements, ExactEvmPayload>;
+
+/// Type alias for V2 payment requirements with EVM-specific types.
+///
+/// V2 uses CAIP-2 chain IDs and embeds requirements directly in the payload,
+/// unlike V1 which uses network names and separate requirement objects.
+pub type PaymentRequirements =
+    v2::PaymentRequirements<ExactScheme, TokenAmount, ChecksummedAddress, PaymentRequirementsExtra>;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/Cargo.toml b/bbt-x402-facilitator/crates/chains/x402-chain-solana/Cargo.toml
new file mode 100644
index 0000000..f2640f5
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/Cargo.toml
@@ -0,0 +1,64 @@
+[package]
+name = "x402-chain-solana"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+categories.workspace = true
+keywords.workspace = true
+description = "Solana chain support for the x402 payment protocol"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[features]
+default = []
+telemetry = ["tracing", "tracing-core", "x402-types/telemetry"]
+client = ["alloy-primitives", "spl-token", "spl-token-2022", "solana-transaction", "solana-signer", "solana-client", "solana-signature", "solana-account", "solana-message", "solana-compute-budget-interface", "bincode", "solana-commitment-config"]
+server = []
+facilitator = ["solana-client", "spl-token", "spl-token-2022", "solana-keypair", "solana-account", "solana-signer", "solana-transaction", "solana-signature", "solana-message", "solana-commitment-config", "solana-compute-budget-interface", "bs58", "bincode", "futures-util", "url"]
+full = ["telemetry", "client", "server", "facilitator"]
+
+[dependencies]
+x402-types = { workspace = true }
+serde = { workspace = true }
+thiserror = { workspace = true }
+tokio = { workspace = true }
+async-trait = { workspace = true }
+alloy-primitives = { workspace = true, optional = true }
+serde_json = { workspace = true }
+
+# Solana - always needed
+solana-pubkey = { version = "4.0.0" }
+
+# Needed by faciliator and client features
+solana-signature = { version = "3.1.0", optional = true }
+solana-transaction = { version = "3.0.2", optional = true }
+solana-signer = { version = "3.0.0", optional = true }
+spl-token = { version = "9.0.0", features = ["no-entrypoint"], optional = true }
+spl-token-2022 = { version = "10.0.0", features = ["no-entrypoint"], optional = true }
+
+# Solana - client feature only
+solana-client = { version = "3.1.4", optional = true }
+solana-account = { version = "3.2.0", optional = true }
+solana-message = { version = "3.0.1", optional = true }
+solana-compute-budget-interface = { version = "3.0.0", optional = true }
+solana-commitment-config = { version = "3.1.0", optional = true }
+futures-util = { version = "0.3.31", optional = true }
+bincode = { version = "1.3.3", optional = true }
+
+# Solana - facilitator feature only
+bs58 = { version = "0.5.1", optional = true }
+solana-keypair = { version = "3.1.0", optional = true }
+url = { workspace = true, optional = true }
+
+# Telemetry
+tracing = { workspace = true, optional = true }
+tracing-core = { workspace = true, optional = true }
+
+[dev-dependencies]
+solana-keypair = { version = "3.1.0" }
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/README.md b/bbt-x402-facilitator/crates/chains/x402-chain-solana/README.md
new file mode 100644
index 0000000..992fc18
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/README.md
@@ -0,0 +1,165 @@
+# x402-chain-solana
+
+[![Crates.io](https://img.shields.io/crates/v/x402-chain-solana.svg)](https://crates.io/crates/x402-chain-solana)
+[![Docs.rs](https://docs.rs/x402-chain-solana/badge.svg)](https://docs.rs/x402-chain-solana)
+
+Solana chain support for the x402 payment protocol.
+
+This crate provides implementations of the x402 payment protocol for the Solana blockchain. It supports both V1 and V2 protocol versions with the "exact" payment scheme based on SPL Token `transfer` instructions with pre-signed authorization.
+
+## Features
+
+- **V1 and V2 Protocol Support**: Implements both protocol versions with network name (V1) and CAIP-2 chain ID (V2) addressing
+- **SPL Token Payments**: Token transfers using pre-signed transaction authorization
+- **Compute Budget Management**: Automatic compute unit limit and price configuration for transaction prioritization
+- **WebSocket Support**: Optional pubsub for faster transaction confirmation via signature subscriptions
+- **Balance Verification**: On-chain balance checks before settlement
+- **Transaction Simulation**: Pre-flight simulation to validate transactions before submission
+
+## Architecture
+
+The crate is organized into several modules:
+
+- **`chain`** - Core Solana chain types, providers, and configuration
+- **`v1_solana_exact`** - V1 protocol implementation with network names
+- **`v2_solana_exact`** - V2 protocol implementation with CAIP-2 chain IDs
+
+## Feature Flags
+
+- `server` - Server-side price tag generation
+- `client` - Client-side payment signing
+- `facilitator` - Facilitator-side payment verification and settlement
+- `telemetry` - OpenTelemetry tracing support
+
+## Usage
+
+### Server: Creating a Price Tag
+
+```rust
+use x402_chain_solana::{V1SolanaExact, KnownNetworkSolana};
+use x402_types::networks::USDC;
+
+// Get USDC deployment on Solana mainnet
+let usdc = USDC::solana();
+
+// Create a price tag for 1 USDC
+let price_tag = V1SolanaExact::price_tag(
+    "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
+    usdc.amount(1_000_000u64),
+);
+```
+
+### Client: Signing a Payment
+
+```rust
+use x402_chain_solana::V1SolanaExactClient;
+use solana_keypair::Keypair;
+
+let keypair = Keypair::new();
+let client = V1SolanaExactClient::new(keypair);
+
+// Use client to sign payment candidates
+let candidates = client.accept(&payment_required);
+```
+
+### Facilitator: Verifying and Settling
+
+```rust
+use x402_chain_solana::{V1SolanaExact, SolanaChainProvider};
+use x402_types::scheme::X402SchemeFacilitatorBuilder;
+
+let provider = SolanaChainProvider::from_config(&config).await?;
+let facilitator = V1SolanaExact.build(provider, None)?;
+
+// Verify payment
+let verify_response = facilitator.verify(&verify_request).await?;
+
+// Settle payment
+let settle_response = facilitator.settle(&settle_request).await?;
+```
+
+## Supported Networks
+
+The crate includes built-in support for Solana networks through the `KnownNetworkSolana` trait:
+
+- **Solana Mainnet** (`solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`)
+- **Solana Devnet** (`solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1`)
+
+Each network includes USDC token deployment information with proper mint addresses and decimal precision.
+
+## Payment Flow
+
+### Client Side
+
+1. Client receives a `PaymentRequired` response with price tags
+2. Client selects a compatible payment option (Solana + USDC)
+3. Client creates a pre-signed SPL Token transfer transaction
+4. Client serializes and base64-encodes the transaction
+5. Client sends the payment payload to the server
+
+### Facilitator Side
+
+1. Facilitator receives the payment payload
+2. Deserializes and validates the transaction structure
+3. Simulates the transaction to verify it will succeed
+4. Checks the payer's token balance
+5. For verification: Returns success if all checks pass
+6. For settlement: Submits the transaction on-chain and waits for confirmation
+
+## Transaction Structure
+
+Solana payments use a pre-signed `VersionedTransaction` containing:
+
+- **Transfer instruction**: SPL Token transfer from payer to recipient
+- **Compute budget instructions**: Set compute unit limit and price
+- **Signatures**: Pre-signed by the payer, co-signed by the facilitator (fee payer)
+
+The facilitator adds its signature as the fee payer and submits the transaction.
+
+## Configuration
+
+### Facilitator Configuration Example
+
+```json
+{
+  "solana": {
+    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "signer": "$SOLANA_FACILITATOR_KEY",
+      "rpc": "https://api.mainnet-beta.solana.com",
+      "pubsub": "wss://api.mainnet-beta.solana.com",
+      "max_compute_unit_limit": 400000,
+      "max_compute_unit_price": 1000000
+    }
+  }
+}
+```
+
+### Configuration Parameters
+
+- **`signer`**: Base58-encoded 64-byte Solana keypair (or environment variable reference)
+- **`rpc`**: HTTP RPC endpoint URL
+- **`pubsub`**: Optional WebSocket endpoint for faster confirmations
+- **`max_compute_unit_limit`**: Maximum compute units per transaction (default: 400,000)
+- **`max_compute_unit_price`**: Maximum price per compute unit in micro-lamports (default: 1,000,000)
+
+## Compute Budget
+
+Solana transactions have compute unit limits that determine how much computation they can perform. The facilitator automatically adds compute budget instructions to transactions:
+
+- **Compute Unit Limit**: Maximum compute units the transaction can consume
+- **Compute Unit Price**: Priority fee in micro-lamports per compute unit
+
+Higher compute unit prices increase transaction priority during network congestion.
+
+## Dependencies
+
+This crate uses the official Solana SDK crates:
+
+- `solana-client` - RPC and WebSocket client
+- `solana-transaction` - Transaction building and signing
+- `solana-keypair` - Ed25519 keypair management
+- `spl-token` - SPL Token program interactions
+
+## License
+
+Apache 2.0
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/config.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/config.rs
new file mode 100644
index 0000000..c1a6296
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/config.rs
@@ -0,0 +1,183 @@
+use serde::{Deserialize, Serialize};
+use std::ops::Deref;
+use std::str::FromStr;
+use url::Url;
+use x402_types::chain::ChainId;
+use x402_types::config::LiteralOrEnv;
+
+use crate::chain::SolanaChainReference;
+
+/// Configuration for a Solana chain in the x402 facilitator.
+///
+/// This struct combines a chain reference with chain-specific configuration
+/// including RPC endpoints, signer, and compute budget parameters.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_solana::chain::{SolanaChainConfig, SolanaChainReference};
+///
+/// let config = SolanaChainConfig {
+///     chain_reference: SolanaChainReference::solana(),
+///     inner: config_inner,
+/// };
+/// ```
+#[derive(Debug, Clone)]
+pub struct SolanaChainConfig {
+    /// The Solana network identifier (genesis hash prefix).
+    pub chain_reference: SolanaChainReference,
+    /// Chain-specific configuration details.
+    pub inner: SolanaChainConfigInner,
+}
+
+impl SolanaChainConfig {
+    /// Returns the signer configuration for this chain.
+    pub fn signer(&self) -> &SolanaSignerConfig {
+        &self.inner.signer
+    }
+    /// Returns the RPC endpoint URL for this chain.
+    pub fn rpc(&self) -> &Url {
+        &self.inner.rpc
+    }
+
+    /// Returns the maximum compute unit limit for transactions.
+    pub fn max_compute_unit_limit(&self) -> u32 {
+        self.inner.max_compute_unit_limit
+    }
+
+    /// Returns the maximum compute unit price (in micro-lamports).
+    pub fn max_compute_unit_price(&self) -> u64 {
+        self.inner.max_compute_unit_price
+    }
+
+    /// Returns the chain reference (genesis hash prefix).
+    pub fn chain_reference(&self) -> SolanaChainReference {
+        self.chain_reference
+    }
+
+    /// Returns the CAIP-2 chain ID for this configuration.
+    pub fn chain_id(&self) -> ChainId {
+        self.chain_reference.into()
+    }
+
+    /// Returns the optional WebSocket pubsub endpoint URL.
+    pub fn pubsub(&self) -> &Option<Url> {
+        &self.inner.pubsub
+    }
+}
+
+/// Configuration specific to Solana chains.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct SolanaChainConfigInner {
+    /// Signer configuration for this chain (required).
+    /// A single private key (base58 format, 64 bytes) or env var reference.
+    pub signer: SolanaSignerConfig,
+    /// RPC provider configuration for this chain (required).
+    pub rpc: Url,
+    /// RPC pubsub provider endpoint (optional)
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub pubsub: Option<Url>,
+    /// Maximum compute unit limit for transactions (optional)
+    #[serde(default = "solana_chain_config::default_max_compute_unit_limit")]
+    pub max_compute_unit_limit: u32,
+    /// Maximum compute unit price for transactions (optional)
+    #[serde(default = "solana_chain_config::default_max_compute_unit_price")]
+    pub max_compute_unit_price: u64,
+}
+
+mod solana_chain_config {
+    pub fn default_max_compute_unit_limit() -> u32 {
+        400_000
+    }
+    pub fn default_max_compute_unit_price() -> u64 {
+        1_000_000
+    }
+}
+
+// ============================================================================
+// Solana Private Key
+// ============================================================================
+
+/// A validated Solana private key (64 bytes in standard Solana format).
+///
+/// This type represents a standard Solana keypair in its 64-byte format:
+/// - First 32 bytes: the Ed25519 secret key (seed)
+/// - Last 32 bytes: the Ed25519 public key
+///
+/// The key is stored and parsed as a base58-encoded 64-byte array,
+/// which is the standard format used by Solana CLI and wallets.
+#[derive(Clone, Debug, PartialEq, Eq)]
+pub struct SolanaPrivateKey([u8; 64]);
+
+impl SolanaPrivateKey {
+    /// Parse a base58 string into a private key (64 bytes in standard Solana format).
+    ///
+    /// The standard Solana keypair format is 64 bytes:
+    /// - First 32 bytes: secret key (seed)
+    /// - Last 32 bytes: public key
+    pub fn from_base58(s: &str) -> Result<Self, String> {
+        let bytes = bs58::decode(s)
+            .into_vec()
+            .map_err(|e| format!("Invalid base58: {}", e))?;
+
+        if bytes.len() != 64 {
+            return Err(format!(
+                "Private key must be 64 bytes (standard Solana format), got {} bytes",
+                bytes.len()
+            ));
+        }
+
+        let mut arr = [0u8; 64];
+        arr.copy_from_slice(&bytes);
+        Ok(Self(arr))
+    }
+
+    /// Encode the keypair back to base58.
+    pub fn to_base58(&self) -> String {
+        bs58::encode(&self.0).into_string()
+    }
+}
+
+impl Serialize for SolanaPrivateKey {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&self.to_base58())
+    }
+}
+
+impl FromStr for SolanaPrivateKey {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        Self::from_base58(s)
+    }
+}
+
+impl std::fmt::Display for SolanaPrivateKey {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.to_base58())
+    }
+}
+
+/// Type alias for Solana signer configuration.
+///
+/// Uses `LiteralOrEnv` to support both literal base58 keys and environment variable references.
+///
+/// Example JSON:
+/// ```json
+/// {
+///   "signer": "$SOLANA_FACILITATOR_KEY"
+/// }
+/// ```
+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
+pub struct SolanaSignerConfig(LiteralOrEnv<SolanaPrivateKey>);
+
+impl Deref for SolanaSignerConfig {
+    type Target = SolanaPrivateKey;
+
+    fn deref(&self) -> &Self::Target {
+        self.0.inner()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/mod.rs
new file mode 100644
index 0000000..2952465
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/mod.rs
@@ -0,0 +1,46 @@
+//! Solana chain support for x402 payments.
+//!
+//! This module provides types and providers for interacting with the Solana blockchain
+//! in the x402 protocol. It supports SPL token transfers for payment settlement.
+//!
+//! # Key Types
+//!
+//! - [`SolanaChainReference`] - A 32-character genesis hash identifying a Solana network
+//! - [`SolanaChainProvider`] - Provider for interacting with Solana chains
+//! - [`SolanaTokenDeployment`] - Token deployment information including mint address and decimals
+//! - [`Address`] - A Solana public key (base58-encoded)
+//!
+//! # Solana Networks
+//!
+//! Solana networks are identified by the first 32 characters of their genesis block hash:
+//! - Mainnet: `5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`
+//! - Devnet: `EtWTRABZaYq6iMfeYKouRu166VU2xqa1`
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_rs::chain::solana::{SolanaChainReference, SolanaTokenDeployment};
+//! use x402_rs::networks::{KnownNetworkSolana, USDC};
+//!
+//! // Get USDC deployment on Solana mainnet
+//! let usdc = USDC::solana();
+//! assert_eq!(usdc.decimals, 6);
+//!
+//! // Parse a human-readable amount
+//! let amount = usdc.parse("10.50").unwrap();
+//! // amount.amount is now 10_500_000 (10.50 * 10^6)
+//! ```
+
+pub mod types;
+pub use types::*;
+
+#[cfg(feature = "facilitator")]
+pub mod config;
+
+#[cfg(feature = "facilitator")]
+pub mod provider;
+#[cfg(feature = "facilitator")]
+pub use provider::*;
+
+#[cfg(feature = "client")]
+pub mod rpc;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/provider.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/provider.rs
new file mode 100644
index 0000000..aaf43b5
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/provider.rs
@@ -0,0 +1,452 @@
+use solana_account::Account;
+use solana_client::client_error::{ClientError, ClientErrorKind};
+use solana_client::nonblocking::pubsub_client::PubsubClient;
+use solana_client::nonblocking::rpc_client::RpcClient;
+use solana_client::pubsub_client::PubsubClientError;
+use solana_client::rpc_client::SerializableTransaction;
+use solana_client::rpc_config::{
+    RpcSendTransactionConfig, RpcSignatureSubscribeConfig, RpcSimulateTransactionConfig,
+};
+use solana_client::rpc_response::{RpcSignatureResult, TransactionError, UiTransactionError};
+use solana_commitment_config::CommitmentConfig;
+use solana_keypair::Keypair;
+use solana_keypair::Signer;
+use solana_pubkey::Pubkey;
+use solana_signature::Signature;
+use solana_signer::SignerError;
+use solana_transaction::versioned::VersionedTransaction;
+use std::fmt::{Debug, Formatter};
+use std::sync::Arc;
+use std::time::Duration;
+use x402_types::chain::{ChainId, ChainProviderOps, FromConfig};
+use x402_types::proto::PaymentVerificationError;
+use x402_types::scheme::X402SchemeFacilitatorError;
+
+use crate::chain::config::SolanaChainConfig;
+use crate::chain::types::{Address, SolanaChainReference};
+
+/// Errors that can occur when interacting with a Solana chain provider.
+#[derive(thiserror::Error, Debug)]
+pub enum SolanaChainProviderError {
+    /// Failed to sign a transaction.
+    #[error(transparent)]
+    Signer(#[from] SignerError),
+    /// The transaction was invalid or failed simulation.
+    #[error("Invalid transaction: {0}")]
+    InvalidTransaction(#[from] UiTransactionError),
+    /// RPC transport error.
+    #[error(transparent)]
+    Transport(Box<ClientErrorKind>),
+    /// WebSocket pubsub transport error.
+    #[error(transparent)]
+    PubsubTransport(#[from] PubsubClientError),
+    #[error("{0}")]
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    Custom(String),
+}
+
+impl From<ClientError> for SolanaChainProviderError {
+    fn from(value: ClientError) -> Self {
+        SolanaChainProviderError::Transport(value.kind)
+    }
+}
+
+impl From<SolanaChainProviderError> for X402SchemeFacilitatorError {
+    fn from(value: SolanaChainProviderError) -> Self {
+        Self::OnchainFailure(value.to_string())
+    }
+}
+
+impl From<SolanaChainProviderError> for PaymentVerificationError {
+    fn from(value: SolanaChainProviderError) -> Self {
+        Self::TransactionSimulation(value.to_string())
+    }
+}
+
+/// Provider for interacting with a Solana blockchain.
+///
+/// This provider handles transaction signing, simulation, and submission for
+/// Solana-based x402 payments. It supports both RPC polling and WebSocket
+/// subscriptions for transaction confirmation.
+///
+/// # Configuration
+///
+/// The provider requires:
+/// - A keypair for signing transactions (the fee payer)
+/// - An RPC endpoint URL
+/// - Optionally, a WebSocket pubsub URL for faster confirmations
+/// - Compute unit limits and prices for transaction prioritization
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_solana::chain::SolanaChainProvider;
+/// use x402_chain_solana::chain::SolanaChainConfig;
+///
+/// let provider = SolanaChainProvider::from_config(&config).await?;
+/// println!("Fee payer: {}", provider.fee_payer());
+/// ```
+pub struct SolanaChainProvider {
+    /// The Solana network this provider connects to.
+    chain: SolanaChainReference,
+    /// The keypair used for signing transactions.
+    keypair: Arc<Keypair>,
+    /// The RPC client for sending requests.
+    rpc_client: Arc<RpcClient>,
+    /// Optional WebSocket client for subscriptions.
+    pubsub_client: Option<Arc<PubsubClient>>,
+    /// Maximum compute units allowed per transaction.
+    max_compute_unit_limit: u32,
+    /// Maximum price per compute unit (in micro-lamports).
+    max_compute_unit_price: u64,
+}
+
+impl Debug for SolanaChainProvider {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("SolanaChainProvider")
+            .field("pubkey", &self.keypair.pubkey())
+            .field("chain", &self.chain)
+            .field("rpc_url", &self.rpc_client.url())
+            .finish()
+    }
+}
+
+impl SolanaChainProvider {
+    /// Creates a new Solana chain provider.
+    ///
+    /// # Parameters
+    ///
+    /// - `keypair`: The keypair used for signing transactions (fee payer)
+    /// - `rpc_url`: The HTTP RPC endpoint URL
+    /// - `pubsub_url`: Optional WebSocket pubsub endpoint for faster confirmations
+    /// - `chain`: The Solana network identifier
+    /// - `max_compute_unit_limit`: Maximum compute units per transaction
+    /// - `max_compute_unit_price`: Maximum price per compute unit in micro-lamports
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if the WebSocket connection fails to establish.
+    pub async fn new(
+        keypair: Keypair,
+        rpc_url: String,
+        pubsub_url: Option<String>,
+        chain: SolanaChainReference,
+        max_compute_unit_limit: u32,
+        max_compute_unit_price: u64,
+    ) -> Result<Self, PubsubClientError> {
+        #[cfg(feature = "telemetry")]
+        {
+            let signer_addresses = vec![keypair.pubkey()];
+            let chain_id: ChainId = chain.into();
+            tracing::info!(
+                chain = %chain_id,
+                rpc = rpc_url,
+                pubsub = ?pubsub_url,
+                signers = ?signer_addresses,
+                max_compute_unit_limit,
+                max_compute_unit_price,
+                "Using Solana provider"
+            );
+        }
+        let rpc_client = RpcClient::new(rpc_url);
+        let pubsub_client = if let Some(pubsub_url) = pubsub_url {
+            let client = PubsubClient::new(pubsub_url).await?;
+            Some(client)
+        } else {
+            None
+        };
+        Ok(Self {
+            keypair: Arc::new(keypair),
+            chain,
+            rpc_client: Arc::new(rpc_client),
+            pubsub_client: pubsub_client.map(Arc::new),
+            max_compute_unit_limit,
+            max_compute_unit_price,
+        })
+    }
+
+    /// Returns a cloned reference to the RPC client.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn rpc_client(&self) -> Arc<RpcClient> {
+        Arc::clone(&self.rpc_client)
+    }
+
+    /// Returns a cloned reference to the optional pubsub client.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn pubsub_client(&self) -> Option<Arc<PubsubClient>> {
+        self.pubsub_client.clone()
+    }
+
+    /// Sends a signed transaction to the network without waiting for confirmation.
+    ///
+    /// This method submits the transaction with `skip_preflight: true` to avoid
+    /// simulation delays. The transaction should already be signed.
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if the RPC request fails or the transaction is rejected.
+    pub async fn send(
+        &self,
+        tx: &VersionedTransaction,
+    ) -> Result<Signature, SolanaChainProviderError> {
+        let signature = self
+            .rpc_client
+            .send_transaction_with_config(
+                tx,
+                RpcSendTransactionConfig {
+                    skip_preflight: true,
+                    ..RpcSendTransactionConfig::default()
+                },
+            )
+            .await?;
+        Ok(signature)
+    }
+}
+
+#[async_trait::async_trait]
+impl FromConfig<SolanaChainConfig> for SolanaChainProvider {
+    async fn from_config(config: &SolanaChainConfig) -> Result<Self, Box<dyn std::error::Error>> {
+        let rpc_url = config.rpc();
+        let pubsub_url = config.pubsub().clone().map(|url| url.to_string());
+        let keypair = Keypair::from_base58_string(&config.signer().to_string());
+        let max_compute_unit_limit = config.max_compute_unit_limit();
+        let max_compute_unit_price = config.max_compute_unit_price();
+        let chain = config.chain_reference();
+        let provider = Self::new(
+            keypair,
+            rpc_url.to_string(),
+            pubsub_url,
+            chain,
+            max_compute_unit_limit,
+            max_compute_unit_price,
+        )
+        .await?;
+        Ok(provider)
+    }
+}
+
+impl ChainProviderOps for SolanaChainProvider {
+    fn signer_addresses(&self) -> Vec<String> {
+        vec![self.fee_payer().to_string()]
+    }
+
+    fn chain_id(&self) -> ChainId {
+        self.chain.into()
+    }
+}
+
+/// Trait for Solana chain provider operations.
+///
+/// This trait abstracts the core operations needed for x402 payment processing
+/// on Solana, including transaction simulation, signing, and confirmation.
+pub trait SolanaChainProviderLike {
+    /// Simulates a transaction with the given configuration.
+    fn simulate_transaction_with_config(
+        &self,
+        tx: &VersionedTransaction,
+        cfg: RpcSimulateTransactionConfig,
+    ) -> impl Future<Output = Result<(), SolanaChainProviderError>> + Send;
+
+    /// Fetches multiple accounts in a single RPC call.
+    fn get_multiple_accounts(
+        &self,
+        pubkeys: &[Pubkey],
+    ) -> impl Future<Output = Result<Vec<Option<Account>>, SolanaChainProviderError>> + Send;
+
+    /// Returns the maximum compute unit limit for transactions.
+    fn max_compute_unit_limit(&self) -> u32;
+
+    /// Returns the maximum compute unit price in micro-lamports.
+    fn max_compute_unit_price(&self) -> u64;
+
+    /// Returns the public key of the fee payer.
+    fn pubkey(&self) -> Pubkey;
+
+    /// Returns the fee payer address.
+    fn fee_payer(&self) -> Address;
+
+    /// Signs a transaction with the provider's keypair.
+    fn sign(
+        &self,
+        tx: VersionedTransaction,
+    ) -> Result<VersionedTransaction, SolanaChainProviderError>;
+
+    /// Sends a transaction and waits for confirmation.
+    ///
+    /// Uses WebSocket subscription if available, otherwise polls for confirmation.
+    fn send_and_confirm(
+        &self,
+        tx: &VersionedTransaction,
+        commitment_config: CommitmentConfig,
+    ) -> impl Future<Output = Result<Signature, SolanaChainProviderError>> + Send;
+}
+
+impl SolanaChainProviderLike for SolanaChainProvider {
+    async fn simulate_transaction_with_config(
+        &self,
+        tx: &VersionedTransaction,
+        cfg: RpcSimulateTransactionConfig,
+    ) -> Result<(), SolanaChainProviderError> {
+        let sim = self
+            .rpc_client
+            .simulate_transaction_with_config(tx, cfg)
+            .await?;
+        match sim.value.err {
+            None => Ok(()),
+            Some(e) => Err(SolanaChainProviderError::InvalidTransaction(e)),
+        }
+    }
+
+    async fn get_multiple_accounts(
+        &self,
+        pubkeys: &[Pubkey],
+    ) -> Result<Vec<Option<Account>>, SolanaChainProviderError> {
+        let accounts = self.rpc_client.get_multiple_accounts(pubkeys).await?;
+        Ok(accounts)
+    }
+
+    fn max_compute_unit_limit(&self) -> u32 {
+        self.max_compute_unit_limit
+    }
+
+    fn max_compute_unit_price(&self) -> u64 {
+        self.max_compute_unit_price
+    }
+
+    fn pubkey(&self) -> Pubkey {
+        self.keypair.pubkey()
+    }
+
+    fn fee_payer(&self) -> Address {
+        Address::new(self.keypair.pubkey())
+    }
+
+    fn sign(
+        &self,
+        tx: VersionedTransaction,
+    ) -> Result<VersionedTransaction, SolanaChainProviderError> {
+        let mut tx = tx.clone();
+        let msg_bytes = tx.message.serialize();
+        let signature = self.keypair.try_sign_message(msg_bytes.as_slice())?;
+        // Required signatures are the first N account keys
+        let num_required = tx.message.header().num_required_signatures as usize;
+        let static_keys = tx.message.static_account_keys();
+        // Find signerâ€™s position
+        let pos = static_keys[..num_required]
+            .iter()
+            .position(|k| *k == self.pubkey())
+            .ok_or(SolanaChainProviderError::InvalidTransaction(
+                UiTransactionError::from(TransactionError::InvalidAccountIndex),
+            ))?;
+        // Ensure signature vector is large enough, then place the signature
+        if tx.signatures.len() < num_required {
+            tx.signatures.resize(num_required, Signature::default());
+        }
+        // tx.signatures.push(signature);
+        tx.signatures[pos] = signature;
+        Ok(tx)
+    }
+
+    async fn send_and_confirm(
+        &self,
+        tx: &VersionedTransaction,
+        commitment_config: CommitmentConfig,
+    ) -> Result<Signature, SolanaChainProviderError> {
+        let tx_sig = tx.get_signature();
+
+        use futures_util::stream::StreamExt;
+
+        if let Some(pubsub_client) = self.pubsub_client.as_ref() {
+            let config = RpcSignatureSubscribeConfig {
+                commitment: Some(commitment_config),
+                enable_received_notification: None,
+            };
+            let (mut stream, unsubscribe) = pubsub_client
+                .signature_subscribe(tx_sig, Some(config))
+                .await?;
+            if let Err(e) = self.send(tx).await {
+                #[cfg(feature = "telemetry")]
+                tracing::error!(error = %e, "Failed to send transaction");
+                unsubscribe().await;
+                return Err(e);
+            }
+            if let Some(response) = stream.next().await {
+                let error = if let RpcSignatureResult::ProcessedSignature(r) = response.value {
+                    r.err
+                } else {
+                    None
+                };
+                match error {
+                    None => Ok(*tx_sig),
+                    Some(error) => Err(SolanaChainProviderError::InvalidTransaction(error)),
+                }
+            } else {
+                Err(SolanaChainProviderError::Transport(Box::new(
+                    ClientErrorKind::Custom(
+                        "Can not get response from signatureSubscribe".to_string(),
+                    ),
+                )))
+            }
+        } else {
+            self.send(tx).await?;
+            loop {
+                let confirmed = self
+                    .rpc_client
+                    .confirm_transaction_with_commitment(tx_sig, commitment_config)
+                    .await?;
+                if confirmed.value {
+                    return Ok(*tx_sig);
+                }
+                tokio::time::sleep(Duration::from_millis(200)).await;
+            }
+        }
+    }
+}
+
+impl<T: SolanaChainProviderLike> SolanaChainProviderLike for Arc<T> {
+    fn simulate_transaction_with_config(
+        &self,
+        tx: &VersionedTransaction,
+        cfg: RpcSimulateTransactionConfig,
+    ) -> impl Future<Output = Result<(), SolanaChainProviderError>> + Send {
+        (**self).simulate_transaction_with_config(tx, cfg)
+    }
+
+    fn get_multiple_accounts(
+        &self,
+        pubkeys: &[Pubkey],
+    ) -> impl Future<Output = Result<Vec<Option<Account>>, SolanaChainProviderError>> + Send {
+        (**self).get_multiple_accounts(pubkeys)
+    }
+
+    fn max_compute_unit_limit(&self) -> u32 {
+        (**self).max_compute_unit_limit()
+    }
+
+    fn max_compute_unit_price(&self) -> u64 {
+        (**self).max_compute_unit_price()
+    }
+
+    fn pubkey(&self) -> Pubkey {
+        (**self).pubkey()
+    }
+
+    fn fee_payer(&self) -> Address {
+        (**self).fee_payer()
+    }
+
+    fn sign(
+        &self,
+        tx: VersionedTransaction,
+    ) -> Result<VersionedTransaction, SolanaChainProviderError> {
+        (**self).sign(tx)
+    }
+
+    fn send_and_confirm(
+        &self,
+        tx: &VersionedTransaction,
+        commitment_config: CommitmentConfig,
+    ) -> impl Future<Output = Result<Signature, SolanaChainProviderError>> + Send {
+        (**self).send_and_confirm(tx, commitment_config)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/rpc.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/rpc.rs
new file mode 100644
index 0000000..e05580b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/rpc.rs
@@ -0,0 +1,66 @@
+//! Trait abstraction for Solana RPC client operations.
+//!
+//! This module provides a trait that abstracts common RPC operations,
+//! allowing for easier testing and mocking of Solana RPC interactions.
+
+use solana_account::Account;
+use solana_client::client_error::ClientError;
+use solana_client::nonblocking::rpc_client::RpcClient;
+use solana_client::rpc_config::RpcSimulateTransactionConfig;
+use solana_client::rpc_response::{RpcPrioritizationFee, RpcResult, RpcSimulateTransactionResult};
+use solana_message::Hash;
+use solana_pubkey::Pubkey;
+use solana_transaction::versioned::VersionedTransaction;
+
+/// Trait for Solana RPC client operations.
+///
+/// This trait abstracts the most commonly used RPC methods for x402 payment
+/// processing, making it easier to test and mock RPC interactions.
+pub trait RpcClientLike {
+    /// Fetches account data for the given public key.
+    fn get_account(
+        &self,
+        pubkey: &Pubkey,
+    ) -> impl Future<Output = Result<Account, ClientError>> + Send;
+
+    /// Simulates a transaction with the given configuration.
+    fn simulate_transaction_with_config(
+        &self,
+        transaction: &VersionedTransaction,
+        config: RpcSimulateTransactionConfig,
+    ) -> impl Future<Output = RpcResult<RpcSimulateTransactionResult>> + Send;
+
+    /// Fetches recent prioritization fees for the given addresses.
+    fn get_recent_prioritization_fees(
+        &self,
+        addresses: &[Pubkey],
+    ) -> impl Future<Output = Result<Vec<RpcPrioritizationFee>, ClientError>> + Send;
+
+    /// Fetches the latest blockhash.
+    fn get_latest_blockhash(&self) -> impl Future<Output = Result<Hash, ClientError>> + Send;
+}
+
+impl<Container: AsRef<RpcClient>> RpcClientLike for Container {
+    fn get_account(
+        &self,
+        pubkey: &Pubkey,
+    ) -> impl Future<Output = Result<Account, ClientError>> + Send {
+        RpcClient::get_account(self.as_ref(), pubkey)
+    }
+    fn simulate_transaction_with_config(
+        &self,
+        transaction: &VersionedTransaction,
+        config: RpcSimulateTransactionConfig,
+    ) -> impl Future<Output = RpcResult<RpcSimulateTransactionResult>> + Send {
+        RpcClient::simulate_transaction_with_config(self.as_ref(), transaction, config)
+    }
+    fn get_recent_prioritization_fees(
+        &self,
+        addresses: &[Pubkey],
+    ) -> impl Future<Output = Result<Vec<RpcPrioritizationFee>, ClientError>> + Send {
+        RpcClient::get_recent_prioritization_fees(self.as_ref(), addresses)
+    }
+    fn get_latest_blockhash(&self) -> impl Future<Output = Result<Hash, ClientError>> + Send {
+        RpcClient::get_latest_blockhash(self.as_ref())
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/types.rs
new file mode 100644
index 0000000..cc393af
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/chain/types.rs
@@ -0,0 +1,419 @@
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use solana_pubkey::Pubkey;
+use std::fmt::{Debug, Display, Formatter};
+use std::str::FromStr;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::util::money_amount::{MoneyAmount, MoneyAmountParseError};
+
+use crate::networks::KnownNetworkSolana;
+
+/// The CAIP-2 namespace for Solana chains.
+pub const SOLANA_NAMESPACE: &str = "solana";
+
+/// A Solana chain reference consisting of 32 ASCII characters.
+///
+/// The reference is the first 32 characters of the base58-encoded genesis block hash,
+/// which uniquely identifies a Solana network. This follows the CAIP-2 standard for
+/// Solana chain identification.
+///
+/// # Well-Known References
+///
+/// - Mainnet: `5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`
+/// - Devnet: `EtWTRABZaYq6iMfeYKouRu166VU2xqa1`
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_solana::chain::SolanaChainReference;
+/// use x402_chain_solana::KnownNetworkSolana;
+///
+/// let mainnet = SolanaChainReference::solana();
+/// assert_eq!(mainnet.as_str(), "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+/// ```
+#[derive(Clone, Copy, PartialEq, Eq, Hash)]
+pub struct SolanaChainReference([u8; 32]);
+
+impl SolanaChainReference {
+    /// Creates a new [`SolanaChainReference`] from a 32-byte ASCII array.
+    ///
+    /// # Panics
+    ///
+    /// This function does not validate that the bytes are valid ASCII.
+    /// Use [`FromStr`] for validated parsing.
+    #[allow(dead_code)]
+    pub const fn new(bytes: [u8; 32]) -> Self {
+        Self(bytes)
+    }
+
+    /// Returns the underlying bytes.
+    #[allow(dead_code)]
+    pub fn as_bytes(&self) -> &[u8; 32] {
+        &self.0
+    }
+
+    /// Returns the chain reference as a string.
+    pub fn as_str(&self) -> &str {
+        // Safe because we validate ASCII on construction
+        std::str::from_utf8(&self.0).expect("SolanaChainReference contains valid ASCII")
+    }
+}
+
+impl KnownNetworkSolana<SolanaChainReference> for SolanaChainReference {
+    fn solana() -> Self {
+        Self::new(*b"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp")
+    }
+
+    fn solana_devnet() -> Self {
+        Self::new(*b"EtWTRABZaYq6iMfeYKouRu166VU2xqa1")
+    }
+}
+
+impl Debug for SolanaChainReference {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        f.write_str("SolanaChainReference(")?;
+        f.write_str(self.as_str())?;
+        f.write_str(")")
+    }
+}
+
+impl FromStr for SolanaChainReference {
+    type Err = SolanaChainReferenceFormatError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        if !(s.is_ascii() && s.len() == 32) {
+            return Err(SolanaChainReferenceFormatError::InvalidReference(
+                s.to_string(),
+            ));
+        }
+        let mut bytes = [0u8; 32];
+        bytes.copy_from_slice(s.as_bytes());
+        Ok(Self(bytes))
+    }
+}
+
+impl Display for SolanaChainReference {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        f.write_str(self.as_str())
+    }
+}
+
+impl Serialize for SolanaChainReference {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(self.as_str())
+    }
+}
+
+impl<'de> Deserialize<'de> for SolanaChainReference {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        s.parse().map_err(serde::de::Error::custom)
+    }
+}
+
+impl From<SolanaChainReference> for ChainId {
+    fn from(value: SolanaChainReference) -> Self {
+        ChainId::new(SOLANA_NAMESPACE, value.as_str())
+    }
+}
+
+impl TryFrom<ChainId> for SolanaChainReference {
+    type Error = SolanaChainReferenceFormatError;
+
+    fn try_from(value: ChainId) -> Result<Self, Self::Error> {
+        if value.namespace != SOLANA_NAMESPACE {
+            return Err(SolanaChainReferenceFormatError::InvalidNamespace(
+                value.namespace,
+            ));
+        }
+        let solana_chain_reference = Self::from_str(&value.reference)
+            .map_err(|_| SolanaChainReferenceFormatError::InvalidReference(value.reference))?;
+        Ok(solana_chain_reference)
+    }
+}
+
+/// Error type for parsing Solana chain references.
+#[derive(Debug, thiserror::Error)]
+pub enum SolanaChainReferenceFormatError {
+    /// The namespace was not "solana".
+    #[error("Invalid namespace {0}, expected solana")]
+    InvalidNamespace(String),
+    /// The reference was not a valid 32-character ASCII string.
+    #[error("Invalid solana chain reference {0}")]
+    InvalidReference(String),
+}
+
+/// Information about an SPL token deployment on a Solana network.
+///
+/// This type contains all the information needed to interact with a specific
+/// token on a specific Solana network, including the mint address and decimal
+/// precision.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_chain_solana::chain::{SolanaChainReference, SolanaTokenDeployment, Address};
+/// use x402_chain_solana::KnownNetworkSolana;
+/// use std::str::FromStr;
+///
+/// // USDC on Solana mainnet
+/// let usdc = SolanaTokenDeployment::new(
+///     SolanaChainReference::solana(),
+///     Address::from_str("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v").unwrap(),
+///     6,
+/// );
+///
+/// // Parse a human-readable amount
+/// let amount = usdc.parse("10.50").unwrap();
+/// assert_eq!(amount.amount, 10_500_000); // 10.50 * 10^6
+/// ```
+#[derive(Clone, Debug, Eq, PartialEq, Hash)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct SolanaTokenDeployment {
+    /// The Solana network where this token is deployed.
+    pub chain_reference: SolanaChainReference,
+    /// The SPL token mint address.
+    pub address: Address,
+    /// The number of decimal places for this token.
+    pub decimals: u8,
+}
+
+impl SolanaTokenDeployment {
+    /// Creates a new token deployment.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn new(chain_reference: SolanaChainReference, address: Address, decimals: u8) -> Self {
+        Self {
+            chain_reference,
+            address,
+            decimals,
+        }
+    }
+
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn amount(&self, v: u64) -> DeployedTokenAmount<u64, SolanaTokenDeployment> {
+        DeployedTokenAmount {
+            amount: v,
+            token: self.clone(),
+        }
+    }
+
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn parse<V>(
+        &self,
+        v: V,
+    ) -> Result<DeployedTokenAmount<u64, SolanaTokenDeployment>, MoneyAmountParseError>
+    where
+        V: TryInto<MoneyAmount>,
+        MoneyAmountParseError: From<<V as TryInto<MoneyAmount>>::Error>,
+    {
+        let money_amount = v.try_into()?;
+        let scale = money_amount.scale();
+        let token_scale = self.decimals as u32;
+        if scale > token_scale {
+            return Err(MoneyAmountParseError::WrongPrecision {
+                money: scale,
+                token: token_scale,
+            });
+        }
+        let scale_diff = token_scale - scale;
+        let multiplier = 10u64
+            .checked_pow(scale_diff)
+            .ok_or(MoneyAmountParseError::OutOfRange)?;
+        let digits = u64::try_from(money_amount.mantissa()).expect("mantissa fits in u64");
+        let value = digits
+            .checked_mul(multiplier)
+            .ok_or(MoneyAmountParseError::OutOfRange)?;
+        Ok(DeployedTokenAmount {
+            amount: value,
+            token: self.clone(),
+        })
+    }
+}
+
+/// A Solana public key address.
+///
+/// This is a wrapper around [`Pubkey`] that provides serialization as a
+/// base58-encoded string, suitable for use in x402 protocol messages.
+///
+/// # Example
+///
+/// ```
+/// use x402_chain_solana::chain::Address;
+/// use std::str::FromStr;
+///
+/// let addr = Address::from_str("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v").unwrap();
+/// assert_eq!(addr.to_string(), "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
+/// ```
+#[derive(Clone, Debug, Hash, PartialEq, Eq)]
+pub struct Address(Pubkey);
+
+impl Address {
+    /// Creates a new address from a [`Pubkey`].
+    pub const fn new(pubkey: Pubkey) -> Self {
+        Self(pubkey)
+    }
+
+    pub fn pubkey(&self) -> &Pubkey {
+        &self.0
+    }
+}
+
+impl From<Pubkey> for Address {
+    fn from(pubkey: Pubkey) -> Self {
+        Self(pubkey)
+    }
+}
+
+impl From<Address> for Pubkey {
+    fn from(address: Address) -> Self {
+        address.0
+    }
+}
+
+impl AsRef<[u8]> for Address {
+    fn as_ref(&self) -> &[u8] {
+        self.0.as_ref()
+    }
+}
+
+impl Serialize for Address {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        let base58_string = self.0.to_string();
+        serializer.serialize_str(&base58_string)
+    }
+}
+
+impl<'de> Deserialize<'de> for Address {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        let pubkey = Pubkey::from_str(&s)
+            .map_err(|_| serde::de::Error::custom("Failed to decode Solana address"))?;
+        Ok(Self(pubkey))
+    }
+}
+
+impl Display for Address {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl FromStr for Address {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let pubkey =
+            Pubkey::from_str(s).map_err(|_| format!("Failed to decode Solana address: {s}"))?;
+        Ok(Self(pubkey))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn create_test_deployment(decimals: u8) -> SolanaTokenDeployment {
+        let chain_ref = SolanaChainReference::solana();
+        // Use a well-known test address (USDC on Solana devnet)
+        let address = Address::from_str("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZ5nc4pb").unwrap();
+        SolanaTokenDeployment::new(chain_ref, address, decimals)
+    }
+
+    #[test]
+    fn test_parse_whole_number() {
+        let deployment = create_test_deployment(6); // 6 decimals like USDC
+        let result = deployment.parse("100");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 100_000_000); // 100 * 10^6
+    }
+
+    #[test]
+    fn test_parse_with_decimals() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("1.50");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 1_500_000); // 1.50 * 10^6
+    }
+
+    #[test]
+    fn test_parse_zero_decimals() {
+        let deployment = create_test_deployment(0);
+        let result = deployment.parse("42");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 42);
+    }
+
+    #[test]
+    fn test_parse_precision_too_high() {
+        let deployment = create_test_deployment(2); // Only 2 decimals
+        let result = deployment.parse("1.234"); // 3 decimals - should fail
+        assert!(result.is_err());
+        let err = result.unwrap_err();
+        assert!(matches!(err, MoneyAmountParseError::WrongPrecision { .. }));
+    }
+
+    #[test]
+    fn test_parse_exact_precision() {
+        let deployment = create_test_deployment(9); // 9 decimals
+        let result = deployment.parse("0.123456789");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 123_456_789);
+    }
+
+    #[test]
+    fn test_parse_smallest_amount() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("0.000001");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 1);
+    }
+
+    #[test]
+    fn test_parse_with_currency_symbol() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("$10.50");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 10_500_000);
+    }
+
+    #[test]
+    fn test_parse_with_commas() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("1,000");
+        assert!(result.is_ok());
+        assert_eq!(result.unwrap().amount, 1_000_000_000);
+    }
+
+    #[test]
+    fn test_parse_large_amount() {
+        let deployment = create_test_deployment(6);
+        let result = deployment.parse("999999999");
+        assert!(result.is_ok());
+        // 999999999 * 10^6 = 999999999000000
+        assert_eq!(result.unwrap().amount, 999_999_999_000_000);
+    }
+
+    #[test]
+    fn test_parse_overflow_returns_error() {
+        // Create a deployment with 19 decimals (beyond what u64 can handle)
+        let deployment = create_test_deployment(19);
+        // 999999999 with 19 decimals = 999999999 * 10^19, which overflows u64
+        let result = deployment.parse("999999999");
+        assert!(result.is_err());
+        assert!(matches!(
+            result.unwrap_err(),
+            MoneyAmountParseError::OutOfRange
+        ));
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/lib.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/lib.rs
new file mode 100644
index 0000000..064c5a7
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/lib.rs
@@ -0,0 +1,93 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Solana chain support for the x402 payment protocol.
+//!
+//! This crate provides implementations of the x402 payment protocol for Solana blockchain.
+//! It supports both V1 and V2 protocol versions with the "exact" payment scheme based on
+//! SPL Token `transfer` instructions with pre-signed authorization.
+//!
+//! # Features
+//!
+//! - **V1 and V2 Protocol Support**: Implements both protocol versions with network name
+//!   (V1) and CAIP-2 chain ID (V2) addressing
+//! - **SPL Token Payments**: Token transfers using pre-signed transaction authorization
+//! - **Compute Budget Management**: Automatic compute unit limit and price configuration
+//! - **WebSocket Support**: Optional pubsub for faster transaction confirmation
+//! - **Balance Verification**: On-chain balance checks before settlement
+//!
+//! # Architecture
+//!
+//! The crate is organized into several modules:
+//!
+//! - [`chain`] - Core Solana chain types, providers, and configuration
+//! - [`v1_solana_exact`] - V1 protocol implementation with network names
+//! - [`v2_solana_exact`] - V2 protocol implementation with CAIP-2 chain IDs
+//!
+//! # Feature Flags
+//!
+//! - `server` - Server-side price tag generation
+//! - `client` - Client-side payment signing
+//! - `facilitator` - Facilitator-side payment verification and settlement
+//! - `telemetry` - OpenTelemetry tracing support
+//!
+//! # Usage Examples
+//!
+//! ## Server: Creating a Price Tag
+//!
+//! ```ignore
+//! use x402_chain_solana::{V1SolanaExact, KnownNetworkSolana};
+//! use x402_types::networks::USDC;
+//!
+//! // Get USDC deployment on Solana mainnet
+//! let usdc = USDC::solana();
+//!
+//! // Create a price tag for 1 USDC
+//! let price_tag = V1SolanaExact::price_tag(
+//!     "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
+//!     usdc.amount(1_000_000u64),
+//! );
+//! ```
+//!
+//! ## Client: Signing a Payment
+//!
+//! ```ignore
+//! use x402_chain_solana::V1SolanaExactClient;
+//! use solana_keypair::Keypair;
+//!
+//! let keypair = Keypair::new();
+//! let client = V1SolanaExactClient::new(keypair);
+//!
+//! // Use client to sign payment candidates
+//! let candidates = client.accept(&payment_required);
+//! ```
+//!
+//! ## Facilitator: Verifying and Settling
+//!
+//! ```ignore
+//! use x402_chain_solana::{V1SolanaExact, SolanaChainProvider};
+//! use x402_types::scheme::X402SchemeFacilitatorBuilder;
+//!
+//! let provider = SolanaChainProvider::from_config(&config).await?;
+//! let facilitator = V1SolanaExact.build(provider, None)?;
+//!
+//! // Verify payment
+//! let verify_response = facilitator.verify(&verify_request).await?;
+//!
+//! // Settle payment
+//! let settle_response = facilitator.settle(&settle_request).await?;
+//! ```
+
+pub mod chain;
+pub mod v1_solana_exact;
+pub mod v2_solana_exact;
+
+mod networks;
+pub use networks::*;
+
+pub use v1_solana_exact::V1SolanaExact;
+pub use v2_solana_exact::V2SolanaExact;
+
+#[cfg(feature = "client")]
+pub use v1_solana_exact::client::V1SolanaExactClient;
+#[cfg(feature = "client")]
+pub use v2_solana_exact::client::V2SolanaExactClient;
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/networks.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/networks.rs
new file mode 100644
index 0000000..212b7ad
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/networks.rs
@@ -0,0 +1,72 @@
+use solana_pubkey::pubkey;
+use x402_types::chain::ChainId;
+use x402_types::networks::USDC;
+
+use crate::chain::{SolanaChainReference, SolanaTokenDeployment};
+
+/// Trait providing convenient methods to get instances for well-known Solana networks.
+///
+/// This trait can be implemented for any type to provide static methods that create
+/// instances for well-known Solana blockchain networks. Each method returns `Self`, allowing
+/// the trait to be used with different types that need per-network configuration.
+///
+/// # Use Cases
+///
+/// - **ChainId**: Get CAIP-2 chain identifiers for Solana networks
+/// - **Token Deployments**: Get per-chain token addresses (e.g., USDC on different Solana networks)
+/// - **Network Configuration**: Get network-specific configuration objects for Solana chains
+/// - **Any Per-Network Data**: Any type that needs Solana network-specific instances
+///
+/// # Examples
+///
+/// ```ignore
+/// use x402_rs::chain::ChainId;
+/// use x402_rs::known::KnownNetworkSolana;
+///
+/// // Get Solana mainnet chain ID
+/// let solana = ChainId::solana();
+/// assert_eq!(solana.namespace, "solana");
+/// assert_eq!(solana.reference, "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+///
+/// // Get Solana devnet chain ID
+/// let devnet = ChainId::solana_devnet();
+/// assert_eq!(devnet.namespace, "solana");
+/// ```
+#[allow(dead_code)]
+pub trait KnownNetworkSolana<A> {
+    /// Returns the instance for Solana mainnet (solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp)
+    fn solana() -> A;
+    /// Returns the instance for Solana devnet (solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1)
+    fn solana_devnet() -> A;
+}
+
+/// Implementation of KnownNetworkSolana for ChainId.
+///
+/// Provides convenient static methods to create ChainId instances for well-known
+/// Solana blockchain networks. Each method returns a properly configured ChainId with the
+/// "solana" namespace and the correct chain reference.
+///
+/// This is one example of implementing the KnownNetworkSolana trait. Other types
+/// (such as token address types) can also implement this trait to provide
+/// per-network instances with better developer experience.
+impl KnownNetworkSolana<ChainId> for ChainId {
+    fn solana() -> ChainId {
+        SolanaChainReference::solana().into()
+    }
+
+    fn solana_devnet() -> ChainId {
+        SolanaChainReference::solana_devnet().into()
+    }
+}
+
+impl KnownNetworkSolana<SolanaTokenDeployment> for USDC {
+    fn solana() -> SolanaTokenDeployment {
+        let address = pubkey!("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
+        SolanaTokenDeployment::new(SolanaChainReference::solana(), address.into(), 6)
+    }
+
+    fn solana_devnet() -> SolanaTokenDeployment {
+        let address = pubkey!("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU");
+        SolanaTokenDeployment::new(SolanaChainReference::solana_devnet(), address.into(), 6)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/README.md b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/README.md
new file mode 100644
index 0000000..1a53d60
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/README.md
@@ -0,0 +1,172 @@
+# V1 Solana Exact Scheme
+
+This module implements the `exact` payment scheme for Solana in the x402 protocol. It verifies and settles SPL Token transfers using the `TransferChecked` instruction.
+
+## Overview
+
+The V1 Solana Exact scheme validates that a transaction contains a valid token transfer to the expected recipient with the correct amount. It supports both SPL Token and Token-2022 programs.
+
+## Transaction Structure
+
+A valid transaction must have the following structure:
+
+| Index | Instruction                                 | Required |
+|-------|---------------------------------------------|----------|
+| 0     | `SetComputeUnitLimit`                       | Yes      |
+| 1     | `SetComputeUnitPrice`                       | Yes      |
+| 2     | `TransferChecked` (SPL Token or Token-2022) | Yes      |
+| 3+    | Additional instructions (configurable)      | Optional |
+
+## Flexible Instruction Verification
+
+### Background
+
+Third-party wallets like Phantom inject additional instructions into transactions for user protection. On Solana mainnet, Phantom adds the **Lighthouse program** (`L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95`) which provides security assertions.
+
+This caused payment failures because the original implementation strictly required exactly 3 instructions.
+
+**Related Issues:**
+- [coinbase/x402#828](https://github.com/coinbase/x402/issues/828) - Solana mainnet payments failing with Phantom wallet
+- [coinbase/x402#646](https://github.com/coinbase/x402/issues/646) - Comprehensive proposal for outcome-based verification
+- [coinbase/x402#829](https://github.com/coinbase/x402/pull/829) - TypeScript implementation of flexible facilitator instructions
+
+### Solution
+
+The scheme now supports configurable instruction verification through `V1SolanaExactFacilitatorConfig`:
+
+```rust
+pub struct V1SolanaExactFacilitatorConfig {
+    /// Allow additional instructions beyond the required 3
+    /// Default: true
+    pub allow_additional_instructions: bool,
+
+    /// Maximum number of instructions allowed
+    /// Default: 10
+    pub max_instruction_count: usize,
+
+    /// Explicitly allowed program IDs for additional instructions
+    /// Default: [Phantom Lighthouse program]
+    pub allowed_program_ids: Vec<Address>,
+
+    /// Blocked program IDs (takes precedence over allowed)
+    /// Default: []
+    pub blocked_program_ids: Vec<Address>,
+
+    /// Require fee payer is NOT in any instruction's accounts
+    /// Default: true
+    pub require_fee_payer_not_in_instructions: bool,
+}
+```
+
+### Default Behavior
+
+By default, the scheme:
+- **Allows** additional instructions (to support Phantom and other wallets)
+- **Whitelists** the Phantom Lighthouse program (`L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95`)
+- **Limits** transactions to 10 instructions maximum
+- **Requires** the fee payer to not appear in any instruction's accounts (security)
+
+This means Phantom wallet transactions work **out of the box** without any configuration.
+
+### Configuration
+
+To customize the behavior, provide a config when building the facilitator:
+
+```json
+{
+  "schemes": [
+    {
+      "id": "v1-solana-exact",
+      "chains": "solana:*",
+      "config": {
+        "allowAdditionalInstructions": true,
+        "maxInstructionCount": 10,
+        "allowedProgramIds": [
+          "L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95",
+          "AnotherProgramIdHere"
+        ],
+        "blockedProgramIds": [],
+        "requireFeePayerNotInInstructions": true
+      }
+    }
+  ]
+}
+```
+
+### Strict Mode
+
+To disable additional instructions and enforce the original 3-instruction limit:
+
+```json
+{
+  "config": {
+    "allowAdditionalInstructions": false,
+    "maxInstructionCount": 3
+  }
+}
+```
+
+## Security Model
+
+### Fee Payer Protection
+
+The facilitator's fee payer signs the transaction to pay for gas. To prevent exploitation:
+
+1. **Fee payer isolation**: The fee payer must NOT appear in any instruction's accounts (configurable via `require_fee_payer_not_in_instructions`)
+2. **Fee payer not authority**: The fee payer cannot be the transfer authority
+3. **Compute budget limits**: Maximum compute unit limit and price are enforced
+
+### Program Allowlist
+
+When `allow_additional_instructions` is true:
+- Only programs in `allowed_program_ids` are permitted
+- Programs in `blocked_program_ids` are always rejected (takes precedence)
+- If `allowed_program_ids` is empty, NO additional programs are allowed
+
+### Verification Steps
+
+1. **Decode transaction** from base64
+2. **Verify compute instructions** at indices 0 and 1
+3. **Validate instruction structure** (count, allowed programs)
+4. **Verify TransferChecked** at index 2:
+   - Correct token program (SPL Token or Token-2022)
+   - Correct mint (asset)
+   - Correct destination (ATA derived from pay_to + asset)
+   - Correct amount
+5. **Fee payer safety check** (if enabled)
+6. **Simulate transaction** to verify it will succeed
+
+## CreateATA Not Supported
+
+The scheme does **not** support creating Associated Token Accounts (ATAs) in the payment transaction. The destination ATA must exist before the payment is submitted.
+
+**Rationale**: Creating ATAs on-the-fly adds complexity and potential attack vectors. The recipient should ensure their ATA exists before requesting payment.
+
+## Error Types
+
+| Error | Description |
+|-------|-------------|
+| `TooFewInstructions` | Transaction has fewer than 3 instructions |
+| `AdditionalInstructionsNotAllowed` | Extra instructions when `allow_additional_instructions` is false |
+| `InstructionCountExceedsMax` | Transaction exceeds `max_instruction_count` |
+| `BlockedProgram` | Instruction uses a blocked program |
+| `ProgramNotAllowed` | Instruction uses a program not in the allowed list |
+| `CreateATANotSupported` | Transaction contains CreateATA instruction |
+| `FeePayerIncludedInInstructionAccounts` | Fee payer found in instruction accounts |
+| `FeePayerTransferringFunds` | Fee payer is the transfer authority |
+| `AssetMismatch` | Mint doesn't match expected asset |
+| `RecipientMismatch` | Destination doesn't match expected ATA |
+| `InvalidPaymentAmount` | Transfer amount doesn't match requirement |
+
+## V2 Scheme
+
+The V2 Solana Exact scheme (`v2_solana_exact`) uses the same verification logic and configuration. It differs only in the protocol message format (V2 vs V1).
+
+## References
+
+- [x402 Protocol Specification](https://github.com/coinbase/x402)
+- [Issue #828: Solana mainnet payments failing](https://github.com/coinbase/x402/issues/828)
+- [Issue #646: Outcome-based verification proposal](https://github.com/coinbase/x402/issues/646)
+- [PR #829: Flexible facilitator instructions (TypeScript)](https://github.com/coinbase/x402/pull/829)
+- [Lighthouse by Phantom](https://www.lighthouse.voyage) - Phantom's transaction security program
+- [Lighthouse Program on Solscan](https://solscan.io/account/L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95)
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/client.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/client.rs
new file mode 100644
index 0000000..449f440
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/client.rs
@@ -0,0 +1,413 @@
+//! Client-side payment signing for the V1 Solana "exact" scheme.
+//!
+//! This module provides [`V1SolanaExactClient`] for building and signing
+//! SPL Token transfer transactions on Solana.
+//!
+//! # Features
+//!
+//! - Automatic compute unit estimation via simulation
+//! - Priority fee calculation from recent fees
+//! - SPL Token and Token-2022 support
+//! - Transaction building with proper instruction ordering
+//!
+//! # Usage
+//!
+//! ```rust
+//! use x402_chain_solana::v1_solana_exact::client::V1SolanaExactClient;
+//! use solana_client::nonblocking::rpc_client::RpcClient;
+//! use solana_keypair::Keypair;
+//!
+//! let keypair = Keypair::new();
+//! let rpc = RpcClient::new("https://api.mainnet-beta.solana.com".to_string());
+//! let client = V1SolanaExactClient::new(keypair, rpc);
+//! ```
+
+use alloy_primitives::U256;
+use async_trait::async_trait;
+use solana_client::rpc_config::RpcSimulateTransactionConfig;
+use solana_compute_budget_interface::ComputeBudgetInstruction;
+use solana_message::v0::Message as MessageV0;
+use solana_message::{Hash, VersionedMessage};
+use solana_pubkey::Pubkey;
+use solana_signature::Signature;
+use solana_signer::Signer;
+use solana_transaction::Instruction;
+use solana_transaction::versioned::VersionedTransaction;
+use spl_token::solana_program::program_pack::Pack;
+use x402_types::chain::ChainId;
+use x402_types::proto::PaymentRequired;
+use x402_types::proto::v1::X402Version1;
+use x402_types::util::Base64Bytes;
+
+use x402_types::scheme::X402SchemeId;
+use x402_types::scheme::client::{
+    PaymentCandidate, PaymentCandidateSigner, X402Error, X402SchemeClient,
+};
+
+use crate::chain::Address;
+use crate::chain::rpc::RpcClientLike;
+use crate::v1_solana_exact::types::{
+    ExactScheme, ExactSolanaPayload, PaymentPayload, PaymentRequirements,
+};
+use crate::v1_solana_exact::{ATA_PROGRAM_PUBKEY, TransactionInt, V1SolanaExact};
+
+/// Mint information for SPL tokens
+#[derive(Debug)]
+pub enum Mint {
+    Token { decimals: u8, token_program: Pubkey },
+    Token2022 { decimals: u8, token_program: Pubkey },
+}
+
+impl Mint {
+    pub fn token_program(&self) -> &Pubkey {
+        match self {
+            Mint::Token { token_program, .. } => token_program,
+            Mint::Token2022 { token_program, .. } => token_program,
+        }
+    }
+}
+
+/// Fetch mint information from the blockchain.
+pub async fn fetch_mint<R: RpcClientLike>(
+    mint_address: &Address,
+    rpc_client: &R,
+) -> Result<Mint, X402Error> {
+    let mint_pubkey = mint_address.pubkey();
+    let account = rpc_client
+        .get_account(mint_pubkey)
+        .await
+        .map_err(|e| X402Error::SigningError(format!("failed to fetch mint {mint_pubkey}: {e}")))?;
+    if account.owner == spl_token::id() {
+        let mint = spl_token::state::Mint::unpack(&account.data).map_err(|e| {
+            X402Error::SigningError(format!("failed to unpack mint {mint_pubkey}: {e}"))
+        })?;
+        Ok(Mint::Token {
+            decimals: mint.decimals,
+            token_program: spl_token::id(),
+        })
+    } else if account.owner == spl_token_2022::id() {
+        let mint = spl_token_2022::state::Mint::unpack(&account.data).map_err(|e| {
+            X402Error::SigningError(format!("failed to unpack mint {mint_pubkey}: {e}",))
+        })?;
+        Ok(Mint::Token2022 {
+            decimals: mint.decimals,
+            token_program: spl_token_2022::id(),
+        })
+    } else {
+        Err(X402Error::SigningError(format!(
+            "failed to unpack mint {mint_pubkey}: unknown owner"
+        )))
+    }
+}
+
+/// Build the message we want to simulate (priority fee + transfer Ixs).
+pub fn build_message_to_simulate(
+    fee_payer: Pubkey,
+    transfer_instructions: &[Instruction],
+    priority_micro_lamports: u64,
+    recent_blockhash: Hash,
+) -> Result<(MessageV0, Vec<Instruction>), X402Error> {
+    let set_price = ComputeBudgetInstruction::set_compute_unit_price(priority_micro_lamports);
+
+    let mut ixs = Vec::with_capacity(1 + transfer_instructions.len());
+    ixs.push(set_price);
+    ixs.extend(transfer_instructions.to_owned());
+
+    let with_cu_limit = {
+        let mut ixs_mod = ixs.clone();
+        update_or_append_set_compute_unit_limit(&mut ixs_mod, 1e5 as u32);
+        ixs_mod
+    };
+    let message = MessageV0::try_compile(&fee_payer, &with_cu_limit, &[], recent_blockhash)
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+    Ok((message, ixs))
+}
+
+/// Estimate compute units by simulating the unsigned/signed tx.
+pub async fn estimate_compute_units<S: RpcClientLike>(
+    rpc_client: &S,
+    message: &MessageV0,
+) -> Result<u32, X402Error> {
+    let message = VersionedMessage::V0(message.clone());
+    let num_required_signatures = message.header().num_required_signatures;
+    let tx = VersionedTransaction {
+        signatures: vec![Signature::default(); num_required_signatures as usize],
+        message,
+    };
+
+    let sim = rpc_client
+        .simulate_transaction_with_config(
+            &tx,
+            RpcSimulateTransactionConfig {
+                sig_verify: false,
+                replace_recent_blockhash: true,
+                ..RpcSimulateTransactionConfig::default()
+            },
+        )
+        .await
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+    let units = sim.value.units_consumed.ok_or(X402Error::SigningError(
+        "simulation returned no units_consumed".to_string(),
+    ))?;
+    Ok(units as u32)
+}
+
+/// Get the priority fee in micro-lamports.
+pub async fn get_priority_fee_micro_lamports<S: RpcClientLike>(
+    rpc_client: &S,
+    writeable_accounts: &[Pubkey],
+) -> Result<u64, X402Error> {
+    let recent_fees = rpc_client
+        .get_recent_prioritization_fees(writeable_accounts)
+        .await
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+    let fee = recent_fees
+        .iter()
+        .filter_map(|e| {
+            if e.prioritization_fee > 0 {
+                Some(e.prioritization_fee)
+            } else {
+                None
+            }
+        })
+        .min_by(|a, b| a.cmp(b))
+        .unwrap_or(1);
+    Ok(fee)
+}
+
+/// Update the first set_compute_unit_limit ix if it exists, else append a new one.
+pub fn update_or_append_set_compute_unit_limit(ixs: &mut Vec<Instruction>, units: u32) {
+    let target_program = solana_compute_budget_interface::ID;
+    let new_ix = ComputeBudgetInstruction::set_compute_unit_limit(units);
+
+    let ix = ixs
+        .iter_mut()
+        .find(|ix| ix.program_id == target_program && ix.data.is_empty());
+    if let Some(ix) = ix {
+        *ix = new_ix;
+    } else {
+        ixs.push(new_ix);
+    }
+}
+
+/// Build and sign a Solana token transfer transaction.
+/// Returns the base64-encoded signed transaction.
+pub async fn build_signed_transfer_transaction<S: Signer, R: RpcClientLike>(
+    signer: &S,
+    rpc_client: &R,
+    fee_payer: &Pubkey,
+    pay_to: &Address,
+    asset: &Address,
+    amount: u64,
+) -> Result<String, X402Error> {
+    let mint = fetch_mint(asset, rpc_client).await?;
+
+    let (ata, _) = Pubkey::find_program_address(
+        &[
+            pay_to.as_ref(),
+            mint.token_program().as_ref(),
+            asset.as_ref(),
+        ],
+        &ATA_PROGRAM_PUBKEY,
+    );
+
+    let client_pubkey = signer.pubkey();
+    let (source_ata, _) = Pubkey::find_program_address(
+        &[
+            client_pubkey.as_ref(),
+            mint.token_program().as_ref(),
+            asset.as_ref(),
+        ],
+        &ATA_PROGRAM_PUBKEY,
+    );
+    let destination_ata = ata;
+
+    let transfer_instruction = match mint {
+        Mint::Token {
+            decimals,
+            token_program,
+        } => spl_token::instruction::transfer_checked(
+            &token_program,
+            &source_ata,
+            asset.pubkey(),
+            &destination_ata,
+            &client_pubkey,
+            &[],
+            amount,
+            decimals,
+        )
+        .map_err(|e| X402Error::SigningError(format!("{e}")))?,
+        Mint::Token2022 {
+            decimals,
+            token_program,
+        } => spl_token_2022::instruction::transfer_checked(
+            &token_program,
+            &source_ata,
+            asset.pubkey(),
+            &destination_ata,
+            &client_pubkey,
+            &[],
+            amount,
+            decimals,
+        )
+        .map_err(|e| X402Error::SigningError(format!("{e}")))?,
+    };
+
+    let recent_blockhash = rpc_client
+        .get_latest_blockhash()
+        .await
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+
+    let fee =
+        get_priority_fee_micro_lamports(rpc_client, &[*fee_payer, destination_ata, source_ata])
+            .await?;
+
+    let (msg_to_sim, instructions) =
+        build_message_to_simulate(*fee_payer, &[transfer_instruction], fee, recent_blockhash)?;
+
+    let estimated_cu = estimate_compute_units(rpc_client, &msg_to_sim).await?;
+
+    let cu_ix = ComputeBudgetInstruction::set_compute_unit_limit(estimated_cu);
+    let msg = {
+        let mut final_instructions = Vec::with_capacity(instructions.len() + 1);
+        final_instructions.push(cu_ix);
+        final_instructions.extend(instructions);
+        MessageV0::try_compile(fee_payer, &final_instructions, &[], recent_blockhash)
+            .map_err(|e| X402Error::SigningError(format!("{e:?}")))?
+    };
+
+    let tx = VersionedTransaction {
+        signatures: vec![],
+        message: VersionedMessage::V0(msg),
+    };
+
+    let tx = TransactionInt::new(tx);
+    let signed = tx
+        .sign_with_keypair(signer)
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+    let tx_b64 = signed
+        .as_base64()
+        .map_err(|e| X402Error::SigningError(format!("{e:?}")))?;
+
+    Ok(tx_b64)
+}
+
+// ============================================================================
+// V1 Client
+// ============================================================================
+
+/// Client for creating Solana payment payloads for the v1 exact scheme.
+#[derive(Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct V1SolanaExactClient<S, R> {
+    signer: S,
+    rpc_client: R,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl<S, R> V1SolanaExactClient<S, R> {
+    pub fn new(signer: S, rpc_client: R) -> Self {
+        Self { signer, rpc_client }
+    }
+}
+
+impl<S, R> X402SchemeId for V1SolanaExactClient<S, R> {
+    fn x402_version(&self) -> u8 {
+        V1SolanaExact.x402_version()
+    }
+
+    fn namespace(&self) -> &str {
+        V1SolanaExact.namespace()
+    }
+
+    fn scheme(&self) -> &str {
+        V1SolanaExact.scheme()
+    }
+}
+
+impl<S, R> X402SchemeClient for V1SolanaExactClient<S, R>
+where
+    S: Signer + Send + Sync + Clone + 'static,
+    R: RpcClientLike + Send + Sync + Clone + 'static,
+{
+    fn accept(&self, payment_required: &PaymentRequired) -> Vec<PaymentCandidate> {
+        let payment_required = match payment_required {
+            PaymentRequired::V1(payment_required) => payment_required,
+            PaymentRequired::V2(_) => {
+                return vec![];
+            }
+        };
+        payment_required
+            .accepts
+            .iter()
+            .filter_map(|v| {
+                let requirements: PaymentRequirements = v.as_concrete()?;
+                let chain_id = ChainId::from_network_name(&requirements.network)?;
+                if chain_id.namespace != "solana" {
+                    return None;
+                }
+                let candidate = PaymentCandidate {
+                    chain_id,
+                    asset: requirements.asset.to_string(),
+                    amount: U256::from(requirements.max_amount_required.inner()),
+                    scheme: self.scheme().to_string(),
+                    x402_version: self.x402_version(),
+                    pay_to: requirements.pay_to.to_string(),
+                    signer: Box::new(PayloadSigner {
+                        signer: self.signer.clone(),
+                        rpc_client: self.rpc_client.clone(),
+                        requirements,
+                    }),
+                };
+                Some(candidate)
+            })
+            .collect::<Vec<_>>()
+    }
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct PayloadSigner<S, R> {
+    signer: S,
+    rpc_client: R,
+    requirements: PaymentRequirements,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+#[async_trait]
+impl<S: Signer + Sync, R: RpcClientLike + Sync> PaymentCandidateSigner for PayloadSigner<S, R> {
+    async fn sign_payment(&self) -> Result<String, X402Error> {
+        let fee_payer = self
+            .requirements
+            .extra
+            .as_ref()
+            .map(|extra| extra.fee_payer.clone())
+            .ok_or(X402Error::SigningError(
+                "missing fee_payer in extra".to_string(),
+            ))?;
+        let fee_payer_pubkey: Pubkey = fee_payer.into();
+
+        let amount = self.requirements.max_amount_required.inner();
+        let tx_b64 = build_signed_transfer_transaction(
+            &self.signer,
+            &self.rpc_client,
+            &fee_payer_pubkey,
+            &self.requirements.pay_to,
+            &self.requirements.asset,
+            amount,
+        )
+        .await?;
+
+        let payload = PaymentPayload {
+            x402_version: X402Version1,
+            scheme: ExactScheme,
+            network: self.requirements.network.clone(),
+            payload: ExactSolanaPayload {
+                transaction: tx_b64,
+            },
+        };
+        let json = serde_json::to_vec(&payload)?;
+        let b64 = Base64Bytes::encode(&json);
+
+        Ok(b64.to_string())
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/facilitator.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/facilitator.rs
new file mode 100644
index 0000000..b2c1f3d
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/facilitator.rs
@@ -0,0 +1,575 @@
+use serde::{Deserialize, Serialize};
+use solana_client::rpc_config::RpcSimulateTransactionConfig;
+use solana_client::rpc_response::{TransactionError, UiTransactionError};
+use solana_commitment_config::CommitmentConfig;
+use solana_compute_budget_interface::ID as ComputeBudgetInstructionId;
+use solana_pubkey::Pubkey;
+use solana_signature::Signature;
+use solana_transaction::versioned::VersionedTransaction;
+use std::collections::HashMap;
+use x402_types::chain::{ChainId, ChainProviderOps};
+use x402_types::proto;
+use x402_types::proto::{PaymentVerificationError, v1};
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorBuilder, X402SchemeFacilitatorError,
+};
+use x402_types::util::Base64Bytes;
+
+#[cfg(feature = "telemetry")]
+use tracing_core::Level;
+
+use crate::V1SolanaExact;
+use crate::chain::Address;
+use crate::chain::provider::{SolanaChainProviderError, SolanaChainProviderLike};
+use crate::v1_solana_exact::types;
+use crate::v1_solana_exact::types::{
+    ATA_PROGRAM_PUBKEY, PHANTOM_LIGHTHOUSE_PROGRAM, SolanaExactError, TransactionInt,
+};
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V1SolanaExact
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync + 'static,
+{
+    fn build(
+        &self,
+        provider: P,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        let config = config
+            .map(serde_json::from_value::<V1SolanaExactFacilitatorConfig>)
+            .transpose()?
+            .unwrap_or_default();
+
+        Ok(Box::new(V1SolanaExactFacilitator::new(provider, config)))
+    }
+}
+
+pub struct V1SolanaExactFacilitator<P> {
+    provider: P,
+    config: V1SolanaExactFacilitatorConfig,
+}
+
+impl<P> V1SolanaExactFacilitator<P> {
+    pub fn new(provider: P, config: V1SolanaExactFacilitatorConfig) -> Self {
+        Self { provider, config }
+    }
+}
+
+#[async_trait::async_trait]
+impl<P> X402SchemeFacilitator for V1SolanaExactFacilitator<P>
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync,
+{
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError> {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request, &self.config).await?;
+        Ok(v1::VerifyResponse::valid(verification.payer.to_string()).into())
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError> {
+        let request = types::SettleRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request, &self.config).await?;
+        let payer = verification.payer.to_string();
+        let tx_sig = settle_transaction(&self.provider, verification).await?;
+        Ok(v1::SettleResponse::Success {
+            payer,
+            transaction: tx_sig.to_string(),
+            network: self.provider.chain_id().to_string(),
+        }
+        .into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+        let kinds: Vec<proto::SupportedPaymentKind> = {
+            let mut kinds = Vec::with_capacity(1);
+            let fee_payer = self.provider.fee_payer();
+            let extra =
+                Some(serde_json::to_value(types::SupportedPaymentKindExtra { fee_payer }).unwrap());
+            let network = chain_id.as_network_name();
+            if let Some(network) = network {
+                kinds.push(proto::SupportedPaymentKind {
+                    x402_version: proto::v1::X402Version1.into(),
+                    scheme: types::ExactScheme.to_string(),
+                    network: network.to_string(),
+                    extra,
+                });
+            }
+            kinds
+        };
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+pub struct VerifyTransferResult {
+    pub payer: Address,
+    pub transaction: VersionedTransaction,
+}
+
+#[derive(Debug)]
+pub struct TransferCheckedInstruction {
+    pub amount: u64,
+    pub source: Pubkey,
+    pub mint: Pubkey,
+    pub destination: Pubkey,
+    pub authority: Pubkey,
+    pub token_program: Pubkey,
+}
+
+pub fn verify_compute_limit_instruction(
+    transaction: &VersionedTransaction,
+    instruction_index: usize,
+) -> Result<u32, SolanaExactError> {
+    let instructions = transaction.message.instructions();
+    let instruction = instructions
+        .get(instruction_index)
+        .ok_or(SolanaExactError::NoInstructionAtIndex(instruction_index))?;
+    let account = instruction.program_id(transaction.message.static_account_keys());
+    let data = instruction.data.as_slice();
+
+    // Verify program ID, discriminator, and data length (1 byte discriminator + 4 bytes u32)
+    if ComputeBudgetInstructionId.ne(account)
+        || data.first().cloned().unwrap_or(0) != 2
+        || data.len() != 5
+    {
+        return Err(SolanaExactError::InvalidComputeLimitInstruction);
+    }
+
+    // Parse compute unit limit (u32 in little-endian)
+    let mut buf = [0u8; 4];
+    buf.copy_from_slice(&data[1..5]);
+    let compute_units = u32::from_le_bytes(buf);
+
+    Ok(compute_units)
+}
+
+pub fn verify_compute_price_instruction(
+    max_compute_unit_price: u64,
+    transaction: &VersionedTransaction,
+    instruction_index: usize,
+) -> Result<(), SolanaExactError> {
+    let instructions = transaction.message.instructions();
+    let instruction = instructions
+        .get(instruction_index)
+        .ok_or(SolanaExactError::NoInstructionAtIndex(instruction_index))?;
+    let account = instruction.program_id(transaction.message.static_account_keys());
+    let compute_budget = solana_compute_budget_interface::ID;
+    let data = instruction.data.as_slice();
+    if compute_budget.ne(account) || data.first().cloned().unwrap_or(0) != 3 || data.len() != 9 {
+        return Err(SolanaExactError::InvalidComputePriceInstruction);
+    }
+    // It is ComputeBudgetInstruction definitely by now!
+    let mut buf = [0u8; 8];
+    buf.copy_from_slice(&data[1..]);
+    let microlamports = u64::from_le_bytes(buf);
+    if microlamports > max_compute_unit_price {
+        return Err(SolanaExactError::MaxComputeUnitPriceExceeded);
+    }
+    Ok(())
+}
+
+/// Validates the instruction structure of the transaction.
+///
+/// Required structure:
+/// - Index 0: SetComputeUnitLimit instruction
+/// - Index 1: SetComputeUnitPrice instruction
+/// - Index 2: TransferChecked instruction (Token or Token-2022)
+/// - Index 3+: Additional instructions (only if allow_additional_instructions is true)
+///
+/// NOTE: CreateATA is NOT supported. The destination ATA must exist before payment.
+pub fn validate_instructions(
+    transaction: &VersionedTransaction,
+    config: &V1SolanaExactFacilitatorConfig,
+) -> Result<(), SolanaExactError> {
+    let instructions = transaction.message.instructions();
+
+    // Minimum: ComputeLimit + ComputePrice + TransferChecked
+    if instructions.len() < 3 {
+        return Err(SolanaExactError::TooFewInstructions);
+    }
+
+    // Check maximum instruction count
+    if instructions.len() > config.max_instruction_count {
+        return Err(SolanaExactError::InstructionCountExceedsMax(
+            config.max_instruction_count,
+        ));
+    }
+
+    // Verify instruction at index 2 is a token transfer (NOT CreateATA)
+    let ix2_program = get_program_id(transaction, 2);
+    if ix2_program == Some(ATA_PROGRAM_PUBKEY) {
+        return Err(SolanaExactError::CreateATANotSupported);
+    }
+
+    // Validate additional instructions (if any beyond the required 3)
+    if instructions.len() > 3 {
+        if !config.allow_additional_instructions {
+            return Err(SolanaExactError::AdditionalInstructionsNotAllowed);
+        }
+
+        // Validate each additional instruction (starting at index 3)
+        for i in 3..instructions.len() {
+            if let Some(program_id) = get_program_id(transaction, i) {
+                // Check blocked list first (takes precedence)
+                if config.is_blocked(&program_id) {
+                    return Err(SolanaExactError::BlockedProgram(program_id));
+                }
+
+                // Check allowed list - must be explicitly whitelisted
+                if !config.is_allowed(&program_id) {
+                    return Err(SolanaExactError::ProgramNotAllowed(program_id));
+                }
+            }
+        }
+    }
+
+    Ok(())
+}
+
+fn get_program_id(transaction: &VersionedTransaction, index: usize) -> Option<Pubkey> {
+    let instruction = transaction.message.instructions().get(index)?;
+    let account_keys = transaction.message.static_account_keys();
+    Some(*instruction.program_id(account_keys))
+}
+
+pub async fn verify_transfer<P: SolanaChainProviderLike + ChainProviderOps>(
+    provider: &P,
+    request: &types::VerifyRequest,
+    config: &V1SolanaExactFacilitatorConfig,
+) -> Result<VerifyTransferResult, PaymentVerificationError> {
+    let payload = &request.payment_payload;
+    let requirements = &request.payment_requirements;
+
+    // Assert valid payment START
+    let chain_id = provider.chain_id();
+    let payload_chain_id = ChainId::from_network_name(&payload.network)
+        .ok_or(PaymentVerificationError::UnsupportedChain)?;
+    if payload_chain_id != chain_id {
+        return Err(PaymentVerificationError::ChainIdMismatch);
+    }
+    let requirements_chain_id = ChainId::from_network_name(&requirements.network)
+        .ok_or(PaymentVerificationError::UnsupportedChain)?;
+    if requirements_chain_id != chain_id {
+        return Err(PaymentVerificationError::ChainIdMismatch);
+    }
+    let transaction_b64_string = payload.payload.transaction.clone();
+    let transfer_requirement = TransferRequirement {
+        pay_to: &requirements.pay_to,
+        asset: &requirements.asset,
+        amount: requirements.max_amount_required.inner(),
+    };
+    let result = verify_transaction(
+        provider,
+        transaction_b64_string,
+        &transfer_requirement,
+        config,
+    )
+    .await?;
+    Ok(result)
+}
+
+pub async fn verify_transaction<P: SolanaChainProviderLike>(
+    provider: &P,
+    transaction_b64_string: String,
+    transfer_requirement: &TransferRequirement<'_>,
+    config: &V1SolanaExactFacilitatorConfig,
+) -> Result<VerifyTransferResult, PaymentVerificationError> {
+    let bytes = Base64Bytes::from(transaction_b64_string.as_bytes())
+        .decode()
+        .map_err(|e| SolanaExactError::TransactionDecoding(e.to_string()))?;
+    let transaction = bincode::deserialize::<VersionedTransaction>(bytes.as_slice())
+        .map_err(|e| SolanaExactError::TransactionDecoding(e.to_string()))?;
+
+    // Verify compute instructions
+    let compute_units = verify_compute_limit_instruction(&transaction, 0)?;
+    if compute_units > provider.max_compute_unit_limit() {
+        return Err(SolanaExactError::MaxComputeUnitLimitExceeded.into());
+    }
+    #[cfg(feature = "telemetry")]
+    tracing::debug!(compute_units = compute_units, "Verified compute unit limit");
+    verify_compute_price_instruction(provider.max_compute_unit_price(), &transaction, 1)?;
+
+    // Flexible instruction validation (replaces old instruction count check)
+    validate_instructions(&transaction, config)?;
+
+    // Transfer instruction is ALWAYS at index 2 (CreateATA no longer supported)
+    let transfer_instruction =
+        verify_transfer_instruction(provider, &transaction, 2, transfer_requirement).await?;
+
+    // Fee payer safety check (configurable but defaults to enabled)
+    if config.require_fee_payer_not_in_instructions {
+        let fee_payer_pubkey = provider.pubkey();
+        for instruction in transaction.message.instructions().iter() {
+            for account_idx in instruction.accounts.iter() {
+                let account = transaction
+                    .message
+                    .static_account_keys()
+                    .get(*account_idx as usize)
+                    .ok_or(SolanaExactError::NoAccountAtIndex(*account_idx))?;
+
+                if *account == fee_payer_pubkey {
+                    return Err(SolanaExactError::FeePayerIncludedInInstructionAccounts.into());
+                }
+            }
+        }
+    }
+
+    // Sign and simulate transaction
+    let tx = TransactionInt::new(transaction.clone()).sign(provider)?;
+    let cfg = RpcSimulateTransactionConfig {
+        sig_verify: false,
+        replace_recent_blockhash: false,
+        commitment: Some(CommitmentConfig::confirmed()),
+        encoding: None,
+        accounts: None,
+        inner_instructions: false,
+        min_context_slot: None,
+    };
+    provider
+        .simulate_transaction_with_config(tx.inner(), cfg)
+        .await?;
+    let payer: Address = transfer_instruction.authority.into();
+    Ok(VerifyTransferResult { payer, transaction })
+}
+
+pub struct TransferRequirement<'a> {
+    pub asset: &'a Address,
+    pub pay_to: &'a Address,
+    pub amount: u64,
+}
+
+pub async fn verify_transfer_instruction<P: SolanaChainProviderLike>(
+    provider: &P,
+    transaction: &VersionedTransaction,
+    instruction_index: usize,
+    transfer_requirement: &TransferRequirement<'_>,
+) -> Result<TransferCheckedInstruction, PaymentVerificationError> {
+    let tx = TransactionInt::new(transaction.clone());
+    let instruction = tx.instruction(instruction_index)?;
+    instruction.assert_not_empty()?;
+    let program_id = instruction.program_id();
+    let transfer_checked_instruction = if spl_token::ID.eq(&program_id) {
+        let token_instruction =
+            spl_token::instruction::TokenInstruction::unpack(instruction.data_slice())
+                .map_err(|_| SolanaExactError::InvalidTokenInstruction)?;
+        let amount = match token_instruction {
+            spl_token::instruction::TokenInstruction::TransferChecked {
+                amount,
+                decimals: _,
+            } => amount,
+            _ => return Err(SolanaExactError::InvalidTokenInstruction.into()),
+        };
+        // Source = 0
+        let source = instruction.account(0)?;
+        // Mint = 1
+        let mint = instruction.account(1)?;
+        // Destination = 2
+        let destination = instruction.account(2)?;
+        // Authority = 3
+        let authority = instruction.account(3)?;
+        TransferCheckedInstruction {
+            amount,
+            source,
+            mint,
+            destination,
+            authority,
+            token_program: spl_token::ID,
+        }
+    } else if spl_token_2022::ID.eq(&program_id) {
+        let token_instruction =
+            spl_token_2022::instruction::TokenInstruction::unpack(instruction.data_slice())
+                .map_err(|_| SolanaExactError::InvalidTokenInstruction)?;
+        let amount = match token_instruction {
+            spl_token_2022::instruction::TokenInstruction::TransferChecked {
+                amount,
+                decimals: _,
+            } => amount,
+            _ => return Err(SolanaExactError::InvalidTokenInstruction.into()),
+        };
+        // Source = 0
+        let source = instruction.account(0)?;
+        // Mint = 1
+        let mint = instruction.account(1)?;
+        // Destination = 2
+        let destination = instruction.account(2)?;
+        // Authority = 3
+        let authority = instruction.account(3)?;
+        TransferCheckedInstruction {
+            amount,
+            source,
+            mint,
+            destination,
+            authority,
+            token_program: spl_token_2022::ID,
+        }
+    } else {
+        return Err(SolanaExactError::InvalidTokenInstruction.into());
+    };
+
+    // Verify that the fee payer is not transferring funds (not the authority)
+    let fee_payer_pubkey = provider.pubkey();
+    if transfer_checked_instruction.authority == fee_payer_pubkey {
+        return Err(SolanaExactError::FeePayerTransferringFunds.into());
+    }
+
+    // Verify that the mint matches the expected asset
+    if Address::new(transfer_checked_instruction.mint) != *transfer_requirement.asset {
+        return Err(PaymentVerificationError::AssetMismatch);
+    }
+
+    let token_program = transfer_checked_instruction.token_program;
+    // findAssociatedTokenPda
+    let (ata, _) = Pubkey::find_program_address(
+        &[
+            transfer_requirement.pay_to.as_ref(),
+            token_program.as_ref(),
+            transfer_requirement.asset.as_ref(),
+        ],
+        &ATA_PROGRAM_PUBKEY,
+    );
+    if transfer_checked_instruction.destination != ata {
+        return Err(PaymentVerificationError::RecipientMismatch);
+    }
+    let accounts = provider
+        .get_multiple_accounts(&[transfer_checked_instruction.source, ata])
+        .await?;
+    let is_sender_missing = accounts.first().cloned().is_none_or(|a| a.is_none());
+    if is_sender_missing {
+        return Err(SolanaExactError::MissingSenderAccount.into());
+    }
+    // Destination ATA must exist (CreateATA no longer supported)
+    let is_receiver_missing = accounts.get(1).cloned().is_none_or(|a| a.is_none());
+    if is_receiver_missing {
+        return Err(PaymentVerificationError::RecipientMismatch);
+    }
+    let instruction_amount = transfer_checked_instruction.amount;
+    if instruction_amount != transfer_requirement.amount {
+        return Err(PaymentVerificationError::InvalidPaymentAmount);
+    }
+    Ok(transfer_checked_instruction)
+}
+
+pub async fn settle_transaction<P: SolanaChainProviderLike>(
+    provider: &P,
+    verification: VerifyTransferResult,
+) -> Result<Signature, SolanaChainProviderError> {
+    let tx = TransactionInt::new(verification.transaction).sign(provider)?;
+    // Verify if fully signed
+    if !tx.is_fully_signed() {
+        #[cfg(feature = "telemetry")]
+        tracing::event!(Level::WARN, status = "failed", "undersigned transaction");
+        return Err(SolanaChainProviderError::InvalidTransaction(
+            UiTransactionError::from(TransactionError::SignatureFailure),
+        ));
+    }
+    let tx_sig = tx
+        .send_and_confirm(provider, CommitmentConfig::confirmed())
+        .await?;
+    Ok(tx_sig)
+}
+
+/// Configuration for V1 Solana Exact Facilitator
+///
+/// Controls transaction verification behavior, including support for
+/// additional instructions from third-party wallets like Phantom.
+///
+/// By default, the Phantom Lighthouse program is allowed to support
+/// Phantom wallet users on mainnet.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct V1SolanaExactFacilitatorConfig {
+    /// Allow additional instructions beyond the required ones
+    /// Default: true (to support Phantom Lighthouse)
+    #[serde(default = "default_allow_additional_instructions")]
+    pub allow_additional_instructions: bool,
+
+    /// Maximum number of instructions allowed in a transaction
+    /// Default: 10
+    #[serde(default = "default_max_instruction_count")]
+    pub max_instruction_count: usize,
+
+    /// Explicitly allowed program IDs for additional instructions.
+    /// Only checked if allow_additional_instructions is true.
+    /// Uses Solana Address type which deserializes from base58 strings.
+    ///
+    /// Default: [Phantom Lighthouse program]
+    ///
+    /// SECURITY: If this list is empty and allow_additional_instructions is true,
+    /// ALL additional instructions will be rejected. You must explicitly whitelist
+    /// the programs you want to allow.
+    #[serde(default = "default_allowed_program_ids")]
+    pub allowed_program_ids: Vec<Address>,
+
+    /// Blocked program IDs (always rejected, takes precedence over allowed).
+    /// Uses Solana Address type which deserializes from base58 strings.
+    #[serde(default)]
+    pub blocked_program_ids: Vec<Address>,
+
+    /// SECURITY: Require fee payer is NOT present in any instruction's accounts
+    /// Default: true - strongly recommended to keep this enabled
+    #[serde(default = "default_require_fee_payer_not_in_instructions")]
+    pub require_fee_payer_not_in_instructions: bool,
+}
+
+fn default_allow_additional_instructions() -> bool {
+    true
+}
+
+fn default_max_instruction_count() -> usize {
+    10
+}
+
+fn default_allowed_program_ids() -> Vec<Address> {
+    vec![Address::new(*PHANTOM_LIGHTHOUSE_PROGRAM)]
+}
+
+fn default_require_fee_payer_not_in_instructions() -> bool {
+    true
+}
+
+impl Default for V1SolanaExactFacilitatorConfig {
+    fn default() -> Self {
+        Self {
+            allow_additional_instructions: default_allow_additional_instructions(),
+            max_instruction_count: default_max_instruction_count(),
+            allowed_program_ids: default_allowed_program_ids(),
+            blocked_program_ids: Vec::new(),
+            require_fee_payer_not_in_instructions: default_require_fee_payer_not_in_instructions(),
+        }
+    }
+}
+
+impl V1SolanaExactFacilitatorConfig {
+    /// Check if a program ID is in the blocked list
+    pub fn is_blocked(&self, program_id: &Pubkey) -> bool {
+        self.blocked_program_ids
+            .iter()
+            .any(|addr| addr.pubkey() == program_id)
+    }
+
+    /// Check if a program ID is in the allowed list.
+    ///
+    /// SECURITY: If the allowed list is empty, NO programs are allowed.
+    /// This follows the principle of least privilege - you must explicitly
+    /// whitelist programs you want to accept.
+    pub fn is_allowed(&self, program_id: &Pubkey) -> bool {
+        self.allowed_program_ids
+            .iter()
+            .any(|addr| addr.pubkey() == program_id)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/mod.rs
new file mode 100644
index 0000000..40a9537
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/mod.rs
@@ -0,0 +1,71 @@
+//! V1 Solana "exact" payment scheme implementation.
+//!
+//! This module implements the "exact" payment scheme for Solana using
+//! the V1 x402 protocol. It uses SPL Token `TransferChecked` instructions
+//! for token transfers.
+//!
+//! # Features
+//!
+//! - SPL Token and Token-2022 program support
+//! - Compute budget instruction validation
+//! - Transaction simulation before settlement
+//! - Fee payer safety checks
+//! - Configurable instruction allowlists/blocklists
+//!
+//! # Transaction Structure
+//!
+//! The expected transaction structure is:
+//! - Index 0: `SetComputeUnitLimit` instruction
+//! - Index 1: `SetComputeUnitPrice` instruction
+//! - Index 2: `TransferChecked` instruction (SPL Token or Token-2022)
+//! - Index 3+: Additional instructions (if allowed by configuration)
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_solana::v1_solana_exact::V1SolanaExact;
+//! use x402_chain_solana::networks::{KnownNetworkSolana, USDC};
+//!
+//! // Create a price tag for 1 USDC on Solana mainnet
+//! let usdc = USDC::solana_mainnet();
+//! let price = V1SolanaExact::price_tag(
+//!     recipient_pubkey,  // pay_to address
+//!     usdc.amount(1_000_000),  // 1 USDC
+//! );
+//! ```
+
+#[cfg(feature = "server")]
+pub mod server;
+#[cfg(feature = "server")]
+pub use server::*;
+
+#[cfg(feature = "facilitator")]
+pub mod facilitator;
+#[cfg(feature = "facilitator")]
+pub use facilitator::*;
+
+#[cfg(feature = "client")]
+pub mod client;
+#[cfg(feature = "client")]
+pub use client::*;
+
+pub mod types;
+pub use types::*;
+
+use x402_types::scheme::X402SchemeId;
+
+pub struct V1SolanaExact;
+
+impl X402SchemeId for V1SolanaExact {
+    fn x402_version(&self) -> u8 {
+        1
+    }
+
+    fn namespace(&self) -> &str {
+        "solana"
+    }
+
+    fn scheme(&self) -> &str {
+        ExactScheme.as_ref()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/server.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/server.rs
new file mode 100644
index 0000000..f312a3b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/server.rs
@@ -0,0 +1,59 @@
+use std::sync::Arc;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::proto;
+use x402_types::proto::v1;
+
+use crate::V1SolanaExact;
+use crate::chain::{Address, SolanaTokenDeployment};
+use crate::v1_solana_exact::types::{ExactScheme, SupportedPaymentKindExtra};
+
+impl V1SolanaExact {
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn price_tag<A: Into<Address>>(
+        pay_to: A,
+        asset: DeployedTokenAmount<u64, SolanaTokenDeployment>,
+    ) -> v1::PriceTag {
+        let chain_id: ChainId = asset.token.chain_reference.into();
+        let network = chain_id
+            .as_network_name()
+            .unwrap_or_else(|| panic!("Can not get network name for chain id {}", chain_id));
+        v1::PriceTag {
+            scheme: ExactScheme.to_string(),
+            pay_to: pay_to.into().to_string(),
+            asset: asset.token.address.to_string(),
+            network: network.to_string(),
+            amount: asset.amount.to_string(),
+            max_timeout_seconds: 300,
+            extra: None,
+            enricher: Some(Arc::new(solana_fee_payer_enricher)),
+        }
+    }
+}
+
+/// Enricher function for Solana price tags - adds fee_payer to extra field
+#[allow(dead_code)]
+pub fn solana_fee_payer_enricher(
+    price_tag: &mut v1::PriceTag,
+    capabilities: &proto::SupportedResponse,
+) {
+    if price_tag.extra.is_some() {
+        return;
+    }
+
+    // Find the matching kind and deserialize the whole extra into SupportedPaymentKindExtra
+    let extra = capabilities
+        .kinds
+        .iter()
+        .find(|kind| {
+            v1::X402Version1 == kind.x402_version
+                && kind.scheme == ExactScheme.to_string()
+                && kind.network == price_tag.network
+        })
+        .and_then(|kind| kind.extra.as_ref())
+        .and_then(|extra| serde_json::from_value::<SupportedPaymentKindExtra>(extra.clone()).ok());
+
+    // Serialize the whole extra back to Value
+    if let Some(extra) = extra {
+        price_tag.extra = serde_json::to_value(&extra).ok();
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/types.rs
new file mode 100644
index 0000000..2a9faeb
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v1_solana_exact/types.rs
@@ -0,0 +1,289 @@
+//! Type definitions for the V1 Solana "exact" payment scheme.
+//!
+//! This module defines the wire format types for SPL Token based payments
+//! on Solana using the V1 x402 protocol.
+
+use serde::{Deserialize, Serialize};
+use solana_pubkey::{Pubkey, pubkey};
+use std::sync::LazyLock;
+use x402_types::proto::PaymentVerificationError;
+use x402_types::proto::util::U64String;
+use x402_types::{lit_str, proto};
+
+use crate::chain::Address;
+#[cfg(feature = "facilitator")]
+use crate::chain::{SolanaChainProviderError, SolanaChainProviderLike};
+
+#[cfg(feature = "facilitator")]
+use solana_commitment_config::CommitmentConfig;
+#[cfg(any(feature = "client", feature = "facilitator"))]
+use solana_message::compiled_instruction::CompiledInstruction;
+#[cfg(any(feature = "client", feature = "facilitator"))]
+use solana_signature::Signature;
+#[cfg(any(feature = "client", feature = "facilitator"))]
+use solana_signer::Signer;
+#[cfg(any(feature = "client", feature = "facilitator"))]
+use solana_transaction::versioned::VersionedTransaction;
+#[cfg(any(feature = "client", feature = "facilitator"))]
+use x402_types::util::Base64Bytes;
+
+lit_str!(ExactScheme, "exact");
+
+/// Phantom Lighthouse program ID - security program injected by Phantom wallet on mainnet
+/// See: https://github.com/coinbase/x402/issues/828
+pub static PHANTOM_LIGHTHOUSE_PROGRAM: LazyLock<Pubkey> = LazyLock::new(|| {
+    "L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95"
+        .parse()
+        .expect("Invalid Lighthouse program ID")
+});
+
+pub type VerifyRequest = proto::v1::VerifyRequest<PaymentPayload, PaymentRequirements>;
+pub type SettleRequest = VerifyRequest;
+pub type PaymentPayload = proto::v1::PaymentPayload<ExactScheme, ExactSolanaPayload>;
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ExactSolanaPayload {
+    pub transaction: String,
+}
+
+pub type PaymentRequirements =
+    proto::v1::PaymentRequirements<ExactScheme, U64String, Address, SupportedPaymentKindExtra>;
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+#[serde(rename_all = "camelCase")]
+pub struct SupportedPaymentKindExtra {
+    pub fee_payer: Address,
+}
+
+pub const ATA_PROGRAM_PUBKEY: Pubkey = pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
+
+#[cfg(any(feature = "client", feature = "facilitator"))]
+pub struct InstructionInt {
+    index: usize,
+    instruction: CompiledInstruction,
+    account_keys: Vec<Pubkey>,
+}
+
+#[cfg(any(feature = "client", feature = "facilitator"))]
+pub struct TransactionInt {
+    inner: VersionedTransaction,
+}
+
+#[cfg(any(feature = "client", feature = "facilitator"))]
+impl TransactionInt {
+    pub fn new(transaction: VersionedTransaction) -> Self {
+        Self { inner: transaction }
+    }
+    pub fn inner(&self) -> &VersionedTransaction {
+        &self.inner
+    }
+    pub fn instruction(&self, index: usize) -> Result<InstructionInt, SolanaExactError> {
+        let instruction = self
+            .inner
+            .message
+            .instructions()
+            .get(index)
+            .cloned()
+            .ok_or(SolanaExactError::NoInstructionAtIndex(index))?;
+        let account_keys = self.inner.message.static_account_keys().to_vec();
+
+        Ok(InstructionInt {
+            index,
+            instruction,
+            account_keys,
+        })
+    }
+
+    pub fn is_fully_signed(&self) -> bool {
+        let num_required = self.inner.message.header().num_required_signatures;
+        if self.inner.signatures.len() < num_required as usize {
+            return false;
+        }
+        let default = Signature::default();
+        for signature in self.inner.signatures.iter() {
+            if default.eq(signature) {
+                return false;
+            }
+        }
+        true
+    }
+
+    #[cfg(feature = "facilitator")]
+    pub fn sign<P: SolanaChainProviderLike>(
+        self,
+        provider: &P,
+    ) -> Result<Self, SolanaChainProviderError> {
+        let tx = provider.sign(self.inner)?;
+        Ok(Self { inner: tx })
+    }
+
+    /// Sign the transaction with any Signer.
+    /// This is used by the client to sign transactions before sending to the facilitator.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn sign_with_keypair<S: Signer>(self, signer: &S) -> Result<Self, TransactionSignError> {
+        let mut tx = self.inner;
+        let msg_bytes = tx.message.serialize();
+        let signature = signer
+            .try_sign_message(msg_bytes.as_slice())
+            .map_err(|e| TransactionSignError(format!("{e}")))?;
+
+        // Required signatures are the first N account keys
+        let num_required = tx.message.header().num_required_signatures as usize;
+        let static_keys = tx.message.static_account_keys();
+
+        // Find signer's position
+        let pos = static_keys[..num_required]
+            .iter()
+            .position(|k| *k == signer.pubkey())
+            .ok_or(TransactionSignError(
+                "Signer not found in required signers".to_string(),
+            ))?;
+
+        // Ensure signature vector is large enough, then place the signature
+        if tx.signatures.len() < num_required {
+            tx.signatures.resize(num_required, Signature::default());
+        }
+        tx.signatures[pos] = signature;
+        Ok(Self { inner: tx })
+    }
+
+    #[cfg(feature = "facilitator")]
+    pub async fn send_and_confirm<P: SolanaChainProviderLike>(
+        &self,
+        provider: &P,
+        commitment_config: CommitmentConfig,
+    ) -> Result<Signature, SolanaChainProviderError> {
+        provider
+            .send_and_confirm(&self.inner, commitment_config)
+            .await
+    }
+
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn as_base64(&self) -> Result<String, TransactionToB64Error> {
+        let bytes =
+            bincode::serialize(&self.inner).map_err(|e| TransactionToB64Error(format!("{e}")))?;
+        let base64_bytes = Base64Bytes::encode(bytes);
+        let string = String::from_utf8(base64_bytes.0.into_owned())
+            .map_err(|e| TransactionToB64Error(format!("{e}")))?;
+        Ok(string)
+    }
+}
+
+#[cfg(any(feature = "client", feature = "facilitator"))]
+impl InstructionInt {
+    pub fn has_data(&self) -> bool {
+        !self.instruction.data.is_empty()
+    }
+
+    pub fn has_accounts(&self) -> bool {
+        !self.instruction.accounts.is_empty()
+    }
+
+    pub fn data_slice(&self) -> &[u8] {
+        self.instruction.data.as_slice()
+    }
+
+    pub fn assert_not_empty(&self) -> Result<(), SolanaExactError> {
+        if !self.has_data() || !self.has_accounts() {
+            return Err(SolanaExactError::EmptyInstructionAtIndex(self.index));
+        }
+        Ok(())
+    }
+
+    pub fn program_id(&self) -> Pubkey {
+        *self.instruction.program_id(self.account_keys.as_slice())
+    }
+
+    pub fn account(&self, index: u8) -> Result<Pubkey, SolanaExactError> {
+        let account_index = self
+            .instruction
+            .accounts
+            .get(index as usize)
+            .cloned()
+            .ok_or(SolanaExactError::NoAccountAtIndex(index))?;
+        let pubkey = self
+            .account_keys
+            .get(account_index as usize)
+            .cloned()
+            .ok_or(SolanaExactError::NoAccountAtIndex(index))?;
+        Ok(pubkey)
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+#[error("Can not encode transaction to base64: {0}")]
+pub struct TransactionToB64Error(String);
+
+#[derive(Debug, thiserror::Error)]
+pub enum SolanaExactError {
+    #[error("Can not decode transaction: {0}")]
+    TransactionDecoding(String),
+    #[error("Compute unit limit exceeds facilitator maximum")]
+    MaxComputeUnitLimitExceeded,
+    #[error("Compute unit price exceeds facilitator maximum")]
+    MaxComputeUnitPriceExceeded,
+    #[error("Too few instructions in transaction")]
+    TooFewInstructions,
+    #[error("Additional instructions not allowed")]
+    AdditionalInstructionsNotAllowed,
+    #[error("Instruction count exceeds maximum: {0}")]
+    InstructionCountExceedsMax(usize),
+    #[error("Blocked program in transaction: {0}")]
+    BlockedProgram(Pubkey),
+    #[error("Program not in allowed list: {0}")]
+    ProgramNotAllowed(Pubkey),
+    #[error("CreateATA instruction not supported - destination ATA must exist")]
+    CreateATANotSupported,
+    #[error("Fee payer included in instruction accounts")]
+    FeePayerIncludedInInstructionAccounts,
+    #[error("Fee payer found transferring funds")]
+    FeePayerTransferringFunds,
+    #[error("Instruction at index {0} not found")]
+    NoInstructionAtIndex(usize),
+    #[error("No account at index {0}")]
+    NoAccountAtIndex(u8),
+    #[error("Empty instruction at index {0}")]
+    EmptyInstructionAtIndex(usize),
+    #[error("Invalid compute limit instruction")]
+    InvalidComputeLimitInstruction,
+    #[error("Invalid compute price instruction")]
+    InvalidComputePriceInstruction,
+    #[error("Invalid token instruction")]
+    InvalidTokenInstruction,
+    #[error("Missing sender account in transaction")]
+    MissingSenderAccount,
+}
+
+impl From<SolanaExactError> for PaymentVerificationError {
+    fn from(e: SolanaExactError) -> Self {
+        match e {
+            SolanaExactError::TransactionDecoding(_) => {
+                PaymentVerificationError::InvalidFormat(e.to_string())
+            }
+            SolanaExactError::MaxComputeUnitLimitExceeded
+            | SolanaExactError::MaxComputeUnitPriceExceeded
+            | SolanaExactError::TooFewInstructions
+            | SolanaExactError::AdditionalInstructionsNotAllowed
+            | SolanaExactError::InstructionCountExceedsMax(_)
+            | SolanaExactError::BlockedProgram(_)
+            | SolanaExactError::ProgramNotAllowed(_)
+            | SolanaExactError::CreateATANotSupported
+            | SolanaExactError::FeePayerIncludedInInstructionAccounts
+            | SolanaExactError::NoInstructionAtIndex(_)
+            | SolanaExactError::InvalidComputeLimitInstruction
+            | SolanaExactError::NoAccountAtIndex(_)
+            | SolanaExactError::InvalidTokenInstruction
+            | SolanaExactError::EmptyInstructionAtIndex(_)
+            | SolanaExactError::FeePayerTransferringFunds
+            | SolanaExactError::MissingSenderAccount
+            | SolanaExactError::InvalidComputePriceInstruction => {
+                PaymentVerificationError::TransactionSimulation(e.to_string())
+            }
+        }
+    }
+}
+
+#[derive(Debug, thiserror::Error)]
+#[error("Can not sign transaction: {0}")]
+pub struct TransactionSignError(pub String);
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/client.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/client.rs
new file mode 100644
index 0000000..3d18f94
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/client.rs
@@ -0,0 +1,154 @@
+//! Client-side payment signing for the V2 Solana "exact" scheme.
+//!
+//! This module provides [`V2SolanaExactClient`] for building and signing
+//! SPL Token transfer transactions on Solana using the V2 protocol.
+//!
+//! # Usage
+//!
+//! ```rust
+//! use x402_chain_solana::v2_solana_exact::client::V2SolanaExactClient;
+//! use solana_client::nonblocking::rpc_client::RpcClient;
+//! use solana_keypair::Keypair;
+//!
+//! let keypair = Keypair::new();
+//! let rpc = RpcClient::new("https://api.mainnet-beta.solana.com".to_string());
+//! let client = V2SolanaExactClient::new(keypair, rpc);
+//! ```
+
+use alloy_primitives::U256;
+use async_trait::async_trait;
+use solana_pubkey::Pubkey;
+use solana_signer::Signer;
+use x402_types::proto::PaymentRequired;
+use x402_types::proto::v2::ResourceInfo;
+use x402_types::proto::v2::X402Version2;
+use x402_types::scheme::X402SchemeId;
+use x402_types::scheme::client::{
+    PaymentCandidate, PaymentCandidateSigner, X402Error, X402SchemeClient,
+};
+use x402_types::util::Base64Bytes;
+
+use crate::chain::rpc::RpcClientLike;
+use crate::v1_solana_exact::client::build_signed_transfer_transaction;
+use crate::v1_solana_exact::types::ExactSolanaPayload;
+use crate::v2_solana_exact::V2SolanaExact;
+use crate::v2_solana_exact::types::{PaymentPayload, PaymentRequirements};
+
+/// Client for creating Solana payment payloads for the v2 exact scheme.
+#[derive(Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct V2SolanaExactClient<S, R> {
+    signer: S,
+    rpc_client: R,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl<S, R> V2SolanaExactClient<S, R> {
+    pub fn new(signer: S, rpc_client: R) -> Self {
+        Self { signer, rpc_client }
+    }
+}
+
+impl<S, R> X402SchemeId for V2SolanaExactClient<S, R> {
+    fn x402_version(&self) -> u8 {
+        V2SolanaExact.x402_version()
+    }
+
+    fn namespace(&self) -> &str {
+        V2SolanaExact.namespace()
+    }
+
+    fn scheme(&self) -> &str {
+        V2SolanaExact.scheme()
+    }
+}
+
+impl<S, R> X402SchemeClient for V2SolanaExactClient<S, R>
+where
+    S: Signer + Send + Sync + Clone + 'static,
+    R: RpcClientLike + Send + Sync + Clone + 'static,
+{
+    fn accept(&self, payment_required: &PaymentRequired) -> Vec<PaymentCandidate> {
+        let payment_required = match payment_required {
+            PaymentRequired::V2(payment_required) => payment_required,
+            PaymentRequired::V1(_) => {
+                return vec![];
+            }
+        };
+        payment_required
+            .accepts
+            .iter()
+            .filter_map(|v| {
+                let requirements: PaymentRequirements = v.as_concrete()?;
+                let chain_id = requirements.network.clone();
+                if chain_id.namespace != "solana" {
+                    return None;
+                }
+                let candidate = PaymentCandidate {
+                    chain_id,
+                    asset: requirements.asset.to_string(),
+                    amount: U256::from(requirements.amount.inner()),
+                    scheme: self.scheme().to_string(),
+                    x402_version: self.x402_version(),
+                    pay_to: requirements.pay_to.to_string(),
+                    signer: Box::new(PayloadSigner {
+                        signer: self.signer.clone(),
+                        rpc_client: self.rpc_client.clone(),
+                        requirements,
+                        resource: payment_required.resource.clone(),
+                    }),
+                };
+                Some(candidate)
+            })
+            .collect::<Vec<_>>()
+    }
+}
+
+/// V2 PayloadSigner that uses shared transaction building logic.
+#[allow(dead_code)] // Public for consumption by downstream crates.
+struct PayloadSigner<S, R> {
+    signer: S,
+    rpc_client: R,
+    requirements: PaymentRequirements,
+    resource: ResourceInfo,
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+#[async_trait]
+impl<S: Signer + Sync, R: RpcClientLike + Sync> PaymentCandidateSigner for PayloadSigner<S, R> {
+    async fn sign_payment(&self) -> Result<String, X402Error> {
+        let fee_payer = self
+            .requirements
+            .extra
+            .as_ref()
+            .map(|extra| extra.fee_payer.clone())
+            .ok_or(X402Error::SigningError(
+                "missing fee_payer in extra".to_string(),
+            ))?;
+        let fee_payer_pubkey: Pubkey = fee_payer.into();
+
+        let amount = self.requirements.amount.inner();
+        let tx_b64 = build_signed_transfer_transaction(
+            &self.signer,
+            &self.rpc_client,
+            &fee_payer_pubkey,
+            &self.requirements.pay_to,
+            &self.requirements.asset,
+            amount,
+        )
+        .await?;
+
+        let payload = PaymentPayload {
+            x402_version: X402Version2,
+            accepted: self.requirements.clone(),
+            resource: Some(self.resource.clone()),
+            payload: ExactSolanaPayload {
+                transaction: tx_b64,
+            },
+        };
+        let json = serde_json::to_vec(&payload)?;
+        let b64 = Base64Bytes::encode(&json);
+
+        Ok(b64.to_string())
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/facilitator.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/facilitator.rs
new file mode 100644
index 0000000..5ae58f7
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/facilitator.rs
@@ -0,0 +1,137 @@
+use std::collections::HashMap;
+use x402_types::chain::ChainProviderOps;
+use x402_types::proto;
+use x402_types::proto::v2;
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorBuilder, X402SchemeFacilitatorError,
+};
+
+use crate::V2SolanaExact;
+use crate::chain::provider::SolanaChainProviderLike;
+use crate::v1_solana_exact::facilitator::V1SolanaExactFacilitatorConfig;
+use crate::v1_solana_exact::facilitator::{
+    TransferRequirement, VerifyTransferResult, settle_transaction, verify_transaction,
+};
+use crate::v1_solana_exact::types::SupportedPaymentKindExtra;
+use crate::v2_solana_exact::types;
+
+/// Configuration for V2 Solana Exact facilitator - reuses V1 config
+pub type V2SolanaExactFacilitatorConfig = V1SolanaExactFacilitatorConfig;
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V2SolanaExact
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync + 'static,
+{
+    fn build(
+        &self,
+        provider: P,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        let config = config
+            .map(serde_json::from_value::<V2SolanaExactFacilitatorConfig>)
+            .transpose()?
+            .unwrap_or_default();
+
+        Ok(Box::new(V2SolanaExactFacilitator::new(provider, config)))
+    }
+}
+
+pub struct V2SolanaExactFacilitator<P> {
+    provider: P,
+    config: V2SolanaExactFacilitatorConfig,
+}
+
+impl<P> V2SolanaExactFacilitator<P> {
+    pub fn new(provider: P, config: V2SolanaExactFacilitatorConfig) -> Self {
+        Self { provider, config }
+    }
+}
+
+#[async_trait::async_trait]
+impl<P> X402SchemeFacilitator for V2SolanaExactFacilitator<P>
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync,
+{
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError> {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request, &self.config).await?;
+        Ok(v2::VerifyResponse::valid(verification.payer.to_string()).into())
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError> {
+        let request = types::SettleRequest::from_proto(request.clone())?;
+        let verification = verify_transfer(&self.provider, &request, &self.config).await?;
+        let payer = verification.payer.to_string();
+        let tx_sig = settle_transaction(&self.provider, verification).await?;
+        Ok(v2::SettleResponse::Success {
+            payer,
+            transaction: tx_sig.to_string(),
+            network: self.provider.chain_id().to_string(),
+        }
+        .into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+        let kinds: Vec<proto::SupportedPaymentKind> = {
+            let fee_payer = self.provider.fee_payer();
+            let extra =
+                Some(serde_json::to_value(SupportedPaymentKindExtra { fee_payer }).unwrap());
+            vec![proto::SupportedPaymentKind {
+                x402_version: proto::v2::X402Version2.into(),
+                scheme: types::ExactScheme.to_string(),
+                network: chain_id.to_string(),
+                extra,
+            }]
+        };
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+pub async fn verify_transfer<P: SolanaChainProviderLike + ChainProviderOps>(
+    provider: &P,
+    request: &types::VerifyRequest,
+    config: &V2SolanaExactFacilitatorConfig,
+) -> Result<VerifyTransferResult, proto::PaymentVerificationError> {
+    let payload = &request.payment_payload;
+    let requirements = &request.payment_requirements;
+
+    let accepted = &payload.accepted;
+    if accepted != requirements {
+        return Err(proto::PaymentVerificationError::AcceptedRequirementsMismatch);
+    }
+
+    let chain_id = provider.chain_id();
+    let payload_chain_id = &accepted.network;
+    if payload_chain_id != &chain_id {
+        return Err(proto::PaymentVerificationError::UnsupportedChain);
+    }
+    let transaction_b64_string = payload.payload.transaction.clone();
+    let transfer_requirement = TransferRequirement {
+        pay_to: &requirements.pay_to,
+        asset: &requirements.asset,
+        amount: requirements.amount.inner(),
+    };
+    verify_transaction(
+        provider,
+        transaction_b64_string,
+        &transfer_requirement,
+        config,
+    )
+    .await
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/mod.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/mod.rs
new file mode 100644
index 0000000..89c1a1f
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/mod.rs
@@ -0,0 +1,65 @@
+//! V2 Solana "exact" payment scheme implementation.
+//!
+//! This module implements the "exact" payment scheme for Solana using
+//! the V2 x402 protocol. It builds on the V1 implementation but uses
+//! CAIP-2 chain identifiers instead of network names.
+//!
+//! # Differences from V1
+//!
+//! - Uses CAIP-2 chain IDs (e.g., `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`) instead of network names
+//! - Payment requirements are embedded in the payload for verification
+//! - Cleaner separation between accepted requirements and authorization
+//!
+//! # Features
+//!
+//! - SPL Token and Token-2022 program support
+//! - Compute budget instruction validation
+//! - Transaction simulation before settlement
+//! - Fee payer safety checks
+//! - Configurable instruction allowlists/blocklists
+//!
+//! # Usage
+//!
+//! ```ignore
+//! use x402_chain_solana::v2_solana_exact::V2SolanaExact;
+//! use x402_chain_solana::networks::{KnownNetworkSolana, USDC};
+//!
+//! // Create a price tag for 1 USDC on Solana mainnet
+//! let usdc = USDC::solana_mainnet();
+//! let price = V2SolanaExact::price_tag(
+//!     recipient_pubkey, // pay_to address
+//!     usdc.amount(1_000_000),  // 1 USDC
+//! );
+//! ```
+
+#[cfg(feature = "server")]
+pub mod server;
+#[cfg(feature = "server")]
+pub use server::*;
+
+#[cfg(feature = "facilitator")]
+pub mod facilitator;
+#[cfg(feature = "facilitator")]
+pub use facilitator::*;
+
+#[cfg(feature = "client")]
+pub mod client;
+#[cfg(feature = "client")]
+pub use client::*;
+
+pub mod types;
+pub use types::*;
+
+use x402_types::scheme::X402SchemeId;
+
+pub struct V2SolanaExact;
+
+impl X402SchemeId for V2SolanaExact {
+    fn namespace(&self) -> &str {
+        "solana"
+    }
+
+    fn scheme(&self) -> &str {
+        ExactScheme.as_ref()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/server.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/server.rs
new file mode 100644
index 0000000..034ab8d
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/server.rs
@@ -0,0 +1,59 @@
+use std::sync::Arc;
+use x402_types::chain::{ChainId, DeployedTokenAmount};
+use x402_types::proto;
+use x402_types::proto::v2;
+
+use crate::V2SolanaExact;
+use crate::chain::{Address, SolanaTokenDeployment};
+use crate::v1_solana_exact::SupportedPaymentKindExtra;
+use crate::v1_solana_exact::types::ExactScheme;
+
+impl V2SolanaExact {
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn price_tag<A: Into<Address>>(
+        pay_to: A,
+        asset: DeployedTokenAmount<u64, SolanaTokenDeployment>,
+    ) -> v2::PriceTag {
+        let chain_id: ChainId = asset.token.chain_reference.into();
+        let requirements = v2::PaymentRequirements {
+            scheme: ExactScheme.to_string(),
+            pay_to: pay_to.into().to_string(),
+            asset: asset.token.address.to_string(),
+            network: chain_id,
+            amount: asset.amount.to_string(),
+            max_timeout_seconds: 300,
+            extra: None,
+        };
+        v2::PriceTag {
+            requirements,
+            enricher: Some(Arc::new(solana_fee_payer_enricher_v2)),
+        }
+    }
+}
+
+/// Enricher function for V2 Solana price tags - adds fee_payer to extra field
+pub fn solana_fee_payer_enricher_v2(
+    price_tag: &mut v2::PriceTag,
+    capabilities: &proto::SupportedResponse,
+) {
+    if price_tag.requirements.extra.is_some() {
+        return;
+    }
+
+    // Find the matching kind and deserialize the whole extra into SupportedPaymentKindExtra
+    let extra = capabilities
+        .kinds
+        .iter()
+        .find(|kind| {
+            v2::X402Version2 == kind.x402_version
+                && kind.scheme == ExactScheme.to_string()
+                && kind.network == price_tag.requirements.network.to_string()
+        })
+        .and_then(|kind| kind.extra.as_ref())
+        .and_then(|extra| serde_json::from_value::<SupportedPaymentKindExtra>(extra.clone()).ok());
+
+    // Serialize the whole extra back to Value
+    if let Some(extra) = extra {
+        price_tag.requirements.extra = serde_json::to_value(&extra).ok();
+    }
+}
diff --git a/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/types.rs b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/types.rs
new file mode 100644
index 0000000..ac4ee94
--- /dev/null
+++ b/bbt-x402-facilitator/crates/chains/x402-chain-solana/src/v2_solana_exact/types.rs
@@ -0,0 +1,18 @@
+//! Type definitions for the V2 Solana "exact" payment scheme.
+//!
+//! This module re-exports types from V1 and defines V2-specific wire format
+//! types for SPL Token based payments on Solana.
+
+use x402_types::proto::util::U64String;
+use x402_types::proto::v2;
+
+use crate::chain::Address;
+use crate::v1_solana_exact::types::{ExactSolanaPayload, SupportedPaymentKindExtra};
+
+pub use crate::v1_solana_exact::types::ExactScheme;
+
+pub type VerifyRequest = v2::VerifyRequest<PaymentPayload, PaymentRequirements>;
+pub type SettleRequest = VerifyRequest;
+pub type PaymentPayload = v2::PaymentPayload<PaymentRequirements, ExactSolanaPayload>;
+pub type PaymentRequirements =
+    v2::PaymentRequirements<ExactScheme, U64String, Address, SupportedPaymentKindExtra>;
diff --git a/bbt-x402-facilitator/crates/x402-axum/Cargo.toml b/bbt-x402-facilitator/crates/x402-axum/Cargo.toml
new file mode 100644
index 0000000..213b772
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/Cargo.toml
@@ -0,0 +1,43 @@
+[package]
+name = "x402-axum"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+categories.workspace = true
+keywords.workspace = true
+description = "Axum middleware for enforcing x402 protocol payments on protected routes"
+documentation = "https://docs.rs/x402-axum"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[dependencies]
+x402-types = { workspace = true }
+url = { workspace = true }
+serde_json = { workspace = true }
+reqwest = { workspace = true }
+serde = { workspace = true }
+thiserror = { workspace = true }
+tower = { workspace = true }
+http = { workspace = true }
+tokio = { workspace = true }
+axum-core = { version = "0.5" }
+
+# Telemetry
+tracing = { workspace = true, optional = true }
+
+[dev-dependencies]
+wiremock = "0.6"
+axum = { workspace = true }
+alloy-primitives = { workspace = true }
+x402-chain-eip155 = { workspace = true, features = ["server"] }
+
+[features]
+default = []
+telemetry = ["dep:tracing", "x402-types/telemetry"]
+full = ["telemetry"]
diff --git a/bbt-x402-facilitator/crates/x402-axum/LICENSE b/bbt-x402-facilitator/crates/x402-axum/LICENSE
new file mode 100644
index 0000000..0e18545
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2025 Sergey Ukustov
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
\ No newline at end of file
diff --git a/bbt-x402-facilitator/crates/x402-axum/README.md b/bbt-x402-facilitator/crates/x402-axum/README.md
new file mode 100644
index 0000000..b132e19
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/README.md
@@ -0,0 +1,370 @@
+# x402-axum
+
+[![Crates.io](https://img.shields.io/crates/v/x402-axum.svg)](https://crates.io/crates/x402-axum)
+[![Docs.rs](https://docs.rs/x402-axum/badge.svg)](https://docs.rs/x402-axum)
+
+**Axum middleware for protecting routes with [x402 protocol](https://www.x402.org) payments.**
+
+This crate provides a drop-in `tower::Layer` that intercepts incoming requests,
+validates payment headers using a configured x402 facilitator,
+and settles the payment before or after request execution (configurable).
+
+If no valid payment is provided, a `402 Payment Required` response is returned with details about accepted assets and amounts.
+
+## Features
+
+- Built for [Axum](https://github.com/tokio-rs/axum)
+- Full Protocol v2 Support - Complete implementation of x402 protocol v2
+- Multi-chain Support - EVM (EIP-155), Solana, and Aptos chains
+- Multi-scheme Architecture - Support for various payment schemes
+- Fluent builder API for configuring payment requirements
+- Configurable settlement timing (before or after request execution)
+- Returns standards-compliant `402 Payment Required` responses
+- Emits rich tracing spans with optional OpenTelemetry integration (`telemetry` feature)
+- Compatible with any x402 facilitator
+- Configurable facilitator cache TTL for performance optimization
+
+## Installation
+
+Add to your `Cargo.toml`:
+
+```toml
+x402-axum = "0.8"
+```
+
+If you want to enable tracing and OpenTelemetry support, use the telemetry feature:
+
+```toml
+x402-axum = { version = "0.8", features = ["telemetry"] }
+```
+
+## Quickstart
+
+```rust,no_run
+use alloy_primitives::address;
+use axum::{Router, routing::get};
+use axum::response::IntoResponse;
+use http::StatusCode;
+use x402_axum::X402Middleware;
+use x402_chain_eip155::{KnownNetworkEip155, V1Eip155Exact};
+use x402_types::networks::USDC;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs");
+
+let app: Router = Router::new().route(
+    "/protected",
+    get(my_handler).layer(
+        x402.with_price_tag(V1Eip155Exact::price_tag(
+            address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+            USDC::base_sepolia().parse("0.01").unwrap(),
+        ))
+    ),
+);
+
+async fn my_handler() -> impl IntoResponse {
+    (StatusCode::OK, "This is VIP content!")
+}
+```
+
+## Settlement Timing
+
+By default, the middleware settles payments **after** request execution. You can change this:
+
+```rust
+let x402 = X402Middleware::new("https://facilitator.x402.rs")
+    .settle_before_execution();  // Settle before executing the handler
+```
+
+Or explicitly set settlement after execution (default behavior):
+
+```rust
+let x402 = X402Middleware::new("https://facilitator.x402.rs")
+    .settle_after_execution();  // Settle after successful request execution
+```
+
+## Dynamic Pricing
+
+The middleware supports dynamic pricing through the `with_dynamic_price` method, which allows you to compute prices per-request based on headers, URI, or other runtime factors:
+
+```rust,no_run
+use alloy_primitives::address;
+use axum::Router;
+use axum::routing::get;
+use x402_axum::X402Middleware;
+use x402_chain_eip155::{KnownNetworkEip155, V2Eip155Exact};
+use x402_types::networks::USDC;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs");
+
+let app = Router::new().route(
+    "/api/data",
+    get(handler).layer(x402.with_dynamic_price(|_headers, uri, _base_url| {
+        // Check for discount query parameter
+        let has_discount = uri.query().map(|q| q.contains("discount")).unwrap_or(false);
+        let amount = if has_discount { 50 } else { 100 };
+
+        async move {
+            vec![V2Eip155Exact::price_tag(
+                address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                USDC::base_sepolia().amount(amount),
+            )]
+        }
+    })),
+);
+```
+
+### Conditional Free Access (Empty Price Tags)
+
+When the dynamic pricing callback returns an **empty vector**, the middleware bypasses payment enforcement entirely and forwards the request directly to the handler. This is useful for implementing:
+
+- Free tiers or promotional access
+- Conditional pricing based on user authentication
+- A/B testing with paid vs free access
+
+```rust,no_run
+use alloy_primitives::address;
+use axum::Router;
+use axum::routing::get;
+use x402_axum::X402Middleware;
+use x402_chain_eip155::{KnownNetworkEip155, V2Eip155Exact};
+use x402_types::networks::USDC;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs");
+
+let app = Router::new().route(
+    "/api/data",
+    get(handler).layer(x402.with_dynamic_price(|_headers, uri, _base_url| {
+        // Check if "free" query parameter is present
+        let is_free = uri.query().map(|q| q.contains("free")).unwrap_or(false);
+
+        async move {
+            if is_free {
+                // Return empty vector to bypass payment enforcement
+                vec![]
+            } else {
+                // Normal pricing - payment required
+                vec![V2Eip155Exact::price_tag(
+                    address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                    USDC::base_sepolia().amount(100),
+                )]
+            }
+        }
+    })),
+);
+```
+
+With this configuration:
+- `GET /api/data` â†’ Returns 402 Payment Required
+- `GET /api/data?free` â†’ Bypasses payment, returns content directly
+
+## Defining Prices
+
+Prices are defined using the scheme-specific price tag types from the chain-specific crates. The following
+built-in schemes are available:
+
+- **`V1Eip155Exact::price_tag()`** - V1 EIP-155 exact payment on EVM chains (ERC-3009)
+- **`V2Eip155Exact::price_tag()`** - V2 EIP-155 exact payment on EVM chains (ERC-3009)
+- **`V1SolanaExact::price_tag()`** - V1 Solana exact payment (SPL token transfer)
+- **`V2SolanaExact::price_tag()`** - V2 Solana exact payment (SPL token transfer)
+- **`V2AptosExact::price_tag()`** - V2 Aptos exact payment (Coin transfer)
+
+### Built-in Schemes
+
+```rust,no_run
+use alloy_primitives::address;
+use axum::Router;
+use axum::routing::get;
+use solana_pubkey::pubkey;
+use x402_axum::X402Middleware;
+use x402_chain_eip155::{KnownNetworkEip155, V1Eip155Exact};
+use x402_chain_solana::{KnownNetworkSolana, V1SolanaExact};
+use x402_types::networks::USDC;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs");
+
+// Accept both EVM and Solana payments
+let app = Router::new().route(
+    "/premium",
+    get(handler).layer(
+        x402.with_price_tag(V1Eip155Exact::price_tag(
+            address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+            USDC::base_sepolia().parse("0.01").unwrap(),
+        )).with_price_tag(V1SolanaExact::price_tag(
+            pubkey!("EGBQqKn968sVv5cQh5Cr72pSTHfxsuzq7o7asqYB5uEV"),
+            USDC::solana().amount(100),
+        ))
+    ),
+);
+```
+
+### Custom Schemes
+
+You can implement custom payment schemes by implementing the [`PaygateProtocol`] trait from
+`x402_axum::paygate`. This allows you to support additional blockchains, payment mechanisms,
+or otherwise custom schemes.
+
+To create a custom scheme, you'll need to:
+
+1. **Define your scheme struct** - A unit struct that serves as a namespace for your scheme
+2. **Add a `price_tag` method** - A static method that constructs the protocol-specific price tag
+3. **Implement [`PaygateProtocol`]** - Handle verification, error responses, and facilitator enrichment
+
+Example structure for a custom scheme:
+
+```rust
+use axum_core::response::Response;
+use x402_axum::paygate::{PaygateError, PaygateProtocol, ResourceInfoBuilder, VerificationError};
+use x402_types::proto::{self, v2, SupportedResponse};
+
+/// Your custom scheme struct
+pub struct MyCustomScheme;
+
+impl MyCustomScheme {
+    /// Create a price tag for this scheme
+    pub fn price_tag(
+        pay_to: String,
+        asset: String,
+        amount: u64,
+    ) -> v2::PriceTag {
+        v2::PriceTag {
+            requirements: v2::PaymentRequirements {
+                scheme: "my-custom-scheme".to_string(),
+                pay_to,
+                asset,
+                network: /* your chain id */,
+                amount: amount.to_string(),
+                max_timeout_seconds: 300,
+                extra: None,
+            },
+            enricher: None, // Or Some(Arc::new(your_enricher_fn)) if needed
+        }
+    }
+}
+
+// Implement PaygateProtocol for the price tag type (v2::PriceTag in this case)
+// Note: PaygateProtocol is already implemented for v1::PriceTag and v2::PriceTag
+// You only need to implement it if you're creating a completely custom price tag type
+```
+
+For a complete example, see the [How to Write a Scheme](../../docs/how-to-write-a-scheme.md) guide.
+
+## Configuration
+
+### Base URL
+
+Set a base URL for computing resource URLs dynamically:
+
+```rust
+use url::Url;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs")
+    .with_base_url(Url::parse("https://api.example.com").unwrap());
+```
+
+### Resource URL
+
+Set an explicit resource URL (recommended in production):
+
+```rust
+use alloy_primitives::address;
+use axum::Router;
+use axum::routing::get;
+use url::Url;
+use x402_chain_eip155::V1Eip155Exact;
+use x402_types::networks::USDC;
+
+let app = Router::new().route(
+    "/premium-content",
+    get(handler).layer(
+        x402.with_price_tag(V1Eip155Exact::price_tag(
+            address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+            USDC::base_sepolia().parse("0.01").unwrap(),
+        )).with_resource(Url::parse("https://api.example.com/premium-content").unwrap())
+    ),
+);
+```
+
+### Description and MIME Type
+
+```rust
+let app = Router::new().route(
+    "/api/data",
+    get(handler).layer(
+        x402.with_price_tag(price_tag)
+            .with_description("Access to premium API")
+            .with_mime_type("application/json")
+    ),
+);
+```
+
+### Facilitator Cache TTL
+
+Configure the TTL for caching the facilitator's supported response:
+
+```rust
+use std::time::Duration;
+
+let x402 = X402Middleware::new("https://facilitator.x402.rs")
+    .with_supported_cache_ttl(Duration::from_secs(300)); // 5 minutes
+```
+
+To disable caching entirely:
+
+```rust
+let x402 = X402Middleware::new("https://facilitator.x402.rs")
+    .with_supported_cache_ttl(Duration::from_secs(0));
+```
+
+## HTTP Behavior
+
+If no valid payment is included, the middleware responds with a 402 Payment Required:
+
+**V1 Protocol:**
+```json
+// HTTP/1.1 402 Payment Required
+// Content-Type: application/json
+{
+  "error": "X-PAYMENT header is required",
+  "accepts": [...],
+  "x402Version": "1"
+}
+```
+
+**V2 Protocol:**
+```
+// HTTP/1.1 402 Payment Required
+// Payment-Required: <base64-encoded PaymentRequired>
+```
+
+## Error Handling
+
+The middleware provides detailed error information through the `VerificationError` and `PaygateError` types:
+
+- `VerificationError::PaymentHeaderRequired`: Missing payment header
+- `VerificationError::InvalidPaymentHeader`: Malformed payment header
+- `VerificationError::NoPaymentMatching`: No matching payment requirements found
+- `VerificationError::VerificationFailed`: Payment verification failed
+- `PaygateError::Settlement`: Payment settlement failed
+
+These errors are automatically converted to appropriate 402 Payment Required responses with detailed error messages.
+
+## Optional Telemetry
+
+If the `telemetry` feature is enabled, the middleware emits structured tracing spans:
+- `x402.handle_request`
+- `x402.verify_payment`
+- `x402.settle_payment`
+
+You can connect these to OpenTelemetry exporters like Jaeger, Tempo, or Otel Collector.
+
+## Related Crates
+
+- [x402-types](https://crates.io/crates/x402-types): Core x402 types, facilitator traits, protocol definitions.
+- [x402-reqwest](https://crates.io/crates/x402-reqwest): Reqwest middleware for paying x402 requests.
+- [x402-chain-eip155](https://crates.io/crates/x402-chain-eip155): EVM/EIP-155 chain support for x402.
+- [x402-chain-solana](https://crates.io/crates/x402-chain-solana): Solana chain support for x402.
+- [x402-chain-aptos](https://crates.io/crates/x402-chain-aptos): Aptos chain support for x402.
+
+## License
+
+[Apache-2.0](LICENSE)
diff --git a/bbt-x402-facilitator/crates/x402-axum/src/facilitator_client.rs b/bbt-x402-facilitator/crates/x402-axum/src/facilitator_client.rs
new file mode 100644
index 0000000..426dee7
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/src/facilitator_client.rs
@@ -0,0 +1,667 @@
+//! A [`x402_types::facilitator::Facilitator`] implementation that interacts with a _remote_ x402 Facilitator over HTTP.
+//!
+//! This [`FacilitatorClient`] handles the `/verify`, `/settle`, and `/supported` endpoints of a remote facilitator,
+//! and implements the [`x402_types::facilitator::Facilitator`] trait for compatibility
+//! with x402-based middleware and logic.
+//!
+//! ## Example
+//!
+//! ```rust
+//! use x402_axum::facilitator_client::FacilitatorClient;
+//!
+//! let facilitator = FacilitatorClient::try_from("https://facilitator.x402.rs").unwrap();
+//! ```
+//!
+//! ## Features
+//!
+//! - Uses `reqwest` for async HTTP requests
+//! - Supports optional timeout and headers
+//! - Integrates with `tracing` if the `telemetry` feature is enabled
+//!
+//! ## Error Handling
+//!
+//! Custom error types capture detailed failure contexts, including
+//! - URL construction
+//! - HTTP transport failures
+//! - JSON deserialization errors
+//! - Unexpected HTTP status responses
+//!
+
+use http::{HeaderMap, StatusCode};
+use reqwest::Client;
+use std::fmt::Display;
+use std::time::Duration;
+use tokio::sync::RwLock;
+use url::Url;
+use x402_types::facilitator::Facilitator;
+use x402_types::proto::{
+    SettleRequest, SettleResponse, SupportedResponse, VerifyRequest, VerifyResponse,
+};
+
+#[cfg(feature = "telemetry")]
+use tracing::{Instrument, Span, instrument};
+
+/// TTL cache for [`SupportedResponse`].
+#[derive(Clone, Debug)]
+struct SupportedCacheState {
+    /// The cached response
+    response: SupportedResponse,
+    /// When the cache expires
+    expires_at: std::time::Instant,
+}
+
+/// An encapsulated TTL cache for the `/supported` endpoint response.
+///
+/// Each clone has an independent cache state.
+#[derive(Debug)]
+pub struct SupportedCache {
+    /// TTL for the cache
+    ttl: Duration,
+    /// Cache state (RwLock for read-heavy workload)
+    state: RwLock<Option<SupportedCacheState>>,
+}
+
+impl SupportedCache {
+    /// Creates a new cache with the given TTL.
+    pub fn new(ttl: Duration) -> Self {
+        Self {
+            ttl,
+            state: RwLock::new(None),
+        }
+    }
+
+    /// Returns the cached response if valid, None otherwise.
+    pub async fn get(&self) -> Option<SupportedResponse> {
+        let guard = self.state.read().await;
+        let cache = guard.as_ref()?;
+        if std::time::Instant::now() < cache.expires_at {
+            Some(cache.response.clone())
+        } else {
+            None
+        }
+    }
+
+    /// Stores a response in the cache with the configured TTL.
+    pub async fn set(&self, response: SupportedResponse) {
+        let mut guard = self.state.write().await;
+        *guard = Some(SupportedCacheState {
+            response,
+            expires_at: std::time::Instant::now() + self.ttl,
+        });
+    }
+
+    /// Clears the cache.
+    pub async fn clear(&self) {
+        let mut guard = self.state.write().await;
+        *guard = None;
+    }
+}
+
+impl Clone for SupportedCache {
+    fn clone(&self) -> Self {
+        Self::new(self.ttl)
+    }
+}
+
+/// A client for communicating with a remote x402 facilitator.
+///
+/// Handles `/verify`, `/settle`, and `/supported` endpoints via JSON HTTP.
+#[derive(Clone, Debug)]
+pub struct FacilitatorClient {
+    /// Base URL of the facilitator (e.g. `https://facilitator.example/`)
+    base_url: Url,
+    /// Full URL to `POST /verify` requests
+    verify_url: Url,
+    /// Full URL to `POST /settle` requests
+    settle_url: Url,
+    /// Full URL to `GET /supported` requests
+    supported_url: Url,
+    /// Shared Reqwest HTTP client
+    client: Client,
+    /// Optional custom headers sent with each request
+    headers: HeaderMap,
+    /// Optional request timeout
+    timeout: Option<Duration>,
+    /// Cache for the supported endpoint response
+    supported_cache: SupportedCache,
+}
+
+impl Facilitator for FacilitatorClient {
+    type Error = FacilitatorClientError;
+
+    /// Verifies a payment payload with the facilitator.
+    #[cfg(feature = "telemetry")]
+    async fn verify(
+        &self,
+        request: &VerifyRequest,
+    ) -> Result<VerifyResponse, FacilitatorClientError> {
+        with_span(
+            FacilitatorClient::verify(self, request),
+            tracing::info_span!("x402.facilitator_client.verify", timeout = ?self.timeout),
+        )
+        .await
+    }
+
+    /// Verifies a payment payload with the facilitator.
+    #[cfg(not(feature = "telemetry"))]
+    async fn verify(
+        &self,
+        request: &VerifyRequest,
+    ) -> Result<VerifyResponse, FacilitatorClientError> {
+        FacilitatorClient::verify(self, request).await
+    }
+
+    /// Settles a verified payment with the facilitator.
+    #[cfg(feature = "telemetry")]
+    async fn settle(
+        &self,
+        request: &SettleRequest,
+    ) -> Result<SettleResponse, FacilitatorClientError> {
+        with_span(
+            FacilitatorClient::settle(self, request),
+            tracing::info_span!("x402.facilitator_client.settle", timeout = ?self.timeout),
+        )
+        .await
+    }
+
+    /// Settles a verified payment with the facilitator.
+    #[cfg(not(feature = "telemetry"))]
+    async fn settle(
+        &self,
+        request: &SettleRequest,
+    ) -> Result<SettleResponse, FacilitatorClientError> {
+        FacilitatorClient::settle(self, request).await
+    }
+
+    /// Retrieves the supported payment kinds from the facilitator.
+    ///
+    /// Results are cached with a configurable TTL to avoid repeated HTTP requests.
+    async fn supported(&self) -> Result<SupportedResponse, Self::Error> {
+        FacilitatorClient::supported(self).await
+    }
+}
+
+/// Errors that can occur while interacting with a remote facilitator.
+#[derive(Debug, thiserror::Error)]
+pub enum FacilitatorClientError {
+    #[error("URL parse error: {context}: {source}")]
+    UrlParse {
+        context: &'static str,
+        #[source]
+        source: url::ParseError,
+    },
+    #[error("HTTP error: {context}: {source}")]
+    Http {
+        context: &'static str,
+        #[source]
+        source: reqwest::Error,
+    },
+    #[error("Failed to deserialize JSON: {context}: {source}")]
+    JsonDeserialization {
+        context: &'static str,
+        #[source]
+        source: reqwest::Error,
+    },
+    #[error("Unexpected HTTP status {status}: {context}: {body}")]
+    HttpStatus {
+        context: &'static str,
+        status: StatusCode,
+        body: String,
+    },
+    #[error("Failed to read response body as text: {context}: {source}")]
+    ResponseBodyRead {
+        context: &'static str,
+        #[source]
+        source: reqwest::Error,
+    },
+}
+
+impl FacilitatorClient {
+    /// Default TTL for caching the supported endpoint response (10 minutes).
+    pub const DEFAULT_SUPPORTED_CACHE_TTL: Duration = Duration::from_secs(10 * 60);
+
+    /// Returns the base URL used by this client.
+    pub fn base_url(&self) -> &Url {
+        &self.base_url
+    }
+
+    /// Returns the computed `./verify` URL relative to [`FacilitatorClient::base_url`].
+    pub fn verify_url(&self) -> &Url {
+        &self.verify_url
+    }
+
+    /// Returns the computed `./settle` URL relative to [`FacilitatorClient::base_url`].
+    pub fn settle_url(&self) -> &Url {
+        &self.settle_url
+    }
+
+    /// Returns the computed `./supported` URL relative to [`FacilitatorClient::base_url`].
+    pub fn supported_url(&self) -> &Url {
+        &self.supported_url
+    }
+
+    /// Returns any custom headers configured on the client.
+    pub fn headers(&self) -> &HeaderMap {
+        &self.headers
+    }
+
+    /// Returns the configured timeout, if any.
+    pub fn timeout(&self) -> &Option<Duration> {
+        &self.timeout
+    }
+
+    /// Returns a reference to the supported cache.
+    pub fn supported_cache(&self) -> &SupportedCache {
+        &self.supported_cache
+    }
+
+    /// Constructs a new [`FacilitatorClient`] from a base URL.
+    ///
+    /// This sets up `./verify`, `./settle`, and `./supported` endpoint URLs relative to the base.
+    pub fn try_new(base_url: Url) -> Result<Self, FacilitatorClientError> {
+        let client = Client::new();
+        let verify_url =
+            base_url
+                .join("./verify")
+                .map_err(|e| FacilitatorClientError::UrlParse {
+                    context: "Failed to construct ./verify URL",
+                    source: e,
+                })?;
+        let settle_url =
+            base_url
+                .join("./settle")
+                .map_err(|e| FacilitatorClientError::UrlParse {
+                    context: "Failed to construct ./settle URL",
+                    source: e,
+                })?;
+        let supported_url =
+            base_url
+                .join("./supported")
+                .map_err(|e| FacilitatorClientError::UrlParse {
+                    context: "Failed to construct ./supported URL",
+                    source: e,
+                })?;
+        Ok(Self {
+            client,
+            base_url,
+            verify_url,
+            settle_url,
+            supported_url,
+            headers: HeaderMap::new(),
+            timeout: None,
+            supported_cache: SupportedCache::new(Self::DEFAULT_SUPPORTED_CACHE_TTL),
+        })
+    }
+
+    /// Attaches custom headers to all future requests.
+    pub fn with_headers(&self, headers: HeaderMap) -> Self {
+        let mut this = self.clone();
+        this.headers = headers;
+        this
+    }
+
+    /// Sets a timeout for all future requests.
+    pub fn with_timeout(&self, timeout: Duration) -> Self {
+        let mut this = self.clone();
+        this.timeout = Some(timeout);
+        this
+    }
+
+    /// Sets the TTL for caching the supported endpoint response.
+    ///
+    /// Default is 10 minutes. Use [`Self::without_supported_cache()`] to disable caching.
+    pub fn with_supported_cache_ttl(&self, ttl: Duration) -> Self {
+        let mut this = self.clone();
+        this.supported_cache = SupportedCache::new(ttl);
+        this
+    }
+
+    /// Disables caching for the supported endpoint.
+    pub fn without_supported_cache(&self) -> Self {
+        self.with_supported_cache_ttl(Duration::ZERO)
+    }
+
+    /// Sends a `POST /verify` request to the facilitator.
+    pub async fn verify(
+        &self,
+        request: &VerifyRequest,
+    ) -> Result<VerifyResponse, FacilitatorClientError> {
+        self.post_json(&self.verify_url, "POST /verify", request)
+            .await
+    }
+
+    /// Sends a `POST /settle` request to the facilitator.
+    pub async fn settle(
+        &self,
+        request: &SettleRequest,
+    ) -> Result<SettleResponse, FacilitatorClientError> {
+        self.post_json(&self.settle_url, "POST /settle", request)
+            .await
+    }
+
+    /// Sends a `GET /supported` request to the facilitator.
+    /// This is the inner method that always makes an HTTP request.
+    #[cfg_attr(
+        feature = "telemetry",
+        instrument(name = "x402.facilitator_client.supported", skip_all, err)
+    )]
+    async fn supported_inner(&self) -> Result<SupportedResponse, FacilitatorClientError> {
+        self.get_json(&self.supported_url, "GET /supported").await
+    }
+
+    /// Sends a `GET /supported` request to the facilitator.
+    /// Results are cached with a configurable TTL (default: 10 minutes).
+    /// Use [`Self::supported_inner()`] to bypass the cache.
+    pub async fn supported(&self) -> Result<SupportedResponse, FacilitatorClientError> {
+        // Try to get from cache
+        if let Some(response) = self.supported_cache.get().await {
+            return Ok(response);
+        }
+
+        // Cache miss - fetch and cache
+        #[cfg(feature = "telemetry")]
+        tracing::info!("x402.facilitator_client.supported_cache_miss");
+
+        let response = self.supported_inner().await?;
+        self.supported_cache.set(response.clone()).await;
+
+        Ok(response)
+    }
+
+    /// Generic POST helper that handles JSON serialization, error mapping,
+    /// timeout application, and telemetry integration.
+    ///
+    /// `context` is a human-readable identifier used in tracing and error messages (e.g. `"POST /verify"`).
+    async fn post_json<T, R>(
+        &self,
+        url: &Url,
+        context: &'static str,
+        payload: &T,
+    ) -> Result<R, FacilitatorClientError>
+    where
+        T: serde::Serialize + ?Sized,
+        R: serde::de::DeserializeOwned,
+    {
+        let mut req = self.client.post(url.clone()).json(payload);
+        for (key, value) in self.headers.iter() {
+            req = req.header(key, value);
+        }
+        if let Some(timeout) = self.timeout {
+            req = req.timeout(timeout);
+        }
+        let http_response = req
+            .send()
+            .await
+            .map_err(|e| FacilitatorClientError::Http { context, source: e })?;
+
+        let result = if http_response.status() == StatusCode::OK {
+            http_response
+                .json::<R>()
+                .await
+                .map_err(|e| FacilitatorClientError::JsonDeserialization { context, source: e })
+        } else {
+            let status = http_response.status();
+            let body = http_response
+                .text()
+                .await
+                .map_err(|e| FacilitatorClientError::ResponseBodyRead { context, source: e })?;
+            Err(FacilitatorClientError::HttpStatus {
+                context,
+                status,
+                body,
+            })
+        };
+
+        record_result_on_span(&result);
+
+        result
+    }
+
+    /// Generic GET helper that handles JSON serialization, error mapping,
+    /// timeout application, and telemetry integration.
+    ///
+    /// `context` is a human-readable identifier used in tracing and error messages (e.g. `"GET /supported"`).
+    async fn get_json<R>(
+        &self,
+        url: &Url,
+        context: &'static str,
+    ) -> Result<R, FacilitatorClientError>
+    where
+        R: serde::de::DeserializeOwned,
+    {
+        let mut req = self.client.get(url.clone());
+        for (key, value) in self.headers.iter() {
+            req = req.header(key, value);
+        }
+        if let Some(timeout) = self.timeout {
+            req = req.timeout(timeout);
+        }
+        let http_response = req
+            .send()
+            .await
+            .map_err(|e| FacilitatorClientError::Http { context, source: e })?;
+
+        let result = if http_response.status() == StatusCode::OK {
+            http_response
+                .json::<R>()
+                .await
+                .map_err(|e| FacilitatorClientError::JsonDeserialization { context, source: e })
+        } else {
+            let status = http_response.status();
+            let body = http_response
+                .text()
+                .await
+                .map_err(|e| FacilitatorClientError::ResponseBodyRead { context, source: e })?;
+            Err(FacilitatorClientError::HttpStatus {
+                context,
+                status,
+                body,
+            })
+        };
+
+        record_result_on_span(&result);
+
+        result
+    }
+}
+
+/// Converts a string URL into a `FacilitatorClient`, parsing the URL and calling `try_new`.
+impl TryFrom<&str> for FacilitatorClient {
+    type Error = FacilitatorClientError;
+
+    fn try_from(value: &str) -> Result<Self, Self::Error> {
+        // Normalize: strip trailing slashes and add a single trailing slash
+        let mut normalized = value.trim_end_matches('/').to_string();
+        normalized.push('/');
+        let url = Url::parse(&normalized).map_err(|e| FacilitatorClientError::UrlParse {
+            context: "Failed to parse base url",
+            source: e,
+        })?;
+        FacilitatorClient::try_new(url)
+    }
+}
+
+/// Converts a String URL into a `FacilitatorClient`.
+impl TryFrom<String> for FacilitatorClient {
+    type Error = FacilitatorClientError;
+
+    fn try_from(value: String) -> Result<Self, Self::Error> {
+        FacilitatorClient::try_from(value.as_str())
+    }
+}
+
+/// Records the outcome of a request on a tracing span, including status and errors.
+#[cfg(feature = "telemetry")]
+fn record_result_on_span<R, E: Display>(result: &Result<R, E>) {
+    let span = Span::current();
+    match result {
+        Ok(_) => {
+            span.record("otel.status_code", "OK");
+        }
+        Err(err) => {
+            span.record("otel.status_code", "ERROR");
+            span.record("error.message", tracing::field::display(err));
+            tracing::event!(tracing::Level::ERROR, error = %err, "Request to facilitator failed");
+        }
+    }
+}
+
+/// Records the outcome of a request on a tracing span, including status and errors.
+/// Noop if telemetry feature is off.
+#[cfg(not(feature = "telemetry"))]
+fn record_result_on_span<R, E: Display>(_result: &Result<R, E>) {}
+
+/// Instruments a future with a given tracing span.
+#[cfg(feature = "telemetry")]
+fn with_span<F: Future>(fut: F, span: Span) -> impl Future<Output = F::Output> {
+    fut.instrument(span)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::collections::HashMap;
+    use wiremock::matchers::{method, path};
+    use wiremock::{Mock, MockServer, ResponseTemplate};
+    use x402_types::proto::SupportedPaymentKind;
+
+    fn create_test_supported_response() -> SupportedResponse {
+        SupportedResponse {
+            kinds: vec![SupportedPaymentKind {
+                x402_version: 1,
+                scheme: "eip155-exact".to_string(),
+                network: "1".to_string(),
+                extra: None,
+            }],
+            extensions: vec![],
+            signers: HashMap::new(),
+        }
+    }
+
+    #[tokio::test]
+    async fn test_supported_cache_caches_response() {
+        let mock_server = MockServer::start().await;
+        let test_response = create_test_supported_response();
+
+        // Mock the supported endpoint
+        Mock::given(method("GET"))
+            .and(path("/supported"))
+            .respond_with(ResponseTemplate::new(200).set_body_json(&test_response))
+            .mount(&mock_server)
+            .await;
+
+        let client = FacilitatorClient::try_new(mock_server.uri().parse().unwrap()).unwrap();
+
+        // First call should hit the network
+        let result1 = client.supported().await.unwrap();
+        assert_eq!(result1.kinds.len(), 1);
+
+        // Second call should use cache (same mock call count)
+        let result2 = client.supported().await.unwrap();
+        assert_eq!(result2.kinds.len(), 1);
+
+        // Both results should be equal
+        assert_eq!(result1.kinds[0].scheme, result2.kinds[0].scheme);
+    }
+
+    #[tokio::test]
+    async fn test_supported_cache_with_custom_ttl() {
+        let mock_server = MockServer::start().await;
+        let test_response = create_test_supported_response();
+
+        // Mock the supported endpoint
+        Mock::given(method("GET"))
+            .and(path("/supported"))
+            .respond_with(ResponseTemplate::new(200).set_body_json(&test_response))
+            .mount(&mock_server)
+            .await;
+
+        // Create client with 1ms TTL (essentially no caching)
+        let client = FacilitatorClient::try_new(mock_server.uri().parse().unwrap())
+            .unwrap()
+            .with_supported_cache_ttl(Duration::from_millis(1));
+
+        // First call
+        let result1 = client.supported().await.unwrap();
+        assert_eq!(result1.kinds.len(), 1);
+
+        // Wait for cache to expire
+        tokio::time::sleep(Duration::from_millis(10)).await;
+
+        // Second call should hit the network again due to expired cache
+        let result2 = client.supported().await.unwrap();
+        assert_eq!(result2.kinds.len(), 1);
+    }
+
+    #[tokio::test]
+    async fn test_supported_cache_disabled() {
+        let mock_server = MockServer::start().await;
+        let test_response = create_test_supported_response();
+
+        // Mock the supported endpoint
+        Mock::given(method("GET"))
+            .and(path("/supported"))
+            .respond_with(ResponseTemplate::new(200).set_body_json(&test_response))
+            .mount(&mock_server)
+            .await;
+
+        // Create client with caching disabled
+        let client = FacilitatorClient::try_new(mock_server.uri().parse().unwrap())
+            .unwrap()
+            .without_supported_cache();
+
+        // Each call should hit the network
+        let result1 = client.supported().await.unwrap();
+        let result2 = client.supported().await.unwrap();
+
+        assert_eq!(result1.kinds.len(), 1);
+        assert_eq!(result2.kinds.len(), 1);
+    }
+
+    #[tokio::test]
+    async fn test_supported_cache_clones_independently() {
+        let mock_server = MockServer::start().await;
+        let test_response = create_test_supported_response();
+
+        // Mock the supported endpoint
+        Mock::given(method("GET"))
+            .and(path("/supported"))
+            .respond_with(ResponseTemplate::new(200).set_body_json(&test_response))
+            .mount(&mock_server)
+            .await;
+
+        let client = FacilitatorClient::try_new(mock_server.uri().parse().unwrap()).unwrap();
+
+        // Clone the client
+        let client2 = client.clone();
+
+        // Populate cache on first client
+        let _ = client.supported().await.unwrap();
+
+        // Clone should have independent cache (will make its own request)
+        // Note: Since both clones point to same server, the mock will count 2 requests
+        let _ = client2.supported().await.unwrap();
+    }
+
+    #[tokio::test]
+    async fn test_supported_inner_bypasses_cache() {
+        let mock_server = MockServer::start().await;
+        let test_response = create_test_supported_response();
+
+        // Mock the supported endpoint
+        Mock::given(method("GET"))
+            .and(path("/supported"))
+            .respond_with(ResponseTemplate::new(200).set_body_json(&test_response))
+            .mount(&mock_server)
+            .await;
+
+        let client = FacilitatorClient::try_new(mock_server.uri().parse().unwrap()).unwrap();
+
+        // Populate cache
+        let _ = client.supported().await.unwrap();
+
+        // supported_inner() should always make HTTP request, bypassing cache
+        let result = client.supported_inner().await.unwrap();
+        assert_eq!(result.kinds.len(), 1);
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-axum/src/layer.rs b/bbt-x402-facilitator/crates/x402-axum/src/layer.rs
new file mode 100644
index 0000000..83959ca
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/src/layer.rs
@@ -0,0 +1,401 @@
+//! Axum middleware for enforcing [x402](https://www.x402.org) payments on protected routes.
+//!
+//! This middleware validates incoming payment headers using a configured x402 facilitator,
+//! and settles valid payments either before or after request execution (configurable).
+//!
+//! Returns a `402 Payment Required` response if the request lacks a valid payment.
+//!
+//! ## Example Usage
+//!
+//! ```rust
+//! use alloy_primitives::address;
+//! use axum::{Router, routing::get};
+//! use axum::response::IntoResponse;
+//! use http::StatusCode;
+//! use x402_axum::X402Middleware;
+//! use x402_chain_eip155::{KnownNetworkEip155, V1Eip155Exact};
+//! use x402_types::networks::USDC;
+//!
+//! let x402 = X402Middleware::new("https://facilitator.x402.rs");
+//!
+//! let app: Router = Router::new().route(
+//!     "/protected",
+//!     get(my_handler).layer(
+//!         x402.with_price_tag(V1Eip155Exact::price_tag(
+//!             address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
+//!             USDC::base_sepolia().parse("0.01").unwrap(),
+//!         ))
+//!     ),
+//! );
+//!
+//! async fn my_handler() -> impl IntoResponse {
+//!     (StatusCode::OK, "This is VIP content!")
+//! }
+//! ```
+//!
+//! ## Settlement Timing
+//!
+//! By default, settlement occurs **after** the request is processed. You can change this behavior:
+//!
+//! - **[`X402Middleware::settle_before_execution`]** - Settle payment **before** request execution.
+//! - **[`X402Middleware::settle_after_execution`]** - Settle payment **after** request execution (default).
+//!   This allows processing the request before committing the payment on-chain.
+//!
+//! ## Configuration Notes
+//!
+//! - **[`X402Middleware::with_price_tag`]** sets the assets and amounts accepted for payment (static pricing).
+//! - **[`X402Middleware::with_dynamic_price`]** sets a callback for dynamic pricing based on request context.
+//! - **[`X402Middleware::with_base_url`]** sets the base URL for computing full resource URLs.
+//!   If not set, defaults to `http://localhost/` (avoid in production).
+//! - **[`X402LayerBuilder::with_description`]** is optional but helps the payer understand what is being paid for.
+//! - **[`X402LayerBuilder::with_mime_type`]** sets the MIME type of the protected resource (default: `application/json`).
+//! - **[`X402LayerBuilder::with_resource`]** explicitly sets the full URI of the protected resource.
+//!
+
+use axum_core::extract::Request;
+use axum_core::response::Response;
+use http::{HeaderMap, Uri};
+use std::convert::Infallible;
+use std::future::Future;
+use std::pin::Pin;
+use std::sync::Arc;
+use std::task::{Context, Poll};
+use std::time::Duration;
+use tower::util::BoxCloneSyncService;
+use tower::{Layer, Service};
+use url::Url;
+use x402_types::facilitator::Facilitator;
+
+use crate::facilitator_client::FacilitatorClient;
+use crate::paygate::{
+    DynamicPriceTags, Paygate, PaygateProtocol, PriceTagSource, ResourceInfoBuilder,
+    StaticPriceTags,
+};
+
+/// The main X402 middleware instance for enforcing x402 payments on routes.
+///
+/// Create a single instance per application and use it to build payment layers
+/// for protected routes.
+#[derive(Clone, Debug)]
+pub struct X402Middleware<F> {
+    facilitator: F,
+    base_url: Option<Url>,
+    settle_before_execution: bool,
+}
+
+impl<F> X402Middleware<F> {
+    pub fn facilitator(&self) -> &F {
+        &self.facilitator
+    }
+}
+
+impl X402Middleware<Arc<FacilitatorClient>> {
+    /// Creates a new middleware instance with a default facilitator URL.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the facilitator URL is invalid.
+    pub fn new(url: &str) -> Self {
+        let facilitator = FacilitatorClient::try_from(url).expect("Invalid facilitator URL");
+        Self {
+            facilitator: Arc::new(facilitator),
+            base_url: None,
+            settle_before_execution: false,
+        }
+    }
+
+    /// Creates a new middleware instance with a facilitator URL.
+    pub fn try_new(url: &str) -> Result<Self, Box<dyn std::error::Error>> {
+        let facilitator = FacilitatorClient::try_from(url)?;
+        Ok(Self {
+            facilitator: Arc::new(facilitator),
+            base_url: None,
+            settle_before_execution: false,
+        })
+    }
+
+    /// Returns the configured facilitator URL.
+    pub fn facilitator_url(&self) -> &Url {
+        self.facilitator.base_url()
+    }
+
+    /// Sets the TTL for caching the facilitator's supported response.
+    ///
+    /// Default is 10 minutes. Use [`FacilitatorClient::without_supported_cache()`]
+    /// to disable caching entirely.
+    pub fn with_supported_cache_ttl(&self, ttl: Duration) -> Self {
+        let facilitator = Arc::new(self.facilitator.with_supported_cache_ttl(ttl));
+        Self {
+            facilitator,
+            base_url: self.base_url.clone(),
+            settle_before_execution: self.settle_before_execution,
+        }
+    }
+}
+
+impl TryFrom<&str> for X402Middleware<Arc<FacilitatorClient>> {
+    type Error = Box<dyn std::error::Error>;
+
+    fn try_from(value: &str) -> Result<Self, Self::Error> {
+        Self::try_new(value)
+    }
+}
+
+impl TryFrom<String> for X402Middleware<Arc<FacilitatorClient>> {
+    type Error = Box<dyn std::error::Error>;
+
+    fn try_from(value: String) -> Result<Self, Self::Error> {
+        Self::try_new(&value)
+    }
+}
+
+impl<F> X402Middleware<F>
+where
+    F: Clone,
+{
+    /// Sets the base URL used to construct resource URLs dynamically.
+    ///
+    /// If [`X402LayerBuilder::with_resource`] is not called, this base URL is combined with
+    /// each request's path/query to compute the resource. If not set, defaults to `http://localhost/`.
+    ///
+    /// In production, prefer calling `with_resource` or setting a precise `base_url`.
+    pub fn with_base_url(&self, base_url: Url) -> X402Middleware<F> {
+        let mut this = self.clone();
+        this.base_url = Some(base_url);
+        this
+    }
+
+    /// Enables settlement prior to request execution.
+    /// When disabled (default), settlement occurs after successful request execution.
+    pub fn settle_before_execution(&self) -> X402Middleware<F> {
+        let mut this = self.clone();
+        this.settle_before_execution = true;
+        this
+    }
+
+    /// Disables settlement prior to request execution (default behavior).
+    ///
+    /// When disabled, settlement occurs after successful request execution.
+    /// This is the default behavior and allows the application to process
+    /// the request before committing the payment on-chain.
+    pub fn settle_after_execution(&self) -> Self {
+        let mut this = self.clone();
+        this.settle_before_execution = false;
+        this
+    }
+}
+
+impl<TFacilitator> X402Middleware<TFacilitator>
+where
+    TFacilitator: Clone,
+{
+    /// Sets the price tag for the protected route.
+    ///
+    /// Creates a layer builder that can be further configured with additional
+    /// price tags and resource information.
+    pub fn with_price_tag<TPriceTag>(
+        &self,
+        price_tag: TPriceTag,
+    ) -> X402LayerBuilder<StaticPriceTags<TPriceTag>, TFacilitator> {
+        X402LayerBuilder {
+            facilitator: self.facilitator.clone(),
+            price_source: StaticPriceTags::new(vec![price_tag]),
+            base_url: self.base_url.clone().map(Arc::new),
+            resource: Arc::new(ResourceInfoBuilder::default()),
+            settle_before_execution: self.settle_before_execution,
+        }
+    }
+
+    /// Sets a dynamic price source for the protected route.
+    ///
+    /// The `callback` receives request headers, URI, and base URL, and returns
+    /// a vector of price tags.
+    ///
+    /// # Example
+    ///
+    /// ```rust,ignore
+    /// use alloy_primitives::address;
+    /// use x402_chain_eip155::V1Eip155Exact;
+    /// use x402_types::networks::USDC;
+    ///
+    /// x402.with_dynamic_price(|headers, uri, _base_url| async move {
+    ///     let is_premium = headers
+    ///         .get("X-User-Tier")
+    ///         .and_then(|v| v.to_str().ok())
+    ///         .map(|v| v == "premium")
+    ///         .unwrap_or(false);
+    ///
+    ///     let amount = if is_premium { "0.005" } else { "0.01" };
+    ///     vec![V1Eip155Exact::price_tag(
+    ///         address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
+    ///         USDC::base_sepolia().parse(amount).unwrap()
+    ///     )]
+    /// })
+    /// ```
+    pub fn with_dynamic_price<F, Fut, TPriceTag>(
+        &self,
+        callback: F,
+    ) -> X402LayerBuilder<DynamicPriceTags<TPriceTag>, TFacilitator>
+    where
+        F: Fn(&HeaderMap, &Uri, Option<&Url>) -> Fut + Send + Sync + 'static,
+        Fut: Future<Output = Vec<TPriceTag>> + Send + 'static,
+    {
+        X402LayerBuilder {
+            facilitator: self.facilitator.clone(),
+            price_source: DynamicPriceTags::new(callback),
+            base_url: self.base_url.clone().map(Arc::new),
+            resource: Arc::new(ResourceInfoBuilder::default()),
+            settle_before_execution: self.settle_before_execution,
+        }
+    }
+}
+
+/// Builder for configuring the X402 middleware layer.
+///
+/// Generic over `TSource` which implements [`PriceTagSource`] to support
+/// both static and dynamic pricing strategies.
+#[derive(Clone)]
+pub struct X402LayerBuilder<TSource, TFacilitator> {
+    facilitator: TFacilitator,
+    settle_before_execution: bool,
+    base_url: Option<Arc<Url>>,
+    price_source: TSource,
+    resource: Arc<ResourceInfoBuilder>,
+}
+
+impl<TPriceTag, TFacilitator> X402LayerBuilder<StaticPriceTags<TPriceTag>, TFacilitator>
+where
+    TPriceTag: Clone,
+{
+    /// Adds another payment option.
+    ///
+    /// Allows specifying multiple accepted payment methods (e.g., different networks).
+    ///
+    /// Note: This method is only available for static price tag sources.
+    pub fn with_price_tag(mut self, price_tag: TPriceTag) -> Self {
+        self.price_source = self.price_source.with_price_tag(price_tag);
+        self
+    }
+}
+
+impl<TSource, TFacilitator> X402LayerBuilder<TSource, TFacilitator> {
+    /// Sets a description of what the payment grants access to.
+    ///
+    /// This is included in 402 responses to inform clients what they're paying for.
+    pub fn with_description(mut self, description: String) -> Self {
+        let mut new_resource = (*self.resource).clone();
+        new_resource.description = description;
+        self.resource = Arc::new(new_resource);
+        self
+    }
+
+    /// Sets the MIME type of the protected resource.
+    ///
+    /// Defaults to `application/json` if not specified.
+    pub fn with_mime_type(mut self, mime: String) -> Self {
+        let mut new_resource = (*self.resource).clone();
+        new_resource.mime_type = mime;
+        self.resource = Arc::new(new_resource);
+        self
+    }
+
+    /// Sets the full URL of the protected resource.
+    ///
+    /// When set, this URL is used directly instead of constructing it from the base URL
+    /// and request URI. This is the preferred approach in production.
+    pub fn with_resource(mut self, resource: Url) -> Self {
+        let mut new_resource = (*self.resource).clone();
+        new_resource.url = Some(resource.to_string());
+        self.resource = Arc::new(new_resource);
+        self
+    }
+}
+
+impl<S, TSource, TFacilitator> Layer<S> for X402LayerBuilder<TSource, TFacilitator>
+where
+    S: Service<Request, Response = Response, Error = Infallible> + Clone + Send + Sync + 'static,
+    S::Future: Send + 'static,
+    TFacilitator: Facilitator + Clone,
+    TSource: PriceTagSource + Clone,
+{
+    type Service = X402MiddlewareService<TSource, TFacilitator>;
+
+    fn layer(&self, inner: S) -> Self::Service {
+        X402MiddlewareService {
+            facilitator: self.facilitator.clone(),
+            settle_before_execution: self.settle_before_execution,
+            base_url: self.base_url.clone(),
+            price_source: self.price_source.clone(),
+            resource: self.resource.clone(),
+            inner: BoxCloneSyncService::new(inner),
+        }
+    }
+}
+
+/// Axum service that enforces x402 payments on incoming requests.
+///
+/// Generic over `TSource` which implements [`PriceTagSource`] to support
+/// both static and dynamic pricing strategies.
+#[derive(Clone)]
+pub struct X402MiddlewareService<TSource, TFacilitator> {
+    /// Payment facilitator (local or remote)
+    facilitator: TFacilitator,
+    /// Base URL for constructing resource URLs
+    base_url: Option<Arc<Url>>,
+    /// Whether to settle payment before executing the request (true) or after (false)
+    settle_before_execution: bool,
+    /// Price tag source - can be static or dynamic
+    price_source: TSource,
+    /// Resource information
+    resource: Arc<ResourceInfoBuilder>,
+    /// The inner Axum service being wrapped
+    inner: BoxCloneSyncService<Request, Response, Infallible>,
+}
+
+impl<TSource, TFacilitator> Service<Request> for X402MiddlewareService<TSource, TFacilitator>
+where
+    TSource: PriceTagSource + Clone + Send + 'static,
+    TSource::PriceTag: PaygateProtocol,
+    TFacilitator: Facilitator + Clone + Send + Sync + 'static,
+{
+    type Response = Response;
+    type Error = Infallible;
+    type Future = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send>>;
+
+    /// Delegates readiness polling to the wrapped inner service.
+    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
+        self.inner.poll_ready(cx)
+    }
+
+    /// Intercepts the request, injects payment enforcement logic, and forwards to the wrapped service.
+    fn call(&mut self, req: Request) -> Self::Future {
+        let price_source = self.price_source.clone();
+        let facilitator = self.facilitator.clone();
+        let base_url = self.base_url.clone();
+        let resource_builder = self.resource.clone();
+        let settle_before_execution = self.settle_before_execution;
+        let mut inner = self.inner.clone();
+
+        Box::pin(async move {
+            // Resolve price tags from the source
+            let accepts = price_source
+                .resolve(req.headers(), req.uri(), base_url.as_deref())
+                .await;
+
+            // If no price tags are configured, bypass payment enforcement
+            if accepts.is_empty() {
+                return inner.call(req).await;
+            }
+
+            let resource = resource_builder.as_resource_info(base_url.as_deref(), &req);
+
+            let gate = Paygate {
+                facilitator,
+                settle_before_execution,
+                accepts: Arc::new(accepts),
+                resource,
+            };
+            gate.handle_request(inner, req).await
+        })
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-axum/src/lib.rs b/bbt-x402-facilitator/crates/x402-axum/src/lib.rs
new file mode 100644
index 0000000..68fa338
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/src/lib.rs
@@ -0,0 +1,112 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Axum middleware for enforcing [x402](https://www.x402.org) payments on protected routes.
+//!
+//! This middleware validates incoming payment headers using a configured x402 facilitator,
+//! and settles valid payments either before or after request execution (configurable).
+//!
+//! Returns a `402 Payment Required` response if the request lacks a valid payment.
+//!
+//! ## Example Usage
+//!
+//! ```rust
+//! use alloy_primitives::address;
+//! use axum::{Router, routing::get};
+//! use axum::response::IntoResponse;
+//! use http::StatusCode;
+//! use x402_axum::X402Middleware;
+//! use x402_chain_eip155::{KnownNetworkEip155, V1Eip155Exact};
+//! use x402_types::networks::USDC;
+//!
+//! let x402 = X402Middleware::new("https://facilitator.x402.rs");
+//!
+//! let app: Router = Router::new().route(
+//!     "/protected",
+//!     get(my_handler).layer(
+//!         x402.with_price_tag(V1Eip155Exact::price_tag(
+//!             address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
+//!             USDC::base_sepolia().parse("0.01").unwrap(),
+//!         ))
+//!     ),
+//! );
+//!
+//! async fn my_handler() -> impl IntoResponse {
+//!     (StatusCode::OK, "This is VIP content!")
+//! }
+//! ```
+//!
+//! See [`X402Middleware`] for full configuration options.
+//! For low-level interaction with the facilitator, see [`facilitator_client::FacilitatorClient`].
+//!
+//! ## Protocol Support
+//!
+//! Supports both V1 and V2 x402 protocols through the [`PaygateProtocol`] trait.
+//! The protocol version is determined by the price tag type used.
+//!
+//! ## Dynamic Pricing
+//!
+//! For dynamic pricing based on request context, use [`X402Middleware::with_dynamic_price`]:
+//!
+//! ```rust
+//! use axum::Router;
+//! use axum::routing::get;
+//! use axum::response::IntoResponse;
+//! use axum::http::StatusCode;
+//! use alloy_primitives::address;
+//! use x402_axum::X402Middleware;
+//! use x402_chain_eip155::KnownNetworkEip155;
+//! use x402_chain_eip155::V1Eip155Exact;
+//! use x402_types::networks::USDC;
+//!
+//! let x402 = X402Middleware::new("https://facilitator.x402.rs");
+//!
+//! let app: Router = Router::new().route(
+//!     "/protected",
+//!     get(my_handler).layer(
+//!         x402.with_dynamic_price(|headers, uri, base_url| {
+//!             // Compute price based on request context
+//!             let is_premium = headers
+//!                 .get("X-User-Tier")
+//!                 .and_then(|v| v.to_str().ok())
+//!                 .map(|v| v == "premium")
+//!                 .unwrap_or(false);
+//!
+//!             let amount = if is_premium { "0.005" } else { "0.01" };
+//!             async move {
+//!                 vec![V1Eip155Exact::price_tag(address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"), USDC::base_sepolia().parse(amount).unwrap())]
+//!             }
+//!         })
+//!     ),
+//! );
+//!
+//! async fn my_handler() -> impl IntoResponse {
+//!     (StatusCode::OK, "This is a VIP content!")
+//! }
+//! ```
+//!
+//! ## Settlement Timing
+//!
+//! By default, settlement occurs **after** the request is processed. You can change this behavior:
+//!
+//! - **[`X402Middleware::settle_before_execution`]** - Settle payment **before** request execution.
+//!   This prevents issues where failed settlements need retry or authorization expires.
+//! - **[`X402Middleware::settle_after_execution`]** - Settle payment **after** request execution (default).
+//!   This allows processing the request before committing the payment on-chain.
+//!
+//! ## Configuration Notes
+//!
+//! - **[`X402Middleware::with_price_tag`]** sets the assets and amounts accepted for payment (static pricing).
+//! - **[`X402Middleware::with_dynamic_price`]** sets a callback for dynamic pricing based on request context.
+//! - **[`X402Middleware::with_base_url`]** sets the base URL for computing full resource URLs.
+//!   If not set, defaults to `http://localhost/` (avoid in production).
+//! - **[`X402Middleware::with_supported_cache_ttl`]** configures the TTL for caching facilitator capabilities.
+//! - **[`X402LayerBuilder::with_description`]** is optional but helps the payer understand what is being paid for.
+//! - **[`X402LayerBuilder::with_mime_type`]** sets the MIME type of the protected resource (default: `application/json`).
+//! - **[`X402LayerBuilder::with_resource`]** explicitly sets the full URI of the protected resource.
+
+pub mod facilitator_client;
+pub mod layer;
+pub mod paygate;
+
+pub use layer::{X402LayerBuilder, X402Middleware};
+pub use paygate::{DynamicPriceTags, PaygateProtocol, PriceTagSource, StaticPriceTags};
diff --git a/bbt-x402-facilitator/crates/x402-axum/src/paygate.rs b/bbt-x402-facilitator/crates/x402-axum/src/paygate.rs
new file mode 100644
index 0000000..b020f00
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-axum/src/paygate.rs
@@ -0,0 +1,843 @@
+//! Unified Paygate implementation supporting both V1 and V2 x402 protocols.
+//!
+//! This module provides a trait-based abstraction that allows sharing the core
+//! payment gate logic between protocol versions while allowing version-specific
+//! behavior through the [`PaygateProtocol`] trait.
+//!
+//! ## Overview
+//!
+//! The paygate handles:
+//! - Extracting payment headers from requests
+//! - Verifying payments with the facilitator
+//! - Settling payments on-chain
+//! - Returning appropriate 402 responses when payment is required
+//!
+//! ## Example
+//!
+//! ```ignore
+//! use x402_axum::paygate::{Paygate, PaygateProtocol};
+//!
+//! // Create a paygate for V1 or V2 protocol
+//! let paygate = Paygate {
+//!     facilitator,
+//!     settle_before_execution: false,
+//!     accepts: Arc::new(price_tags),
+//!     resource: ResourceInfoBuilder::default().as_resource_info(&base_url, &uri),
+//! };
+//!
+//! // Handle a request
+//! let response = paygate.handle_request(inner, request).await;
+//! ```
+
+use axum_core::body::Body;
+use axum_core::extract::Request;
+use axum_core::response::{IntoResponse, Response};
+use http::{HeaderMap, HeaderValue, StatusCode, Uri};
+use serde_json::json;
+use std::convert::Infallible;
+use std::future::Future;
+use std::pin::Pin;
+use std::sync::Arc;
+use tower::Service;
+use url::Url;
+use x402_types::facilitator::Facilitator;
+use x402_types::proto;
+use x402_types::proto::{SupportedResponse, v1, v2};
+
+#[cfg(feature = "telemetry")]
+use tracing::Instrument;
+#[cfg(feature = "telemetry")]
+use tracing::instrument;
+use x402_types::util::Base64Bytes;
+
+// ============================================================================
+// Common Types
+// ============================================================================
+
+/// Builder for resource information that can be used with both V1 and V2 protocols.
+#[derive(Debug, Clone)]
+pub struct ResourceInfoBuilder {
+    /// Description of the protected resource
+    pub description: String,
+    /// MIME type of the protected resource
+    pub mime_type: String,
+    /// Optional explicit URL of the protected resource
+    pub url: Option<String>,
+}
+
+impl Default for ResourceInfoBuilder {
+    fn default() -> Self {
+        Self {
+            description: "".to_string(),
+            mime_type: "application/json".to_string(),
+            url: None,
+        }
+    }
+}
+
+impl ResourceInfoBuilder {
+    /// Determines the resource URL (static or dynamic).
+    ///
+    /// If `url` is set, returns it directly. Otherwise, constructs a URL by combining
+    /// the base URL with the request URI's path and query.
+    pub fn as_resource_info(&self, base_url: Option<&Url>, req: &Request) -> v2::ResourceInfo {
+        let url = self.url.clone().unwrap_or_else(|| {
+            let mut url = base_url.cloned().unwrap_or_else(|| {
+                let host = req.headers().get("host").and_then(|h| h.to_str().ok()).unwrap_or("localhost");
+                let origin = format!("http://{}", host);
+                let url = Url::parse(&origin).unwrap_or_else(|_| Url::parse("http://localhost").unwrap());
+                #[cfg(feature = "telemetry")]
+                tracing::warn!(
+                    "X402Middleware base_url is not configured; using {url} as origin for resource resolution"
+                );
+                url
+            });
+            let request_uri = req.uri();
+            url.set_path(request_uri.path());
+            url.set_query(request_uri.query());
+            url.to_string()
+        });
+        v2::ResourceInfo {
+            description: self.description.clone(),
+            mime_type: self.mime_type.clone(),
+            url,
+        }
+    }
+}
+
+// ============================================================================
+// Error Types
+// ============================================================================
+
+/// Common verification errors shared between protocol versions.
+#[derive(Debug, thiserror::Error)]
+pub enum VerificationError {
+    #[error("{0} header is required")]
+    PaymentHeaderRequired(&'static str),
+    #[error("Invalid or malformed payment header")]
+    InvalidPaymentHeader,
+    #[error("Unable to find matching payment requirements")]
+    NoPaymentMatching,
+    #[error("Verification failed: {0}")]
+    VerificationFailed(String),
+}
+
+/// Paygate error type that wraps verification and settlement errors.
+#[derive(Debug, thiserror::Error)]
+pub enum PaygateError {
+    #[error(transparent)]
+    Verification(#[from] VerificationError),
+    #[error("Settlement failed: {0}")]
+    Settlement(String),
+}
+
+// ============================================================================
+// PaygateProtocol Trait
+// ============================================================================
+
+/// Trait defining version-specific behavior for the x402 payment gate.
+///
+/// This trait is implemented directly on the price tag types (`V1PriceTag` and
+/// `V2PriceTag`/`v2::PaymentRequirements`), allowing the core payment gate logic
+/// to be shared while version-specific behavior is implemented separately.
+pub trait PaygateProtocol: Clone + Send + Sync + 'static {
+    /// The payment payload type extracted from the request header.
+    type PaymentPayload: serde::de::DeserializeOwned + Send;
+
+    /// The HTTP header name for the payment payload.
+    const PAYMENT_HEADER_NAME: &'static str;
+
+    /// Constructs a verify request from the payment payload and accepted requirements.
+    ///
+    /// The `resource` parameter provides resource information that may be needed
+    /// for protocol-specific requirements (e.g., V1 includes resource info in PaymentRequirements).
+    fn make_verify_request(
+        payload: Self::PaymentPayload,
+        accepts: &[Self],
+        resource: &v2::ResourceInfo,
+    ) -> Result<proto::VerifyRequest, VerificationError>;
+
+    /// Converts an error into an HTTP response with appropriate format.
+    fn error_into_response(
+        err: PaygateError,
+        accepts: &[Self],
+        resource: &v2::ResourceInfo,
+    ) -> Response;
+
+    /// Converts the verify response to the protocol-specific format and validates it.
+    fn validate_verify_response(
+        verify_response: proto::VerifyResponse,
+    ) -> Result<(), VerificationError>;
+
+    /// Enriches a price tag with facilitator capabilities.
+    ///
+    /// Called by middleware when building 402 response to add extra information like fee payer
+    /// from the facilitator's supported endpoints.
+    fn enrich_with_capabilities(&mut self, capabilities: &SupportedResponse);
+}
+
+// ============================================================================
+// V1 Protocol Implementation (on v1::PriceTag)
+// ============================================================================
+
+impl PaygateProtocol for v1::PriceTag {
+    type PaymentPayload = v1::PaymentPayload;
+
+    const PAYMENT_HEADER_NAME: &'static str = "X-PAYMENT";
+
+    fn make_verify_request(
+        payment_payload: Self::PaymentPayload,
+        accepts: &[Self],
+        resource: &v2::ResourceInfo,
+    ) -> Result<proto::VerifyRequest, VerificationError> {
+        let selected = accepts
+            .iter()
+            .find(|requirement| {
+                requirement.scheme == payment_payload.scheme
+                    && requirement.network == payment_payload.network
+            })
+            .ok_or(VerificationError::NoPaymentMatching)?;
+
+        let verify_request = v1::VerifyRequest {
+            x402_version: v1::X402Version1,
+            payment_payload,
+            payment_requirements: price_tag_to_v1_requirements_with_resource(selected, resource),
+        };
+
+        verify_request
+            .try_into()
+            .map_err(|e| VerificationError::VerificationFailed(format!("{e}")))
+    }
+
+    fn error_into_response(
+        err: PaygateError,
+        accepts: &[Self],
+        resource: &v2::ResourceInfo,
+    ) -> Response {
+        match err {
+            PaygateError::Verification(err) => {
+                let payment_required_response = v1::PaymentRequired {
+                    error: Some(err.to_string()),
+                    accepts: accepts
+                        .iter()
+                        .map(|pt| price_tag_to_v1_requirements_with_resource(pt, resource))
+                        .collect(),
+                    x402_version: v1::X402Version1,
+                };
+                let payment_required_response_bytes =
+                    serde_json::to_vec(&payment_required_response).expect("serialization failed");
+                let body = Body::from(payment_required_response_bytes);
+                Response::builder()
+                    .status(StatusCode::PAYMENT_REQUIRED)
+                    .header("Content-Type", "application/json")
+                    .body(body)
+                    .expect("Fail to construct response")
+            }
+            PaygateError::Settlement(err) => {
+                let body = Body::from(
+                    json!({
+                        "error": "Settlement failed",
+                        "details": err.to_string()
+                    })
+                    .to_string(),
+                );
+                Response::builder()
+                    .status(StatusCode::PAYMENT_REQUIRED)
+                    .header("Content-Type", "application/json")
+                    .body(body)
+                    .expect("Fail to construct response")
+            }
+        }
+    }
+
+    fn validate_verify_response(
+        verify_response: proto::VerifyResponse,
+    ) -> Result<(), VerificationError> {
+        let verify_response_v1: v1::VerifyResponse = verify_response
+            .try_into()
+            .map_err(|e| VerificationError::VerificationFailed(format!("{e}")))?;
+
+        match verify_response_v1 {
+            v1::VerifyResponse::Valid { .. } => Ok(()),
+            v1::VerifyResponse::Invalid { reason, .. } => {
+                Err(VerificationError::VerificationFailed(reason))
+            }
+        }
+    }
+
+    fn enrich_with_capabilities(&mut self, capabilities: &SupportedResponse) {
+        self.enrich(capabilities);
+    }
+}
+
+/// Helper function to convert V1PriceTag to v1::PaymentRequirements with resource info.
+fn price_tag_to_v1_requirements_with_resource(
+    price_tag: &v1::PriceTag,
+    resource: &v2::ResourceInfo,
+) -> v1::PaymentRequirements {
+    v1::PaymentRequirements {
+        scheme: price_tag.scheme.clone(),
+        network: price_tag.network.clone(),
+        max_amount_required: price_tag.amount.clone(),
+        resource: resource.url.clone(),
+        description: resource.description.clone(),
+        mime_type: resource.mime_type.clone(),
+        output_schema: None,
+        pay_to: price_tag.pay_to.clone(),
+        max_timeout_seconds: price_tag.max_timeout_seconds,
+        asset: price_tag.asset.clone(),
+        extra: price_tag.extra.clone(),
+    }
+}
+
+// ============================================================================
+// V2 Protocol Implementation (on v2::PaymentRequirements / V2PriceTag)
+// ============================================================================
+
+impl PaygateProtocol for v2::PriceTag {
+    type PaymentPayload = v2::PaymentPayload<v2::PaymentRequirements, serde_json::Value>;
+
+    const PAYMENT_HEADER_NAME: &'static str = "Payment-Signature";
+
+    fn make_verify_request(
+        payment_payload: Self::PaymentPayload,
+        accepts: &[Self],
+        _resource: &v2::ResourceInfo,
+    ) -> Result<proto::VerifyRequest, VerificationError> {
+        // In V2, the accepted requirements are embedded in the payload
+        // Resource info is already included in the payment payload from the client
+        let accepted = &payment_payload.accepted;
+
+        // Find matching requirements from our accepts list
+        // According to V2 spec, the accepted requirements must exactly match
+        // one of the requirements we offered in PaymentRequired.accepts
+        let selected = accepts
+            .iter()
+            .find(|price_tag| **price_tag == *accepted)
+            .ok_or(VerificationError::NoPaymentMatching)?;
+
+        // Build the V2 verify request
+        let verify_request = v2::VerifyRequest {
+            x402_version: v2::X402Version2,
+            payment_payload,
+            payment_requirements: selected.requirements.clone(),
+        };
+
+        let json = serde_json::to_value(&verify_request)
+            .map_err(|e| VerificationError::VerificationFailed(format!("{e}")))?;
+
+        Ok(proto::VerifyRequest::from(json))
+    }
+
+    fn error_into_response(
+        err: PaygateError,
+        accepts: &[Self],
+        resource: &v2::ResourceInfo,
+    ) -> Response {
+        match err {
+            PaygateError::Verification(err) => {
+                let payment_required_response = v2::PaymentRequired {
+                    error: Some(err.to_string()),
+                    accepts: accepts.iter().map(|pt| pt.requirements.clone()).collect(),
+                    x402_version: v2::X402Version2,
+                    resource: resource.clone(),
+                };
+                // V2 sends payment required in the "Payment-Required" header (base64 encoded)
+                let payment_required_bytes =
+                    serde_json::to_vec(&payment_required_response).expect("serialization failed");
+                let payment_required_header = Base64Bytes::encode(&payment_required_bytes);
+                let header_value = HeaderValue::from_bytes(payment_required_header.as_ref())
+                    .expect("Failed to create header value");
+
+                Response::builder()
+                    .status(StatusCode::PAYMENT_REQUIRED)
+                    .header("Payment-Required", header_value)
+                    .body(Body::empty())
+                    .expect("Fail to construct response")
+            }
+            PaygateError::Settlement(err) => {
+                let body = Body::from(
+                    json!({
+                        "error": "Settlement failed",
+                        "details": err.to_string()
+                    })
+                    .to_string(),
+                );
+                Response::builder()
+                    .status(StatusCode::PAYMENT_REQUIRED)
+                    .header("Content-Type", "application/json")
+                    .body(body)
+                    .expect("Fail to construct response")
+            }
+        }
+    }
+
+    fn validate_verify_response(
+        verify_response: proto::VerifyResponse,
+    ) -> Result<(), VerificationError> {
+        let verify_response_v2: v2::VerifyResponse = verify_response
+            .try_into()
+            .map_err(|e| VerificationError::VerificationFailed(format!("{e}")))?;
+
+        match verify_response_v2 {
+            v2::VerifyResponse::Valid { .. } => Ok(()),
+            v2::VerifyResponse::Invalid { reason, .. } => {
+                Err(VerificationError::VerificationFailed(reason))
+            }
+        }
+    }
+
+    fn enrich_with_capabilities(&mut self, capabilities: &SupportedResponse) {
+        self.enrich(capabilities);
+    }
+}
+
+// ============================================================================
+// Unified Paygate Implementation
+// ============================================================================
+
+/// Unified payment gate that works with both V1 and V2 protocols.
+///
+/// The protocol version is determined by the price tag type parameter `P`, which must
+/// implement [`PaygateProtocol`]. Use `V1PriceTag` for V1 protocol or `V2PriceTag`
+/// (alias for `v2::PaymentRequirements`) for V2 protocol.
+pub struct Paygate<TPriceTag, TFacilitator> {
+    /// The facilitator for verifying and settling payments
+    pub facilitator: TFacilitator,
+    /// Whether to settle before or after request execution
+    pub settle_before_execution: bool,
+    /// Accepted payment requirements
+    pub accepts: Arc<Vec<TPriceTag>>,
+    /// Resource information for the protected endpoint
+    pub resource: v2::ResourceInfo,
+}
+
+impl<TPriceTag, TFacilitator> Paygate<TPriceTag, TFacilitator> {
+    /// Calls the inner service with proper telemetry instrumentation.
+    async fn call_inner<
+        ReqBody,
+        ResBody,
+        S: Service<http::Request<ReqBody>, Response = http::Response<ResBody>>,
+    >(
+        mut inner: S,
+        req: http::Request<ReqBody>,
+    ) -> Result<http::Response<ResBody>, S::Error>
+    where
+        S::Future: Send,
+    {
+        #[cfg(feature = "telemetry")]
+        {
+            inner
+                .call(req)
+                .instrument(tracing::info_span!("inner"))
+                .await
+        }
+        #[cfg(not(feature = "telemetry"))]
+        {
+            inner.call(req).await
+        }
+    }
+}
+
+impl<TPriceTag, TFacilitator> Paygate<TPriceTag, TFacilitator>
+where
+    TPriceTag: PaygateProtocol,
+    TFacilitator: Facilitator,
+{
+    /// Handles an incoming request, processing payment if required.
+    ///
+    /// Returns 402 response if payment fails.
+    /// Otherwise, returns the response from the inner service.
+    #[cfg_attr(
+        feature = "telemetry",
+        instrument(name = "x402.handle_request", skip_all)
+    )]
+    pub async fn handle_request<
+        ReqBody,
+        ResBody,
+        S: Service<http::Request<ReqBody>, Response = http::Response<ResBody>>,
+    >(
+        self,
+        inner: S,
+        req: http::Request<ReqBody>,
+    ) -> Result<Response, Infallible>
+    where
+        S::Response: IntoResponse,
+        S::Error: IntoResponse,
+        S::Future: Send,
+    {
+        match self.handle_request_fallible(inner, req).await {
+            Ok(response) => Ok(response),
+            Err(err) => {
+                // Get enriched accepts for 402 response
+                let enriched_accepts = self.get_enriched_accepts().await;
+                Ok(TPriceTag::error_into_response(
+                    err,
+                    &enriched_accepts,
+                    &self.resource,
+                ))
+            }
+        }
+    }
+
+    /// Gets enriched price tags with facilitator capabilities.
+    async fn get_enriched_accepts(&self) -> Vec<TPriceTag> {
+        // Try to get capabilities, use empty if fails
+        let capabilities = self.facilitator.supported().await.unwrap_or_default();
+
+        self.accepts
+            .iter()
+            .map(|pt| {
+                let mut pt_clone = pt.clone();
+                pt_clone.enrich_with_capabilities(&capabilities);
+                pt_clone
+            })
+            .collect()
+    }
+
+    /// Handles an incoming request, returning errors as `PaygateError`.
+    ///
+    /// This is the fallible version of `handle_request` that returns an actual error
+    /// instead of turning it into 402 Payment Required response.
+    pub async fn handle_request_fallible<
+        ReqBody,
+        ResBody,
+        S: Service<http::Request<ReqBody>, Response = http::Response<ResBody>>,
+    >(
+        &self,
+        inner: S,
+        req: http::Request<ReqBody>,
+    ) -> Result<Response, PaygateError>
+    where
+        S::Response: IntoResponse,
+        S::Error: IntoResponse,
+        S::Future: Send,
+    {
+        // Extract payment payload from headers
+        let header = extract_payment_header(req.headers(), TPriceTag::PAYMENT_HEADER_NAME).ok_or(
+            VerificationError::PaymentHeaderRequired(TPriceTag::PAYMENT_HEADER_NAME),
+        )?;
+        let payment_payload = extract_payment_payload::<TPriceTag::PaymentPayload>(header)
+            .ok_or(VerificationError::InvalidPaymentHeader)?;
+
+        let verify_request =
+            TPriceTag::make_verify_request(payment_payload, &self.accepts, &self.resource)?;
+
+        if self.settle_before_execution {
+            // Settlement before execution: settle payment first, then call inner handler
+            #[cfg(feature = "telemetry")]
+            tracing::debug!("Settling payment before request execution");
+
+            let settlement = self.settle_payment(&verify_request).await?;
+
+            let header_value = settlement_to_header(settlement)?;
+
+            // Settlement succeeded, now execute the request
+            let response = match Self::call_inner(inner, req).await {
+                Ok(response) => response,
+                Err(err) => return Ok(err.into_response()),
+            };
+
+            // Add payment response header
+            let mut res = response;
+            res.headers_mut().insert("X-Payment-Response", header_value);
+            Ok(res.into_response())
+        } else {
+            // Settlement after execution (default): call inner handler first, then settle
+            #[cfg(feature = "telemetry")]
+            tracing::debug!("Settling payment after request execution");
+
+            let verify_response = self.verify_payment(&verify_request).await?;
+
+            TPriceTag::validate_verify_response(verify_response)?;
+
+            let response = match Self::call_inner(inner, req).await {
+                Ok(response) => response,
+                Err(err) => return Ok(err.into_response()),
+            };
+
+            if response.status().is_client_error() || response.status().is_server_error() {
+                return Ok(response.into_response());
+            }
+
+            let settlement = self.settle_payment(&verify_request).await?;
+
+            let header_value = settlement_to_header(settlement)?;
+
+            let mut res = response;
+            res.headers_mut().insert("X-Payment-Response", header_value);
+            Ok(res.into_response())
+        }
+    }
+
+    /// Verifies a payment with the facilitator.
+    pub async fn verify_payment(
+        &self,
+        verify_request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, VerificationError> {
+        let verify_response = self
+            .facilitator
+            .verify(verify_request)
+            .await
+            .map_err(|e| VerificationError::VerificationFailed(format!("{e}")))?;
+        Ok(verify_response)
+    }
+
+    /// Settles a payment with the facilitator.
+    pub async fn settle_payment(
+        &self,
+        settle_request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, PaygateError> {
+        let settle_response = self
+            .facilitator
+            .settle(settle_request)
+            .await
+            .map_err(|e| PaygateError::Settlement(format!("{e}")))?;
+        Ok(settle_response)
+    }
+}
+
+// ============================================================================
+// Helper Functions
+// ============================================================================
+
+/// Extracts the payment header value from the header map.
+fn extract_payment_header<'a>(header_map: &'a HeaderMap, header_name: &'a str) -> Option<&'a [u8]> {
+    header_map.get(header_name).map(|h| h.as_bytes())
+}
+
+/// Extracts and deserializes the payment payload from base64-encoded header bytes.
+fn extract_payment_payload<T>(header_bytes: &[u8]) -> Option<T>
+where
+    T: serde::de::DeserializeOwned,
+{
+    let base64 = Base64Bytes::from(header_bytes).decode().ok()?;
+    let value = serde_json::from_slice(base64.as_ref()).ok()?;
+    Some(value)
+}
+
+/// Converts a [`proto::SettleResponse`] into an HTTP header value.
+///
+/// Returns an error response if conversion fails.
+fn settlement_to_header(settlement: proto::SettleResponse) -> Result<HeaderValue, PaygateError> {
+    let json =
+        serde_json::to_vec(&settlement).map_err(|err| PaygateError::Settlement(err.to_string()))?;
+    let payment_header = Base64Bytes::encode(json);
+    HeaderValue::from_bytes(payment_header.as_ref())
+        .map_err(|err| PaygateError::Settlement(err.to_string()))
+}
+
+// ============================================================================
+// PriceTagSource Trait and Implementations
+// ============================================================================
+
+/// Trait for types that can provide price tags for a request.
+///
+/// This trait abstracts over static and dynamic pricing strategies.
+/// Implementations must be infallible - they always return price tags.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_axum::paygate::{PriceTagSource, StaticPriceTags, DynamicPriceTags};
+///
+/// // Static pricing - same price for every request
+/// let static_source = StaticPriceTags::new(vec![my_price_tag]);
+///
+/// // Dynamic pricing - compute price per-request
+/// let dynamic_source = DynamicPriceTags::new(|headers, uri, base_url| async move {
+///     vec![compute_price_tag(headers)]
+/// });
+/// ```
+pub trait PriceTagSource {
+    /// The concrete price tag type produced by this source.
+    type PriceTag: PaygateProtocol;
+
+    /// Resolves price tags for the given request context.
+    ///
+    /// This method is infallible - it must always return a non-empty vector of price tags.
+    fn resolve(
+        &self,
+        headers: &HeaderMap,
+        uri: &Uri,
+        base_url: Option<&Url>,
+    ) -> impl Future<Output = Vec<Self::PriceTag>> + Send;
+}
+
+// ============================================================================
+// StaticPriceTags Implementation
+// ============================================================================
+
+/// Static price tag source - returns the same price tags for every request.
+///
+/// This is the default implementation used when calling `with_price_tag()`.
+/// It simply stores a vector of price tags and returns clones on each request.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_axum::paygate::StaticPriceTags;
+///
+/// let source = StaticPriceTags::new(vec![V1Eip155Exact::price_tag(pay_to, amount)]);
+/// ```
+#[derive(Clone, Debug)]
+pub struct StaticPriceTags<TPriceTag> {
+    tags: Arc<Vec<TPriceTag>>,
+}
+
+impl<TPriceTag> StaticPriceTags<TPriceTag> {
+    /// Creates a new static price tag source from a vector of price tags.
+    pub fn new(tags: Vec<TPriceTag>) -> Self {
+        Self {
+            tags: Arc::new(tags),
+        }
+    }
+
+    /// Returns a reference to the stored price tags.
+    pub fn tags(&self) -> &[TPriceTag] {
+        &self.tags
+    }
+}
+
+impl<TPriceTag> StaticPriceTags<TPriceTag>
+where
+    TPriceTag: Clone,
+{
+    /// Adds a price tag to the source.
+    pub fn with_price_tag(mut self, tag: TPriceTag) -> Self {
+        let mut tags = (*self.tags).clone();
+        tags.push(tag);
+        self.tags = Arc::new(tags);
+        self
+    }
+}
+
+impl<TPriceTag> PriceTagSource for StaticPriceTags<TPriceTag>
+where
+    TPriceTag: PaygateProtocol,
+{
+    type PriceTag = TPriceTag;
+
+    async fn resolve(
+        &self,
+        _headers: &HeaderMap,
+        _uri: &Uri,
+        _base_url: Option<&Url>,
+    ) -> Vec<Self::PriceTag> {
+        // Simply clone the static tags
+        (*self.tags).clone()
+    }
+}
+
+// ============================================================================
+// DynamicPriceTags Implementation
+// ============================================================================
+
+/// Internal type alias for the boxed dynamic pricing callback.
+/// Users don't interact with this directly.
+///
+/// Uses higher-ranked trait bounds (HRTB) to express that the callback
+/// works with any lifetime of the input references.
+type BoxedDynamicPriceCallback<TPriceTag> = dyn for<'a> Fn(
+        &'a HeaderMap,
+        &'a Uri,
+        Option<&'a Url>,
+    ) -> Pin<Box<dyn Future<Output = Vec<TPriceTag>> + Send + 'a>>
+    + Send
+    + Sync;
+
+/// Dynamic price tag source - computes price tags per-request via callback.
+///
+/// This implementation allows computing different prices based on request
+/// headers, URI, or other runtime factors.
+///
+/// # Example
+///
+/// ```ignore
+/// use alloy_primitives::address;
+/// use x402_axum::paygate::DynamicPriceTags;
+/// use x402_chain_eip155::V1Eip155Exact;
+/// use x402_types::networks::USDC;
+///
+/// // Users write a simple async closure - no Box::pin needed!
+/// let source = DynamicPriceTags::new(|headers, uri, _base_url| async move {
+///     let is_premium = headers
+///         .get("X-User-Tier")
+///         .and_then(|v| v.to_str().ok())
+///         .map(|v| v == "premium")
+///         .unwrap_or(false);
+///
+///     let amount = if is_premium { "0.005" } else { "0.01" };
+///     vec![V1Eip155Exact::price_tag(
+///         address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
+///         USDC::base_sepolia().parse(amount).unwrap()
+///     )]
+/// });
+/// ```
+pub struct DynamicPriceTags<TPriceTag> {
+    callback: Arc<BoxedDynamicPriceCallback<TPriceTag>>,
+}
+
+impl<TPriceTag> Clone for DynamicPriceTags<TPriceTag> {
+    fn clone(&self) -> Self {
+        Self {
+            callback: self.callback.clone(),
+        }
+    }
+}
+
+impl<TPriceTag> std::fmt::Debug for DynamicPriceTags<TPriceTag> {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("DynamicPriceTags")
+            .field("callback", &"<callback>")
+            .finish()
+    }
+}
+
+impl<TPriceTag> DynamicPriceTags<TPriceTag> {
+    /// Creates a new dynamic price source from an async closure.
+    ///
+    /// The closure receives request context and returns a vector of price tags.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use alloy_primitives::address;
+    /// use x402_chain_eip155::V1Eip155Exact;
+    /// use x402_types::networks::USDC;
+    ///
+    /// DynamicPriceTags::new(|_headers, _uri, _base_url| async move {
+    ///     vec![V1Eip155Exact::price_tag(
+    ///         address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
+    ///         USDC::base_sepolia().parse("0.01").unwrap()
+    ///     )]
+    /// })
+    /// ```
+    pub fn new<F, Fut>(callback: F) -> Self
+    where
+        F: Fn(&HeaderMap, &Uri, Option<&Url>) -> Fut + Send + Sync + 'static,
+        Fut: Future<Output = Vec<TPriceTag>> + Send + 'static,
+    {
+        Self {
+            callback: Arc::new(move |headers, uri, base_url| {
+                Box::pin(callback(headers, uri, base_url))
+            }),
+        }
+    }
+}
+
+impl<TPriceTag> PriceTagSource for DynamicPriceTags<TPriceTag>
+where
+    TPriceTag: PaygateProtocol,
+{
+    type PriceTag = TPriceTag;
+
+    async fn resolve(
+        &self,
+        headers: &HeaderMap,
+        uri: &Uri,
+        base_url: Option<&Url>,
+    ) -> Vec<Self::PriceTag> {
+        (self.callback)(headers, uri, base_url).await
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/Cargo.toml b/bbt-x402-facilitator/crates/x402-facilitator-local/Cargo.toml
new file mode 100644
index 0000000..3e34794
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/Cargo.toml
@@ -0,0 +1,52 @@
+[package]
+name = "x402-facilitator-local"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+categories.workspace = true
+keywords.workspace = true
+description = "Local facilitator implementation for the x402 payment protocol"
+documentation = "https://docs.rs/x402-facilitator-local"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[features]
+default = []
+telemetry = [
+    "dep:tracing",
+    "dep:tracing-subscriber",
+    "dep:opentelemetry",
+    "dep:opentelemetry_sdk",
+    "dep:opentelemetry-semantic-conventions",
+    "dep:tracing-opentelemetry",
+    "dep:opentelemetry-otlp",
+    "dep:opentelemetry-stdout",
+    "x402-types/telemetry",
+]
+full = ["telemetry"]
+
+[dependencies]
+x402-types = { workspace = true }
+thiserror = { workspace = true }
+serde = { workspace = true }
+serde_json = { workspace = true }
+tokio = { workspace = true, features = ["signal"] }
+tokio-util = { workspace = true }
+axum = { workspace = true }
+tower-http = { workspace = true }
+
+# Tracing and OpenTelemetry (optional, enabled via `telemetry` feature)
+tracing = { workspace = true, optional = true }
+tracing-subscriber = { workspace = true, optional = true }
+opentelemetry = { version = "0.31", optional = true }
+opentelemetry_sdk = { version = "0.31", optional = true }
+opentelemetry-semantic-conventions = { version = "0.31", features = ["semconv_experimental"], optional = true }
+tracing-opentelemetry = { version = "0.32", optional = true }
+opentelemetry-otlp = { version = "0.31", features = ["metrics", "grpc-tonic"], optional = true }
+opentelemetry-stdout = { version = "0.31", features = ["trace", "metrics"], optional = true }
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/README.md b/bbt-x402-facilitator/crates/x402-facilitator-local/README.md
new file mode 100644
index 0000000..82b5f8b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/README.md
@@ -0,0 +1,248 @@
+# x402-facilitator-local
+
+[![Crates.io](https://img.shields.io/crates/v/x402-facilitator-local.svg)](https://crates.io/crates/x402-facilitator-local)
+[![Docs.rs](https://docs.rs/x402-facilitator-local/badge.svg)](https://docs.rs/x402-facilitator-local)
+
+Local facilitator implementation for the [x402](https://www.x402.org) payment protocol.
+
+This crate provides a self-hosted facilitator that validates x402 payment payloads and performs on-chain settlements using registered scheme handlers. It includes HTTP handlers for the x402 protocol endpoints and utilities for graceful shutdown and OpenTelemetry tracing.
+
+## Features
+
+- **Local Facilitator**: [`FacilitatorLocal`] implementation that delegates to scheme handlers
+- **HTTP Handlers**: Axum-based endpoints for `/verify`, `/settle`, `/supported`, and `/health`
+- **Multi-chain Support**: Works with any chain implementation (EIP-155, Solana, Aptos)
+- **Scheme Registry**: Pluggable architecture for supporting multiple payment schemes
+- **Graceful Shutdown**: Signal handling for clean server shutdown
+- **OpenTelemetry**: Optional tracing and metrics support (`telemetry` feature)
+
+## Installation
+
+Add to your `Cargo.toml`:
+
+```toml
+x402-facilitator-local = "0.1"
+```
+
+With telemetry support:
+
+```toml
+x402-facilitator-local = { version = "0.1", features = ["telemetry"] }
+```
+
+## Usage
+
+### Basic Setup
+
+```rust
+use x402_facilitator_local::{FacilitatorLocal, handlers};
+use x402_types::chain::ChainRegistry;
+use x402_types::scheme::{SchemeBlueprints, SchemeRegistry};
+use x402_chain_eip155::{V1Eip155Exact, V2Eip155Exact};
+use x402_chain_solana::{V1SolanaExact, V2SolanaExact};
+use x402_chain_aptos::V2AptosExact;
+use std::sync::Arc;
+use axum::Router;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    // Initialize chain registry from configuration
+    let chain_registry = ChainRegistry::from_config(&chains_config).await?;
+    
+    // Register supported schemes
+    let scheme_blueprints = SchemeBlueprints::new()
+        .and_register(V1Eip155Exact)
+        .and_register(V2Eip155Exact)
+        .and_register(V1SolanaExact)
+        .and_register(V2SolanaExact)
+        .and_register(V2AptosExact);
+    
+    // Build the scheme registry
+    let scheme_registry = SchemeRegistry::build(
+        chain_registry,
+        scheme_blueprints,
+        &schemes_config,
+    );
+    
+    // Create the local facilitator
+    let facilitator = FacilitatorLocal::new(scheme_registry);
+    let state = Arc::new(facilitator);
+    
+    // Create HTTP routes
+    let app = Router::new()
+        .merge(handlers::routes().with_state(state));
+    
+    // Run the server
+let listener = tokio::net::TcpListener::bind("0.0.0.0:9090").await?;
+    axum::serve(listener, app).await?;
+    
+    Ok(())
+}
+```
+
+### With Graceful Shutdown
+
+```rust
+use x402_facilitator_local::util::SigDown;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    // ... setup facilitator and routes ...
+    
+    let sig_down = SigDown::try_new()?;
+    let cancellation_token = sig_down.cancellation_token();
+    
+let listener = tokio::net::TcpListener::bind("0.0.0.0:9090").await?;
+    axum::serve(listener, app)
+        .with_graceful_shutdown(async move {
+            cancellation_token.cancelled().await;
+        })
+        .await?;
+    
+    Ok(())
+}
+```
+
+### With OpenTelemetry
+
+```rust
+use x402_facilitator_local::util::Telemetry;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    // Initialize telemetry (reads from OTEL_* environment variables)
+    let telemetry = Telemetry::new()
+        .with_name("x402-facilitator")
+        .with_version("1.0.0")
+        .register();
+    
+    // Get the HTTP tracing layer
+    let tracing_layer = telemetry.http_tracing();
+    
+    // ... setup facilitator and routes ...
+    let app = Router::new()
+        .merge(handlers::routes().with_state(state))
+        .layer(tracing_layer);
+    
+    // Run server...
+    Ok(())
+}
+```
+
+## HTTP Endpoints
+
+The [`handlers`] module provides the following endpoints:
+
+| Endpoint     | Method | Description                                 |
+|--------------|--------|---------------------------------------------|
+| `/`          | GET    | Simple greeting message                     |
+| `/verify`    | GET    | Schema information for verify endpoint      |
+| `/verify`    | POST   | Verify a payment payload                    |
+| `/settle`    | GET    | Schema information for settle endpoint      |
+| `/settle`    | POST   | Settle a verified payment on-chain          |
+| `/supported` | GET    | List supported payment schemes and networks |
+| `/health`    | GET    | Health check (delegates to `/supported`)    |
+
+## Architecture
+
+The local facilitator uses a scheme-based architecture:
+
+1. **Chain Registry**: Manages blockchain providers and connections
+2. **Scheme Blueprints**: Defines available payment schemes (V1/V2, EIP-155/Solana/Aptos)
+3. **Scheme Registry**: Combines chains and schemes into executable handlers
+4. **FacilitatorLocal**: Routes requests to the appropriate scheme handler
+
+```text
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ FacilitatorLocalâ”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚
+    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
+    â”‚ Scheme  â”‚
+    â”‚Registry â”‚
+    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
+         â”‚
+    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
+    â–¼         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”
+â”‚V2Eip  â”‚ â”‚V2Sol  â”‚
+â”‚155Exactâ”‚ â”‚anaExactâ”‚
+â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜
+    â”‚         â”‚
+â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
+â”‚Eip155 â”‚ â”‚Solana â”‚
+â”‚Providerâ”‚ â”‚Providerâ”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+## Configuration
+
+The facilitator requires configuration for chains and optionally for schemes:
+
+```json
+{
+  "chains": {
+    "eip155:8453": {
+      "eip1559": true,
+      "signers": ["$FACILITATOR_PRIVATE_KEY"],
+      "rpc": [
+        {
+          "http": "https://mainnet.base.org",
+          "rate_limit": 100
+        }
+      ]
+    },
+    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "signers": ["$SOLANA_PRIVATE_KEY"],
+      "rpc": [
+        {
+          "http": "https://api.mainnet-beta.solana.com"
+        }
+      ]
+    }
+  },
+  "schemes": [
+    {
+      "scheme": "v2-eip155-exact",
+      "chains": ["eip155:8453"]
+    },
+    {
+      "scheme": "v2-solana-exact",
+      "chains": ["solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"]
+    }
+  ]
+}
+```
+
+## Feature Flags
+
+| Feature     | Description                               |
+|-------------|-------------------------------------------|
+| `telemetry` | Enables OpenTelemetry tracing and metrics |
+
+## Environment Variables
+
+When using the `telemetry` feature:
+
+| Variable                      | Description                          |
+|-------------------------------|--------------------------------------|
+| `OTEL_EXPORTER_OTLP_ENDPOINT` | OTLP collector endpoint              |
+| `OTEL_EXPORTER_OTLP_PROTOCOL` | Protocol (`http/protobuf` or `grpc`) |
+| `OTEL_SERVICE_NAME`           | Service name for traces              |
+| `OTEL_SERVICE_VERSION`        | Service version                      |
+| `OTEL_SERVICE_DEPLOYMENT`     | Deployment environment               |
+
+## Related Crates
+
+| Crate                                                             | Description                                    |
+|-------------------------------------------------------------------|------------------------------------------------|
+| [`x402-types`](https://crates.io/crates/x402-types)               | Core types and facilitator trait               |
+| [`x402-chain-eip155`](https://crates.io/crates/x402-chain-eip155) | EIP-155 (EVM) chain support                    |
+| [`x402-chain-solana`](https://crates.io/crates/x402-chain-solana) | Solana chain support                           |
+| [`x402-chain-aptos`](https://crates.io/crates/x402-chain-aptos)   | Aptos chain support                            |
+| [`x402-axum`](https://crates.io/crates/x402-axum)                 | Axum middleware for payment-gated endpoints    |
+| [`x402-reqwest`](https://crates.io/crates/x402-reqwest)           | Reqwest client with automatic payment handling |
+
+## License
+
+Apache-2.0
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/facilitator_local.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/facilitator_local.rs
new file mode 100644
index 0000000..ee18294
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/facilitator_local.rs
@@ -0,0 +1,164 @@
+//! Local facilitator implementation for x402 payments.
+//!
+//! This module provides [`FacilitatorLocal`], a [`Facilitator`](x402_types::facilitator::Facilitator) implementation that
+//! validates x402 payment payloads and performs on-chain settlements using the
+//! registered scheme handlers.
+//!
+//! # Architecture
+//!
+//! The local facilitator delegates payment processing to scheme handlers registered
+//! in a [`SchemeRegistry`](x402_types::scheme::SchemeRegistry). Each handler is responsible for:
+//!
+//! - Verifying payment signatures and requirements
+//! - Checking on-chain balances
+//! - Executing settlement transactions
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_facilitator_local::FacilitatorLocal;
+//! use x402_types::scheme::SchemeRegistry;
+//!
+//! let registry = SchemeRegistry::build(chain_registry, scheme_blueprints, &config);
+//! let facilitator = FacilitatorLocal::new(registry);
+//! ```
+//!
+//! # Scheme Routing
+//!
+//! The facilitator routes requests to the appropriate scheme handler based on the
+//! payment's chain ID and scheme name. The scheme handler slug is extracted from
+//! the request and used to look up the handler in the registry.
+//!
+//! If no matching handler is found, the request returns an error with
+//! [`PaymentVerificationError::UnsupportedScheme`](x402_types::proto::PaymentVerificationError::UnsupportedScheme).
+
+use std::collections::HashMap;
+use x402_types::facilitator::Facilitator;
+use x402_types::proto;
+use x402_types::proto::PaymentVerificationError;
+use x402_types::scheme::{SchemeRegistry, X402SchemeFacilitatorError};
+
+/// A local [`Facilitator`](x402_types::facilitator::Facilitator) implementation that delegates to scheme handlers.
+///
+/// This type wraps a [`SchemeRegistry`](x402_types::scheme::SchemeRegistry) and routes payment verification and
+/// settlement requests to the appropriate scheme handler based on the payment's
+/// chain ID and scheme name.
+///
+/// # Type Parameter
+///
+/// - `A` - The handler registry type (typically [`SchemeRegistry`](x402_types::scheme::SchemeRegistry))
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_facilitator_local::FacilitatorLocal;
+/// use x402_types::scheme::SchemeRegistry;
+///
+/// let scheme_registry = SchemeRegistry::build(chain_registry, scheme_blueprints, &config);
+/// let facilitator = FacilitatorLocal::new(scheme_registry);
+///
+/// // Use the facilitator to verify payments
+/// let response = facilitator.verify(&verify_request).await?;
+/// ```
+pub struct FacilitatorLocal<A> {
+    handlers: A,
+}
+
+impl<A> FacilitatorLocal<A> {
+    /// Creates a new [`FacilitatorLocal`] with the given scheme handler registry.
+    ///
+    /// # Arguments
+    ///
+    /// - `handlers` - The scheme registry containing all registered payment handlers
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_facilitator_local::FacilitatorLocal;
+    /// use x402_types::scheme::SchemeRegistry;
+    ///
+    /// let scheme_registry = SchemeRegistry::build(chain_registry, scheme_blueprints, &config);
+    /// let facilitator = FacilitatorLocal::new(scheme_registry);
+    /// ```
+    pub fn new(handlers: A) -> Self {
+        FacilitatorLocal { handlers }
+    }
+}
+
+impl Facilitator for FacilitatorLocal<SchemeRegistry> {
+    type Error = FacilitatorLocalError;
+
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, Self::Error> {
+        let handler = request
+            .scheme_handler_slug()
+            .and_then(|slug| self.handlers.by_slug(&slug))
+            .ok_or(FacilitatorLocalError::Verification(
+                PaymentVerificationError::UnsupportedScheme.into(),
+            ))?;
+        let response = handler
+            .verify(request)
+            .await
+            .map_err(FacilitatorLocalError::Verification)?;
+        Ok(response)
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, Self::Error> {
+        let handler = request
+            .scheme_handler_slug()
+            .and_then(|slug| self.handlers.by_slug(&slug))
+            .ok_or(FacilitatorLocalError::Verification(
+                PaymentVerificationError::UnsupportedScheme.into(),
+            ))?;
+        let response = handler
+            .settle(request)
+            .await
+            .map_err(FacilitatorLocalError::Settlement)?;
+        Ok(response)
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, Self::Error> {
+        let mut kinds = vec![];
+        let mut signers = HashMap::new();
+        for provider in self.handlers.values() {
+            let supported = provider.supported().await.ok();
+            if let Some(mut supported) = supported {
+                kinds.append(&mut supported.kinds);
+                for (chain_id, signer_addresses) in supported.signers {
+                    signers.entry(chain_id).or_insert(signer_addresses);
+                }
+            }
+        }
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+
+/// Errors that can occur during local facilitator operations.
+///
+/// These errors wrap the underlying scheme handler errors and distinguish between
+/// verification failures (which occur during the `/verify` step) and settlement
+/// failures (which occur during the `/settle` step).
+#[derive(Debug, thiserror::Error)]
+pub enum FacilitatorLocalError {
+    /// Payment verification failed.
+    ///
+    /// This error occurs when the scheme handler fails to verify a payment,
+    /// typically due to invalid signatures, unsupported schemes, or insufficient funds.
+    #[error(transparent)]
+    Verification(X402SchemeFacilitatorError),
+    /// Payment settlement failed.
+    ///
+    /// This error occurs when the scheme handler fails to settle a payment on-chain,
+    /// typically due to transaction failures or network issues.
+    #[error(transparent)]
+    Settlement(X402SchemeFacilitatorError),
+}
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/handlers.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/handlers.rs
new file mode 100644
index 0000000..22093f2
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/handlers.rs
@@ -0,0 +1,272 @@
+//! HTTP endpoints implemented by the x402 **facilitator**.
+//!
+//! These are the server-side handlers for processing client-submitted x402 payments.
+//! They include both protocol-critical endpoints (`/verify`, `/settle`) and discovery endpoints (`/supported`, etc).
+//!
+//! All payloads follow the types defined in the `x402-rs` crate, and are compatible
+//! with the TypeScript and Go client SDKs.
+//!
+//! Each endpoint consumes or produces structured JSON payloads defined in `x402-rs`,
+//! and is compatible with official x402 client SDKs.
+
+use axum::extract::State;
+use axum::http::StatusCode;
+use axum::response::Response;
+use axum::routing::{get, post};
+use axum::{Json, Router, response::IntoResponse};
+use serde::{Deserialize, Serialize};
+use serde_json::json;
+use x402_types::facilitator::Facilitator;
+use x402_types::proto;
+use x402_types::proto::{AsPaymentProblem, ErrorReason};
+use x402_types::scheme::X402SchemeFacilitatorError;
+
+#[cfg(feature = "telemetry")]
+use tracing::instrument;
+
+use crate::facilitator_local::FacilitatorLocalError;
+
+/// `GET /verify`: Returns a machine-readable description of the `/verify` endpoint.
+///
+/// This is served by the facilitator to help clients understand how to construct
+/// a valid [`VerifyRequest`](x402_types::proto::VerifyRequest) for payment verification.
+///
+/// This is optional metadata and primarily useful for discoverability and debugging tools.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn get_verify_info() -> impl IntoResponse {
+    Json(json!({
+        "endpoint": "/verify",
+        "description": "POST to verify x402 payments",
+        "body": {
+            "paymentPayload": "PaymentPayload",
+            "paymentRequirements": "PaymentRequirements",
+        }
+    }))
+}
+
+/// `GET /settle`: Returns a machine-readable description of the `/settle` endpoint.
+///
+/// This is served by the facilitator to describe the structure of a valid
+/// [`SettleRequest`](x402_types::proto::SettleRequest) used to initiate on-chain payment settlement.
+///
+/// This is optional metadata and primarily useful for discoverability and debugging tools.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn get_settle_info() -> impl IntoResponse {
+    Json(json!({
+        "endpoint": "/settle",
+        "description": "POST to settle x402 payments",
+        "body": {
+            "paymentPayload": "PaymentPayload",
+            "paymentRequirements": "PaymentRequirements",
+        }
+    }))
+}
+
+/// Creates the Axum router with all x402 facilitator endpoints.
+///
+/// The router includes the following routes:
+/// - `GET /` - Root greeting
+/// - `GET /verify` - Schema information for verify endpoint
+/// - `POST /verify` - Verify a payment payload
+/// - `GET /settle` - Schema information for settle endpoint
+/// - `POST /settle` - Settle a verified payment on-chain
+/// - `GET /health` - Health check (delegates to `/supported`)
+/// - `GET /supported` - List supported payment schemes and networks
+///
+/// # Type Parameters
+///
+/// - `A` - The facilitator type that implements [`Facilitator`]
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_facilitator_local::{FacilitatorLocal, handlers};
+/// use std::sync::Arc;
+///
+/// let facilitator = FacilitatorLocal::new(scheme_registry);
+/// let state = Arc::new(facilitator);
+/// let app = axum::Router::new()
+///     .merge(handlers::routes().with_state(state));
+/// ```
+pub fn routes<A>() -> Router<A>
+where
+    A: Facilitator + Clone + Send + Sync + 'static,
+    A::Error: IntoResponse,
+{
+    Router::new()
+        .route("/", get(get_root))
+        .route("/verify", get(get_verify_info))
+        .route("/verify", post(post_verify::<A>))
+        .route("/settle", get(get_settle_info))
+        .route("/settle", post(post_settle::<A>))
+        .route("/health", get(get_health::<A>))
+        .route("/supported", get(get_supported::<A>))
+}
+
+/// `GET /`: Returns a simple greeting message from the facilitator.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn get_root() -> impl IntoResponse {
+    let pkg_name = env!("CARGO_PKG_NAME");
+    (StatusCode::OK, format!("Hello from {pkg_name}!"))
+}
+
+/// `GET /supported`: Lists the x402 payment schemes and networks supported by this facilitator.
+///
+/// Facilitators may expose this to help clients dynamically configure their payment requests
+/// based on available network and scheme support.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn get_supported<A>(State(facilitator): State<A>) -> impl IntoResponse
+where
+    A: Facilitator,
+    A::Error: IntoResponse,
+{
+    match facilitator.supported().await {
+        Ok(supported) => (StatusCode::OK, Json(json!(supported))).into_response(),
+        Err(error) => error.into_response(),
+    }
+}
+
+/// `GET /health`: Health check endpoint.
+///
+/// Returns the same response as `/supported`, making it useful for load balancers
+/// and monitoring systems to check if the facilitator is operational.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn get_health<A>(State(facilitator): State<A>) -> impl IntoResponse
+where
+    A: Facilitator,
+    A::Error: IntoResponse,
+{
+    get_supported(State(facilitator)).await
+}
+
+/// `POST /verify`: Facilitator-side verification of a proposed x402 payment.
+///
+/// This endpoint checks whether a given payment payload satisfies the declared
+/// [`PaymentRequirements`](x402_types::proto::PaymentRequirements), including signature validity, scheme match,
+/// and fund sufficiency.
+///
+/// Responds with a [`VerifyResponse`](x402_types::proto::VerifyResponse) indicating whether the payment can be accepted.
+///
+/// # Errors
+///
+/// Returns `400 Bad Request` if the payment verification fails (e.g., invalid signature,
+/// unsupported scheme, insufficient funds). Returns `500 Internal Server Error` if an
+/// unexpected error occurs during verification.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn post_verify<A>(
+    State(facilitator): State<A>,
+    Json(body): Json<proto::VerifyRequest>,
+) -> impl IntoResponse
+where
+    A: Facilitator,
+    A::Error: IntoResponse,
+{
+    match facilitator.verify(&body).await {
+        Ok(valid_response) => (StatusCode::OK, Json(valid_response)).into_response(),
+        Err(error) => {
+            #[cfg(feature = "telemetry")]
+            tracing::warn!(
+                error = ?error,
+                body = %serde_json::to_string(&body).unwrap_or_else(|_| "<can-not-serialize>".to_string()),
+                "Verification failed"
+            );
+            error.into_response()
+        }
+    }
+}
+
+/// `POST /settle`: Facilitator-side execution of a valid x402 payment on-chain.
+///
+/// Given a valid [`SettleRequest`](x402_types::proto::SettleRequest), this endpoint attempts to execute the payment
+/// on-chain using the appropriate scheme handler, and returns a [`SettleResponse`](x402_types::proto::SettleResponse)
+/// with transaction details.
+///
+/// This endpoint is typically called after a successful `/verify` step.
+///
+/// # Errors
+///
+/// Returns `400 Bad Request` if the payment verification fails (e.g., invalid signature,
+/// insufficient funds). Returns `500 Internal Server Error` if the on-chain settlement fails.
+#[cfg_attr(feature = "telemetry", instrument(skip_all))]
+pub async fn post_settle<A>(
+    State(facilitator): State<A>,
+    Json(body): Json<proto::SettleRequest>,
+) -> impl IntoResponse
+where
+    A: Facilitator,
+    A::Error: IntoResponse,
+{
+    match facilitator.settle(&body).await {
+        Ok(valid_response) => (StatusCode::OK, Json(valid_response)).into_response(),
+        Err(error) => {
+            #[cfg(feature = "telemetry")]
+            tracing::warn!(
+                error = ?error,
+                body = %serde_json::to_string(&body).unwrap_or_else(|_| "<can-not-serialize>".to_string()),
+                "Settlement failed"
+            );
+            error.into_response()
+        }
+    }
+}
+
+impl IntoResponse for FacilitatorLocalError {
+    fn into_response(self) -> Response {
+        #[derive(Serialize, Deserialize)]
+        #[serde(rename_all = "camelCase")]
+        struct VerificationErrorResponse<'a> {
+            is_valid: bool,
+            invalid_reason: ErrorReason,
+            invalid_reason_details: &'a str,
+            payer: &'a str,
+        }
+
+        #[derive(Serialize, Deserialize)]
+        #[serde(rename_all = "camelCase")]
+        struct SettlementErrorResponse<'a> {
+            success: bool,
+            network: &'a str,
+            transaction: &'a str,
+            error_reason: ErrorReason,
+            error_reason_details: &'a str,
+            payer: &'a str,
+        }
+
+        match self {
+            FacilitatorLocalError::Verification(scheme_handler_error) => {
+                let problem = scheme_handler_error.as_payment_problem();
+                let verification_error_response = VerificationErrorResponse {
+                    is_valid: false,
+                    invalid_reason: problem.reason(),
+                    invalid_reason_details: problem.details(),
+                    payer: "",
+                };
+                let status_code = match scheme_handler_error {
+                    X402SchemeFacilitatorError::PaymentVerification(_) => StatusCode::BAD_REQUEST,
+                    X402SchemeFacilitatorError::OnchainFailure(_) => {
+                        StatusCode::INTERNAL_SERVER_ERROR
+                    }
+                };
+                (status_code, Json(verification_error_response)).into_response()
+            }
+            FacilitatorLocalError::Settlement(scheme_handler_error) => {
+                let problem = scheme_handler_error.as_payment_problem();
+                let settlement_error_response = SettlementErrorResponse {
+                    success: false,
+                    network: "",
+                    transaction: "",
+                    error_reason: problem.reason(),
+                    error_reason_details: problem.details(),
+                    payer: "",
+                };
+                let status_code = match scheme_handler_error {
+                    X402SchemeFacilitatorError::PaymentVerification(_) => StatusCode::BAD_REQUEST,
+                    X402SchemeFacilitatorError::OnchainFailure(_) => {
+                        StatusCode::INTERNAL_SERVER_ERROR
+                    }
+                };
+                (status_code, Json(settlement_error_response)).into_response()
+            }
+        }
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/lib.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/lib.rs
new file mode 100644
index 0000000..f5652d3
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/lib.rs
@@ -0,0 +1,71 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Local facilitator implementation for the x402 payment protocol.
+//!
+//! This crate provides [`FacilitatorLocal`], a [`Facilitator`](x402_types::facilitator::Facilitator)
+//! implementation that validates x402 payment payloads and performs on-chain settlements
+//! using registered scheme handlers.
+//!
+//! # Architecture
+//!
+//! The local facilitator uses a scheme-based architecture:
+//!
+//! 1. **Chain Registry**: Manages blockchain providers and connections ([`x402_types::chain::ChainRegistry`])
+//! 2. **Scheme Blueprints**: Defines available payment schemes ([`x402_types::scheme::SchemeBlueprints`])
+//! 3. **Scheme Registry**: Combines chains and schemes into executable handlers ([`x402_types::scheme::SchemeRegistry`])
+//! 4. **FacilitatorLocal**: Routes requests to the appropriate scheme handler ([`FacilitatorLocal`])
+//!
+//! # Modules
+//!
+//! - [`facilitator_local`] - Core facilitator implementation
+//! - [`handlers`] - HTTP endpoints for the x402 protocol
+//! - [`util`] - Utilities for graceful shutdown and telemetry
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_facilitator_local::{FacilitatorLocal, handlers};
+//! use x402_types::chain::ChainRegistry;
+//! use x402_types::scheme::{SchemeBlueprints, SchemeRegistry};
+//! use x402_chain_eip155::{V1Eip155Exact, V2Eip155Exact};
+//! use std::sync::Arc;
+//!
+//! #[tokio::main]
+//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
+//!     // Initialize chain registry
+//!     let chain_registry = ChainRegistry::from_config(&chains_config).await?;
+//!
+//!     // Register schemes
+//!     let scheme_blueprints = SchemeBlueprints::new()
+//!         .and_register(V1Eip155Exact)
+//!         .and_register(V2Eip155Exact);
+//!
+//!     // Build scheme registry
+//!     let scheme_registry = SchemeRegistry::build(
+//!         chain_registry,
+//!         scheme_blueprints,
+//!         &schemes_config,
+//!     );
+//!
+//!     // Create facilitator
+//!     let facilitator = FacilitatorLocal::new(scheme_registry);
+//!     let state = Arc::new(facilitator);
+//!
+//!     // Create HTTP routes
+//!     let app = axum::Router::new()
+//!         .merge(handlers::routes().with_state(state));
+//!
+//!     // Run server
+//!     let listener = tokio::net::TcpListener::bind("0.0.0.0:9090").await?;
+//!     axum::serve(listener, app).await?;
+//!
+//!     Ok(())
+//! }
+//! ```
+
+pub mod facilitator_local;
+pub mod handlers;
+pub mod util;
+
+pub use facilitator_local::*;
+pub use handlers::*;
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/mod.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/mod.rs
new file mode 100644
index 0000000..29e7cfa
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/mod.rs
@@ -0,0 +1,25 @@
+//! Utility modules for the x402-facilitator-local crate.
+//!
+//! This module provides various helper types used throughout the crate:
+//!
+//! | Module | Description | Feature |
+//! |--------|-------------|---------|
+//! | [`sig_down`] | Graceful shutdown signal handling | - |
+//! | [`telemetry`] | OpenTelemetry tracing and metrics setup | `telemetry` |
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_facilitator_local::util::SigDown;
+//!
+//! let sig_down = SigDown::try_new()?;
+//! let token = sig_down.cancellation_token();
+//! ```
+
+pub mod sig_down;
+#[cfg(feature = "telemetry")]
+pub mod telemetry;
+
+pub use sig_down::*;
+#[cfg(feature = "telemetry")]
+pub use telemetry::*;
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/sig_down.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/sig_down.rs
new file mode 100644
index 0000000..a049042
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/sig_down.rs
@@ -0,0 +1,156 @@
+//! Graceful shutdown signal handling.
+//!
+//! This module provides [`SigDown`], a utility for handling Unix shutdown
+//! signals (SIGTERM and SIGINT) and coordinating graceful shutdown across
+//! multiple subsystems using cancellation tokens.
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_facilitator_local::util::SigDown;
+//!
+//! let sig_down = SigDown::try_new()?;
+//! let token = sig_down.cancellation_token();
+//!
+//! // Pass token to subsystems
+//! tokio::spawn(async move {
+//!     token.cancelled().await;
+//!     println!("Shutting down...");
+//! });
+//!
+//! // Wait for shutdown signal
+//! sig_down.recv().await;
+//! ```
+//!
+//! # Architecture
+//!
+//! [`SigDown`] spawns a background task that listens for Unix signals (SIGTERM and SIGINT).
+//! When a signal is received, it triggers a [`CancellationToken`] that can be distributed
+//! to multiple subsystems. This allows for coordinated graceful shutdown where all
+//! components can clean up resources before the application exits.
+//!
+//! The [`TaskTracker`] is used to ensure the signal handler task completes before
+//! the application exits.
+
+use tokio::signal::unix::SignalKind;
+use tokio::signal::unix::signal;
+use tokio_util::sync::CancellationToken;
+use tokio_util::task::TaskTracker;
+
+/// Handles graceful shutdown on SIGTERM and SIGINT signals.
+///
+/// Spawns a background task that listens for shutdown signals and triggers
+/// a cancellation token when received.
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_facilitator_local::util::SigDown;
+///
+/// #[tokio::main]
+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
+///     let sig_down = SigDown::try_new()?;
+///     let token = sig_down.cancellation_token();
+///
+///     // Use token for graceful shutdown in axum
+///     let listener = tokio::net::TcpListener::bind("0.0.0.0:9090").await?;
+///     axum::serve(listener, app)
+///         .with_graceful_shutdown(async move { token.cancelled().await })
+///         .await?;
+///
+///     Ok(())
+/// }
+/// ```
+pub struct SigDown {
+    task_tracker: TaskTracker,
+    cancellation_token: CancellationToken,
+}
+
+impl SigDown {
+    /// Creates a new signal handler.
+    ///
+    /// Returns an error if signal registration fails (e.g., if the platform
+    /// does not support Unix signals).
+    ///
+    /// # Errors
+    ///
+    /// Returns an [`std::io::Error`] if signal registration fails.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_facilitator_local::util::SigDown;
+    ///
+    /// let sig_down = SigDown::try_new()?;
+    /// let token = sig_down.cancellation_token();
+    /// ```
+    pub fn try_new() -> Result<Self, std::io::Error> {
+        let mut sigterm = signal(SignalKind::terminate())?;
+        let mut sigint = signal(SignalKind::interrupt())?;
+        let inner = CancellationToken::new();
+        let outer = inner.clone();
+        let task_tracker = TaskTracker::new();
+        task_tracker.spawn(async move {
+            tokio::select! {
+                _ = sigterm.recv() => {
+                    inner.cancel();
+                },
+                _ = sigint.recv() => {
+                    inner.cancel();
+                }
+            }
+        });
+        task_tracker.close();
+        Ok(Self {
+            task_tracker,
+            cancellation_token: outer,
+        })
+    }
+
+    /// Returns a clone of the cancellation token for distributing to subsystems.
+    ///
+    /// The token can be passed to multiple subsystems. When a shutdown signal is received,
+    /// all clones of the token will be cancelled simultaneously.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_facilitator_local::util::SigDown;
+    ///
+    /// let sig_down = SigDown::try_new()?;
+    /// let token = sig_down.cancellation_token();
+    ///
+    /// // Pass token to multiple subsystems
+    /// let token2 = token.clone();
+    /// tokio::spawn(async move {
+    ///     token2.cancelled().await;
+    ///     println!("Subsystem 2 shutting down...");
+    /// });
+    /// ```
+    pub fn cancellation_token(&self) -> CancellationToken {
+        self.cancellation_token.clone()
+    }
+
+    /// Waits for a shutdown signal and ensures the signal handler task completes.
+    ///
+    /// This method blocks until either SIGTERM or SIGINT is received, then waits
+    /// for the signal handler task to complete. This ensures clean shutdown
+    /// without leaving background tasks running.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_facilitator_local::util::SigDown;
+    ///
+    /// let sig_down = SigDown::try_new()?;
+    ///
+    /// // Wait for shutdown signal
+    /// sig_down.recv().await;
+    /// println!("Shutdown complete");
+    /// ```
+    #[allow(dead_code)]
+    pub async fn recv(&self) {
+        self.cancellation_token.cancelled().await;
+        self.task_tracker.wait().await;
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/telemetry.rs b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/telemetry.rs
new file mode 100644
index 0000000..cf34ac0
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-facilitator-local/src/util/telemetry.rs
@@ -0,0 +1,471 @@
+//! OpenTelemetry tracing and metrics setup.
+//!
+//! This module provides [`Telemetry`] for configuring OpenTelemetry-based
+//! distributed tracing and metrics collection. It supports both HTTP and
+//! gRPC OTLP exporters.
+//!
+//! # Configuration
+//!
+//! Telemetry is configured via environment variables:
+//!
+//! | Variable | Description |
+//! |----------|-------------|
+//! | `OTEL_EXPORTER_OTLP_ENDPOINT` | OTLP collector endpoint |
+//! | `OTEL_EXPORTER_OTLP_PROTOCOL` | Protocol (`http/protobuf` or `grpc`) |
+//! | `OTEL_SERVICE_NAME` | Service name for traces |
+//! | `OTEL_SERVICE_VERSION` | Service version |
+//! | `OTEL_SERVICE_DEPLOYMENT` | Deployment environment |
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_facilitator_local::util::Telemetry;
+//!
+//! // Initialize telemetry (reads from environment)
+//! let telemetry = Telemetry::new()
+//!     .with_name("x402-facilitator")
+//!     .with_version("1.0.0")
+//!     .register();
+//!
+//! // Get HTTP tracing layer for axum
+//! let tracing_layer = telemetry.http_tracing();
+//!
+//! // Telemetry is now active; spans and metrics will be exported
+//! tracing::info!("Application started");
+//! ```
+//!
+//! # Features
+//!
+//! This module is only available when the `telemetry` feature is enabled.
+//!
+//! The telemetry system provides:
+//! - Distributed tracing via OpenTelemetry
+//! - Metrics collection via OTLP
+//! - HTTP request tracing for axum applications
+//! - Automatic graceful shutdown of exporters via [`TelemetryProviders`]
+
+use axum::http::{Request, Response};
+use opentelemetry::trace::{Status, TracerProvider};
+use opentelemetry::{KeyValue, Value, global};
+use opentelemetry_sdk::{
+    Resource,
+    metrics::{MeterProviderBuilder, PeriodicReader, SdkMeterProvider},
+    trace::{RandomIdGenerator, Sampler, SdkTracerProvider},
+};
+use opentelemetry_semantic_conventions::{
+    SCHEMA_URL,
+    attribute::{DEPLOYMENT_ENVIRONMENT_NAME, SERVICE_VERSION},
+};
+use serde::{Deserialize, Serialize};
+use std::env;
+use std::time::Duration;
+use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};
+use tracing::Span;
+use tracing_opentelemetry::{MetricsLayer, OpenTelemetryLayer, OpenTelemetrySpanExt};
+use tracing_subscriber::{EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};
+
+/// Supported telemetry transport protocols for exporting OTLP data.
+///
+/// The default is HTTP if not explicitly configured.
+#[allow(clippy::upper_case_acronyms)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+enum TelemetryProtocol {
+    /// Use `http/protobuf` protocol for OTLP export.
+    #[serde(rename = "http/protobuf")]
+    HTTP,
+    /// Use `grpc` protocol for OTLP export.
+    #[serde(rename = "grpc")]
+    GRPC,
+}
+
+impl TelemetryProtocol {
+    /// Detects the telemetry protocol based on OTEL-related environment variables.
+    ///
+    /// Returns `Some(TelemetryProtocol)` if telemetry is enabled, or `None` if
+    /// no relevant environment variables are set.
+    pub fn from_env() -> Option<Self> {
+        let is_enabled = env::var("OTEL_EXPORTER_OTLP_ENDPOINT").is_ok()
+            || env::var("OTEL_EXPORTER_OTLP_HEADERS").is_ok()
+            || env::var("OTEL_EXPORTER_OTLP_PROTOCOL").is_ok();
+        if is_enabled {
+            let protocol = match env::var("OTEL_EXPORTER_OTLP_PROTOCOL") {
+                Ok(string) => match string.as_str() {
+                    "http/protobuf" | "http" => TelemetryProtocol::HTTP,
+                    "grpc" => TelemetryProtocol::GRPC,
+                    _ => TelemetryProtocol::HTTP,
+                },
+                Err(_) => TelemetryProtocol::HTTP,
+            };
+            Some(protocol)
+        } else {
+            None
+        }
+    }
+}
+
+/// Describes the local service's identity and metadata for telemetry purposes.
+///
+/// This includes:
+/// - The service `name` and `version` (used in span and metric resources),
+/// - The `deployment` environment (e.g., "dev", "staging", "prod").
+///
+/// These values can be provided manually via [`Telemetry::with_name`], [`Telemetry::with_version`], [`Telemetry::with_deployment`],
+/// or overridden using environment variables:
+/// - `OTEL_SERVICE_NAME`
+/// - `OTEL_SERVICE_VERSION`
+/// - `OTEL_SERVICE_DEPLOYMENT`
+#[derive(Clone, Debug, Default)]
+pub struct Telemetry {
+    /// Optional service name (e.g., `"x402-facilitator"`).
+    ///
+    /// May be overridden by the `OTEL_SERVICE_NAME` environment variable.
+    pub name: Option<Value>,
+    /// Optional service version (e.g., `"0.3.0"`).
+    ///
+    /// May be overridden by the `OTEL_SERVICE_VERSION` environment variable.
+    pub version: Option<Value>,
+    /// Optional deployment environment (e.g., `"production"` or `"develop"`).
+    ///
+    /// May be overridden by the `OTEL_SERVICE_DEPLOYMENT` environment variable.
+    pub deployment: Option<Value>,
+}
+
+impl Telemetry {
+    /// Creates a new, empty [`Telemetry`] instance.
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    /// Sets the service name.
+    #[allow(dead_code)]
+    pub fn with_name(&self, name: impl Into<Value>) -> Self {
+        let mut this = self.clone();
+        this.name = Some(name.into());
+        this
+    }
+
+    /// Sets the service version.
+    #[allow(dead_code)]
+    pub fn with_version(&self, version: impl Into<Value>) -> Self {
+        let mut this = self.clone();
+        this.version = Some(version.into());
+        this
+    }
+
+    /// Sets the deployment environment for this service (e.g., `"production"`, `"staging"`).
+    ///
+    /// This value is used for populating the `deployment.environment` semantic attribute.
+    #[allow(dead_code)]
+    pub fn with_deployment(&self, deployment: impl Into<Value>) -> Self {
+        let mut this = self.clone();
+        this.deployment = Some(deployment.into());
+        this
+    }
+
+    /// Resolves the service name for telemetry.
+    ///
+    /// Order of precedence:
+    /// 1. `OTEL_SERVICE_NAME` env variable (if non-empty),
+    /// 2. Otherwise, fallback to locally set value in `self.name`.
+    pub fn name(&self) -> Option<Value> {
+        env::var("OTEL_SERVICE_NAME")
+            .ok()
+            .filter(|value| !value.trim().is_empty())
+            .map(Value::from)
+            .or_else(|| self.name.clone())
+    }
+
+    /// Resolves the service version for telemetry.
+    ///
+    /// Order of precedence:
+    /// 1. `OTEL_SERVICE_VERSION` env variable (if non-empty),
+    /// 2. Otherwise, fallback to locally set value in `self.version`.
+    pub fn version(&self) -> Option<Value> {
+        env::var("OTEL_SERVICE_VERSION")
+            .ok()
+            .filter(|value| !value.trim().is_empty())
+            .map(Value::from)
+            .or_else(|| self.version.clone())
+    }
+
+    /// Resolves the service deployment environment.
+    ///
+    /// Order of precedence:
+    /// 1. `OTEL_SERVICE_DEPLOYMENT` env variable (if non-empty),
+    /// 2. Otherwise, fallback to locally set value in `self.deployment`.
+    pub fn deployment(&self) -> Option<Value> {
+        env::var("OTEL_SERVICE_DEPLOYMENT")
+            .ok()
+            .filter(|value| !value.trim().is_empty())
+            .map(Value::from)
+            .or_else(|| self.deployment.clone())
+    }
+
+    /// Builds an OpenTelemetry [`Resource`] describing the service for use in traces and metrics.
+    ///
+    /// This includes:
+    /// - Service name (if set or inferred from `OTEL_SERVICE_NAME`)
+    /// - Service version (from `OTEL_SERVICE_VERSION` or `self.version`)
+    /// - Deployment environment (from `OTEL_SERVICE_DEPLOYMENT` or `self.deployment`)
+    ///
+    /// The semantic attributes are attached with the OpenTelemetry semantic conventions (see [`SCHEMA_URL`]).
+    pub fn resource(&self) -> Resource {
+        let mut builder = Resource::builder();
+        if let Some(name) = self.name() {
+            builder = builder.with_service_name(name)
+        }
+        let mut attributes = Vec::<KeyValue>::with_capacity(2);
+        if let Some(version) = self.version() {
+            attributes.push(KeyValue::new(SERVICE_VERSION, version));
+        }
+        if let Some(deployment) = self.deployment() {
+            attributes.push(KeyValue::new(DEPLOYMENT_ENVIRONMENT_NAME, deployment));
+        }
+        if !attributes.is_empty() {
+            builder = builder.with_schema_url(attributes, SCHEMA_URL);
+        }
+        builder.build()
+    }
+
+    /// Initializes the OpenTelemetry tracer provider.
+    fn init_tracer_provider(&self, telemetry_protocol: &TelemetryProtocol) -> SdkTracerProvider {
+        let exporter = opentelemetry_otlp::SpanExporter::builder();
+        // Choose transport protocol
+        let exporter = match telemetry_protocol {
+            TelemetryProtocol::HTTP => exporter.with_http().build(),
+            TelemetryProtocol::GRPC => exporter.with_tonic().build(),
+        };
+        let exporter = exporter.expect("Failed to build OTLP span exporter");
+
+        // Construct and return a tracer provider
+        SdkTracerProvider::builder()
+            // Customize sampling strategy
+            .with_sampler(Sampler::ParentBased(Box::new(Sampler::TraceIdRatioBased(
+                1.0,
+            ))))
+            // If export trace to AWS X-Ray, you can use XrayIdGenerator
+            .with_id_generator(RandomIdGenerator::default())
+            .with_resource(self.resource())
+            .with_batch_exporter(exporter)
+            .build()
+    }
+
+    /// Initializes the OpenTelemetry metrics provider
+    fn init_meter_provider(&self, telemetry_protocol: &TelemetryProtocol) -> SdkMeterProvider {
+        let exporter = opentelemetry_otlp::MetricExporter::builder();
+
+        // Configure exporter based on selected protocol
+        let exporter = match telemetry_protocol {
+            TelemetryProtocol::HTTP => exporter
+                .with_http()
+                .with_temporality(opentelemetry_sdk::metrics::Temporality::default())
+                .build(),
+            TelemetryProtocol::GRPC => exporter
+                .with_tonic()
+                .with_temporality(opentelemetry_sdk::metrics::Temporality::default())
+                .build(),
+        };
+        let exporter = exporter.expect("Failed to build OTLP metric exporter");
+
+        // Set up periodic push-based metric reader
+        let reader = PeriodicReader::builder(exporter)
+            .with_interval(std::time::Duration::from_secs(30))
+            .build();
+
+        // Add stdout exporter for local development inspection
+        let stdout_reader =
+            PeriodicReader::builder(opentelemetry_stdout::MetricExporter::default()).build();
+
+        // Assemble and register the meter provider globally
+        let meter_provider = MeterProviderBuilder::default()
+            .with_resource(self.resource())
+            .with_reader(reader)
+            .with_reader(stdout_reader)
+            .build();
+
+        global::set_meter_provider(meter_provider.clone());
+
+        meter_provider
+    }
+
+    /// Initializes and registers tracing and metrics exporters using OpenTelemetry OTLP exporters.
+    ///
+    /// If telemetry-related environment variables are present (e.g., `OTEL_EXPORTER_OTLP_ENDPOINT`),
+    /// this configures and activates:
+    /// - Distributed tracing via `tracing-opentelemetry`
+    /// - Metrics collection via `opentelemetry_sdk::metrics`
+    ///
+    /// Otherwise, it defaults to console logging via `tracing-subscriber`.
+    ///
+    /// Returns a [`TelemetryProviders`] struct that performs graceful exporter shutdown on `Drop`.
+    pub fn register(&self) -> TelemetryProviders {
+        let telemetry_protocol = TelemetryProtocol::from_env();
+        match telemetry_protocol {
+            Some(telemetry_protocol) => {
+                let tracer_provider = self.init_tracer_provider(&telemetry_protocol);
+                let meter_provider = self.init_meter_provider(&telemetry_protocol);
+                let tracer = tracer_provider.tracer("tracing-otel-subscriber");
+
+                // Register tracing subscriber with OpenTelemetry layers
+                tracing_subscriber::registry()
+                    // The global level filter prevents the exporter network stack
+                    // from reentering the globally installed OpenTelemetryLayer with
+                    // its own spans while exporting, as the libraries should not use
+                    // tracing levels below DEBUG. If the OpenTelemetry layer needs to
+                    // trace spans and events with higher verbosity levels, consider using
+                    // per-layer filtering to target the telemetry layer specifically,
+                    // e.g. by target matching.
+                    .with(tracing_subscriber::filter::LevelFilter::INFO)
+                    .with(tracing_subscriber::fmt::layer())
+                    .with(MetricsLayer::new(meter_provider.clone()))
+                    .with(OpenTelemetryLayer::new(tracer))
+                    .init();
+
+                tracing::info!(
+                    "OpenTelemetry tracing and metrics exporter is enabled via {:?}",
+                    telemetry_protocol
+                );
+                TelemetryProviders {
+                    tracer_provider: Some(tracer_provider),
+                    meter_provider: Some(meter_provider),
+                }
+            }
+            None => {
+                // Fallback: just use local logging
+                tracing_subscriber::registry()
+                    .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| "trace".into()))
+                    .with(tracing_subscriber::fmt::layer())
+                    .init();
+
+                tracing::info!("OpenTelemetry is not enabled");
+
+                TelemetryProviders {
+                    tracer_provider: None,
+                    meter_provider: None,
+                }
+            }
+        }
+    }
+}
+
+/// Holds optional OpenTelemetry telemetry providers.
+///
+/// Returned by [`Telemetry::register`] and designed to ensure
+/// a graceful shutdown of tracing and metrics exporters.
+pub struct TelemetryProviders {
+    /// Tracer provider for OpenTelemetry spans
+    pub tracer_provider: Option<SdkTracerProvider>,
+    /// Metrics provider for OpenTelemetry metrics
+    pub meter_provider: Option<SdkMeterProvider>,
+}
+
+/// Drops the telemetry providers with graceful shutdown.
+///
+/// This ensures that all telemetry data is flushed before the application exits.
+/// Any shutdown errors are printed to stderr.
+impl Drop for TelemetryProviders {
+    fn drop(&mut self) {
+        if let Some(tracer_provider) = self.tracer_provider.as_ref()
+            && let Err(err) = tracer_provider.shutdown()
+        {
+            eprintln!("{err:?}");
+        }
+        if let Some(meter_provider) = self.meter_provider.as_ref()
+            && let Err(err) = meter_provider.shutdown()
+        {
+            eprintln!("{err:?}");
+        }
+    }
+}
+
+impl TelemetryProviders {
+    /// Creates an HTTP tracing layer for axum applications.
+    ///
+    /// This layer creates OpenTelemetry-compatible spans for each HTTP request
+    /// and records response status and latency.
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_facilitator_local::util::Telemetry;
+    ///
+    /// let telemetry = Telemetry::new()
+    ///     .with_name("x402-facilitator")
+    ///     .register();
+    ///
+    /// let tracing_layer = telemetry.http_tracing();
+    ///
+    /// let app = Router::new()
+    ///     .merge(handlers::routes().with_state(state))
+    ///     .layer(tracing_layer);
+    /// ```
+    pub fn http_tracing(
+        &self,
+    ) -> TraceLayer<
+        tower_http::classify::SharedClassifier<tower_http::classify::ServerErrorsAsFailures>,
+        FacilitatorHttpMakeSpan,
+        tower_http::trace::DefaultOnRequest,
+        FacilitatorHttpOnResponse,
+    > {
+        TraceLayer::new_for_http()
+            .make_span_with(FacilitatorHttpMakeSpan)
+            .on_response(FacilitatorHttpOnResponse)
+    }
+}
+
+/// Custom span maker for HTTP requests.
+///
+/// Creates OpenTelemetry-compatible spans with relevant HTTP attributes
+/// including method, URI, and version.
+#[derive(Clone, Debug)]
+pub struct FacilitatorHttpMakeSpan;
+
+impl<A> MakeSpan<A> for FacilitatorHttpMakeSpan {
+    fn make_span(&mut self, request: &Request<A>) -> Span {
+        tracing::info_span!(
+            "http_request",
+            otel.kind = "server",
+            otel.name = %format!("{} {}", request.method(), request.uri()),
+            method = %request.method(),
+            uri = %request.uri(),
+            version = ?request.version(),
+        )
+    }
+}
+
+/// Custom response handler for HTTP tracing.
+///
+/// Records response status, latency, and sets OpenTelemetry span status
+/// based on the HTTP response.
+#[derive(Clone, Debug)]
+pub struct FacilitatorHttpOnResponse;
+
+impl<A> OnResponse<A> for FacilitatorHttpOnResponse {
+    fn on_response(self, response: &Response<A>, latency: Duration, span: &Span) {
+        span.record("status", tracing::field::display(response.status()));
+        span.record("latency", tracing::field::display(latency.as_millis()));
+        span.record(
+            "http.status_code",
+            tracing::field::display(response.status().as_u16()),
+        );
+
+        // OpenTelemetry span status
+        if response.status().is_success() {
+            span.set_status(Status::Ok);
+        } else {
+            span.set_status(Status::error(
+                response
+                    .status()
+                    .canonical_reason()
+                    .unwrap_or("unknown")
+                    .to_string(),
+            ));
+        }
+
+        tracing::info!(
+            "status={} elapsed={}ms",
+            response.status().as_u16(),
+            latency.as_millis()
+        );
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/Cargo.toml b/bbt-x402-facilitator/crates/x402-reqwest/Cargo.toml
new file mode 100644
index 0000000..ee769d1
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/Cargo.toml
@@ -0,0 +1,38 @@
+[package]
+name = "x402-reqwest"
+version = "1.0.0"
+edition = "2024"
+description = "Wrapper for reqwest for transparent x402 payments"
+license = "Apache-2.0"
+authors = ["Sergey Ukustov <sergey@ukstv.me>"]
+repository = "https://github.com/x402-rs/x402-rs"
+homepage = "https://x402.rs"
+documentation = "https://docs.rs/x402-reqwest"
+keywords = ["axum", "middleware", "x402", "payments", "stablecoin"]
+categories = ["web-programming::http-client", "authentication", "cryptography", "finance", "network-programming"]
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[dependencies]
+x402-types = { workspace = true }
+reqwest = { workspace = true }
+http = { workspace = true }
+async-trait = { workspace = true }
+serde_json = { workspace = true }
+
+reqwest-middleware = { version = "0.5" }
+
+# Telemetry
+tracing = { workspace = true, optional = true }
+
+[dev-dependencies]
+alloy-signer-local = { version = "1.4" }
+x402-chain-eip155 = { workspace = true, features = ["client"] }
+
+[features]
+default = []
+telemetry = ["dep:tracing", "x402-types/telemetry"]
+json = ["reqwest-middleware/json"]
+full = ["telemetry", "json"]
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/LICENSE b/bbt-x402-facilitator/crates/x402-reqwest/LICENSE
new file mode 100644
index 0000000..0e18545
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2025 Sergey Ukustov
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
\ No newline at end of file
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/README.md b/bbt-x402-facilitator/crates/x402-reqwest/README.md
new file mode 100644
index 0000000..a2a0b74
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/README.md
@@ -0,0 +1,175 @@
+# x402-reqwest
+
+[![Crates.io](https://img.shields.io/crates/v/x402-reqwest.svg)](https://crates.io/crates/x402-reqwest)
+[![Docs.rs](https://docs.rs/x402-reqwest/badge.svg)](https://docs.rs/x402-reqwest)
+
+**Reqwest middleware that transparently handles HTTP `402 Payment Required` responses using the [x402 protocol](https://x402.org/).**
+
+This crate enables your reqwest or reqwest-middleware-based HTTP clients to:
+- Detect `402 Payment Required` responses
+- Extract payment requirements from the response
+- Sign payments using registered scheme clients
+- Retry the request with the payment header attached
+
+All in all: **automatically pay for resources using the x402 protocol**.
+
+## Features
+
+- Pluggable reqwest middleware using [reqwest-middleware](https://crates.io/crates/reqwest-middleware)
+- Multi-chain support (EVM via EIP-155, Solana)
+- Full V1 and V2 protocol support with automatic detection and handling
+- Multi-scheme architecture supporting various payment schemes
+- Customizable payment selection logic
+- Tracing support (opt-in via `telemetry` feature)
+
+## Installation
+
+Add the dependency:
+
+```toml
+# Cargo.toml
+x402-reqwest = "0.6"
+```
+
+To enable tracing:
+
+```toml
+x402-reqwest = { version = "0.6", features = ["telemetry"] }
+```
+
+## Quickstart
+
+```rust,no_run
+use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+use x402_chain_eip155::V1Eip155ExactClient;
+use alloy_signer_local::PrivateKeySigner;
+use std::sync::Arc;
+use reqwest::Client;
+
+let signer: Arc<PrivateKeySigner> = Arc::new("0x...".parse().unwrap());
+
+// Create an X402 client and register scheme handlers
+let x402_client = X402Client::new()
+    .register(V1Eip155ExactClient::new(signer.clone()));
+
+// Build a reqwest client with x402 middleware
+let http_client = Client::new()
+    .with_payments(x402_client)
+    .build();
+
+// Use the client - payments are handled automatically
+let response = http_client
+    .get("https://api.example.com/protected")
+    .send()
+    .await?;
+
+println!("Status: {}", response.status());
+```
+
+## Registering Scheme Clients
+
+The [`X402Client`] uses a plugin architecture for supporting different payment schemes.
+Register scheme clients for each chain/network you want to support:
+
+```rust,no_run
+use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+use x402_chain_eip155::{V1Eip155ExactClient, V2Eip155ExactClient};
+use x402_chain_solana::{V1SolanaExactClient, V2SolanaExactClient};
+use alloy_signer_local::PrivateKeySigner;
+use solana_client::nonblocking::rpc_client::RpcClient;
+use solana_keypair::Keypair;
+use std::sync::Arc;
+use reqwest::Client;
+
+let evm_signer: Arc<PrivateKeySigner> = Arc::new("0x...".parse().unwrap());
+let solana_keypair = Arc::new(Keypair::from_base58_string("..."));
+let solana_rpc_client = Arc::new(RpcClient::new("https://api.devnet.solana.com"));
+
+let x402_client = X402Client::new()
+    // Register EVM schemes (V1 and V2)
+    .register(V1Eip155ExactClient::new(evm_signer.clone()))
+    .register(V2Eip155ExactClient::new(evm_signer))
+    // Register Solana schemes (V1 and V2)
+    .register(V1SolanaExactClient::new(
+        solana_keypair.clone(),
+        solana_rpc_client.clone(),
+    ))
+    .register(V2SolanaExactClient::new(solana_keypair, solana_rpc_client));
+
+let http_client = Client::new()
+    .with_payments(x402_client)
+    .build();
+```
+
+## How It Works
+
+1. A request is made to a server
+2. If a `402 Payment Required` response is received, the middleware:
+   - Parses the Payment-Required response (V1 body or V2 header)
+   - Finds registered scheme clients that can handle the payment
+   - Selects the best matching payment option
+   - Signs the payment using the scheme client
+   - Retries the request with the payment header attached
+
+## Payment Selection
+
+When multiple payment options are available, the [`X402Client`] uses a [`PaymentSelector`]
+to choose the best option. By default, it uses [`FirstMatch`] which selects the first
+matching scheme.
+
+You can implement custom selection logic:
+
+```rust,ignore
+use x402_reqwest::X402Client;
+use x402_types::scheme::client::{PaymentSelector, PaymentCandidate};
+
+struct MyCustomSelector;
+
+impl PaymentSelector for MyCustomSelector {
+    fn select(&self, candidates: &[PaymentCandidate]) -> Option<&PaymentCandidate> {
+        // Custom selection logic
+        candidates.first()
+    }
+}
+
+let client = X402Client::new()
+    .with_selector(MyCustomSelector);
+```
+
+## Optional Features
+
+- `telemetry`: Enables tracing annotations for richer observability
+- `json`: Enables JSON support for the reqwest-middleware, allowing `.json()` calls when making a HTTP request
+
+Enable them via:
+```toml
+x402-reqwest = { version = "0.6", features = ["telemetry", "json"] }
+```
+
+## Telemetry
+
+When the `telemetry` feature is enabled, the middleware emits structured tracing events for key operations:
+
+- **x402.reqwest.handle**: Span covering the entire middleware handling, including 402 detection and payment retry
+- **x402.reqwest.next**: Span for the underlying HTTP request (both initial and retry)
+- **x402.reqwest.make_payment_headers**: Span for payment header creation and signing
+- **x402.reqwest.parse_payment_required**: Span for parsing 402 responses (V1 body or V2 header)
+
+The telemetry includes:
+- Payment version (V1 or V2)
+- Selected scheme and network
+- Request URLs and response status codes
+- Payment parsing results
+
+This integrates with any `tracing`-compatible subscriber. For OpenTelemetry export, see [x402-types telemetry](https://docs.rs/x402-types/latest/x402_types/util/telemetry/index.html).
+
+## Related Crates
+
+- [x402-types](https://crates.io/crates/x402-types): Core x402 types, facilitator traits, helpers.
+- [x402-axum](https://crates.io/crates/x402-axum): Axum middleware for accepting x402 payments.
+- [x402-chain-eip155](https://crates.io/crates/x402-chain-eip155): EIP-155 chain support for x402.
+- [x402-chain-solana](https://crates.io/crates/x402-chain-solana): Solana chain support for x402.
+
+## License
+
+[Apache-2.0](LICENSE)
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/src/builder.rs b/bbt-x402-facilitator/crates/x402-reqwest/src/builder.rs
new file mode 100644
index 0000000..9712ab3
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/src/builder.rs
@@ -0,0 +1,122 @@
+//! Builder utilities for integrating x402 with reqwest.
+//!
+//! This module provides traits and types for building reqwest clients
+//! with x402 payment middleware.
+
+use reqwest::{Client, ClientBuilder};
+use reqwest_middleware as rqm;
+
+use crate::client::X402Client;
+
+/// Trait for adding x402 payment handling to reqwest clients.
+///
+/// This trait is implemented on [`Client`] and [`ClientBuilder`], allowing
+/// you to create a reqwest client with automatic x402 payment handling.
+///
+/// ## Example
+///
+/// ```rust,no_run
+/// use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+/// use x402_chain_eip155::V1Eip155ExactClient;
+/// use alloy_signer_local::PrivateKeySigner;
+/// use std::sync::Arc;
+/// use reqwest::Client;
+///
+/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
+/// let signer = Arc::new("PRIVATE_KEY".parse::<PrivateKeySigner>().unwrap());
+/// let x402_client = X402Client::new()
+///     .register(V1Eip155ExactClient::new(signer));
+///
+/// let http_client = Client::new()
+///     .with_payments(x402_client)
+///     .build();
+/// # Ok(())
+/// # }
+/// ```
+pub trait ReqwestWithPayments<A, S> {
+    /// Adds x402 payment middleware to the client or builder.
+    ///
+    /// # Arguments
+    ///
+    /// * `x402_client` - The x402 client configured with scheme handlers
+    ///
+    /// # Returns
+    ///
+    /// A builder that can be used to build the final client.
+    fn with_payments(self, x402_client: X402Client<S>) -> ReqwestWithPaymentsBuilder<A, S>;
+}
+
+impl<S> ReqwestWithPayments<Client, S> for Client {
+    fn with_payments(self, x402_client: X402Client<S>) -> ReqwestWithPaymentsBuilder<Client, S> {
+        ReqwestWithPaymentsBuilder {
+            inner: self,
+            x402_client,
+        }
+    }
+}
+
+impl<S> ReqwestWithPayments<ClientBuilder, S> for ClientBuilder {
+    fn with_payments(
+        self,
+        x402_client: X402Client<S>,
+    ) -> ReqwestWithPaymentsBuilder<ClientBuilder, S> {
+        ReqwestWithPaymentsBuilder {
+            inner: self,
+            x402_client,
+        }
+    }
+}
+
+/// Builder for creating a reqwest client with x402 middleware.
+pub struct ReqwestWithPaymentsBuilder<A, S> {
+    inner: A,
+    x402_client: X402Client<S>,
+}
+
+/// Trait for building the final client from a [`ReqwestWithPaymentsBuilder`].
+pub trait ReqwestWithPaymentsBuild {
+    /// The type returned by [`build`]
+    type BuildResult;
+    /// The type returned by [`builder`]
+    type BuilderResult;
+
+    /// Builds the client, consuming the builder.
+    fn build(self) -> Self::BuildResult;
+
+    /// Returns the underlying reqwest client builder with middleware added.
+    fn builder(self) -> Self::BuilderResult;
+}
+
+impl<S> ReqwestWithPaymentsBuild for ReqwestWithPaymentsBuilder<Client, S>
+where
+    X402Client<S>: rqm::Middleware,
+{
+    type BuildResult = rqm::ClientWithMiddleware;
+    type BuilderResult = rqm::ClientBuilder;
+
+    fn build(self) -> Self::BuildResult {
+        self.builder().build()
+    }
+
+    fn builder(self) -> Self::BuilderResult {
+        rqm::ClientBuilder::new(self.inner).with(self.x402_client)
+    }
+}
+
+impl<S> ReqwestWithPaymentsBuild for ReqwestWithPaymentsBuilder<ClientBuilder, S>
+where
+    X402Client<S>: rqm::Middleware,
+{
+    type BuildResult = Result<rqm::ClientWithMiddleware, reqwest::Error>;
+    type BuilderResult = Result<rqm::ClientBuilder, reqwest::Error>;
+
+    fn build(self) -> Self::BuildResult {
+        let builder = self.builder()?;
+        Ok(builder.build())
+    }
+
+    fn builder(self) -> Self::BuilderResult {
+        let client = self.inner.build()?;
+        Ok(rqm::ClientBuilder::new(client).with(self.x402_client))
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/src/client.rs b/bbt-x402-facilitator/crates/x402-reqwest/src/client.rs
new file mode 100644
index 0000000..8298637
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/src/client.rs
@@ -0,0 +1,316 @@
+//! Client-side x402 payment handling for reqwest.
+//!
+//! This module provides the [`X402Client`] which orchestrates scheme clients
+//! and payment selection for automatic payment handling.
+
+use http::{Extensions, HeaderMap, StatusCode};
+use reqwest::{Request, Response};
+use reqwest_middleware as rqm;
+use std::sync::Arc;
+use x402_types::proto;
+use x402_types::proto::{v1, v2};
+use x402_types::scheme::client::{
+    FirstMatch, PaymentCandidate, PaymentSelector, X402Error, X402SchemeClient,
+};
+use x402_types::util::Base64Bytes;
+
+#[cfg(feature = "telemetry")]
+use tracing::{debug, info, instrument, trace};
+
+/// The main x402 client that orchestrates scheme clients and selection.
+///
+/// The [`X402Client`] acts as middleware for reqwest, automatically handling
+/// 402 Payment Required responses by extracting payment requirements, signing
+/// payments, and retrying requests.
+///
+/// ## Creating an X402Client
+///
+/// ```rust
+/// use x402_reqwest::X402Client;
+///
+/// let client = X402Client::new();
+/// ```
+///
+/// ## Registering Scheme Clients
+///
+/// To handle payments on different chains, register scheme clients:
+///
+/// ```rust
+/// use x402_reqwest::X402Client;
+/// use x402_chain_eip155::V1Eip155ExactClient;
+/// use alloy_signer_local::PrivateKeySigner;
+/// use std::sync::Arc;
+///
+/// let private_key_hex = "0x0000000000000000000000000000000000000000000000000000000000000001";
+/// let signer = Arc::new(private_key_hex.parse::<PrivateKeySigner>().unwrap());
+/// let client = X402Client::new()
+///     .register(V1Eip155ExactClient::new(signer));
+/// ```
+///
+/// ## Using with Reqwest
+///
+/// See the [`ReqwestWithPayments`] trait for integrating with reqwest.
+pub struct X402Client<TSelector> {
+    schemes: ClientSchemes,
+    selector: TSelector,
+}
+
+impl X402Client<FirstMatch> {
+    /// Creates a new [`X402Client`] with default settings.
+    ///
+    /// The default client uses [`FirstMatch`] payment selection, which selects
+    /// the first matching payment scheme.
+    pub fn new() -> Self {
+        Self::default()
+    }
+}
+
+impl Default for X402Client<FirstMatch> {
+    fn default() -> Self {
+        Self {
+            schemes: ClientSchemes::default(),
+            selector: FirstMatch,
+        }
+    }
+}
+
+impl<TSelector> X402Client<TSelector> {
+    /// Registers a scheme client for specific chains or networks.
+    ///
+    /// Scheme clients handle the actual payment signing for specific protocols.
+    /// You can register multiple clients for different chains or schemes.
+    ///
+    /// # Arguments
+    ///
+    /// * `scheme` - The scheme client implementation to register
+    ///
+    /// # Returns
+    ///
+    /// A new [`X402Client`] with the additional scheme registered.
+    ///
+    /// # Examples
+    ///
+    /// ```rust
+    /// use x402_reqwest::X402Client;
+    /// use x402_chain_eip155::V1Eip155ExactClient;
+    /// use alloy_signer_local::PrivateKeySigner;
+    /// use std::sync::Arc;
+    ///
+    /// let private_key_hex = "0x0000000000000000000000000000000000000000000000000000000000000001";
+    /// let signer = Arc::new(private_key_hex.parse::<PrivateKeySigner>().unwrap());
+    /// let client = X402Client::new()
+    ///     .register(V1Eip155ExactClient::new(signer));
+    /// ```
+    pub fn register<S>(mut self, scheme: S) -> Self
+    where
+        S: X402SchemeClient + 'static,
+    {
+        self.schemes.push(scheme);
+        self
+    }
+
+    /// Sets a custom payment selector.
+    ///
+    /// By default, [`FirstMatch`] is used which selects the first matching scheme.
+    /// You can implement custom selection logic by providing your own [`PaymentSelector`].
+    ///
+    /// # Examples
+    ///
+    /// ```rust,ignore
+    /// use x402_reqwest::X402Client;
+    /// use x402_types::scheme::client::{FirstMatch, PaymentSelector};
+    ///
+    /// let client = X402Client::new()
+    ///     .with_selector(MyCustomSelector);
+    /// ```
+    pub fn with_selector<P: PaymentSelector + 'static>(self, selector: P) -> X402Client<P> {
+        X402Client {
+            selector,
+            schemes: self.schemes,
+        }
+    }
+}
+
+impl<TSelector> X402Client<TSelector>
+where
+    TSelector: PaymentSelector,
+{
+    /// Creates payment headers from a 402 response.
+    ///
+    /// This method extracts the payment requirements from the response,
+    /// selects the best payment option, signs the payment, and returns
+    /// the appropriate headers to include in the retry request.
+    ///
+    /// # Arguments
+    ///
+    /// * `res` - The 402 Payment Required response
+    ///
+    /// # Returns
+    ///
+    /// A [`HeaderMap`] containing the payment signature header, or an error.
+    ///
+    /// # Errors
+    ///
+    /// Returns [`X402Error::ParseError`] if the response cannot be parsed.
+    /// Returns [`X402Error::NoMatchingPaymentOption`] if no registered scheme
+    /// can handle the payment requirements.
+    #[cfg_attr(
+        feature = "telemetry",
+        instrument(name = "x402.reqwest.make_payment_headers", skip_all, err)
+    )]
+    pub async fn make_payment_headers(&self, res: Response) -> Result<HeaderMap, X402Error> {
+        let payment_required = parse_payment_required(res)
+            .await
+            .ok_or(X402Error::ParseError("Invalid 402 response".to_string()))?;
+        let candidates = self.schemes.candidates(&payment_required);
+
+        // Select the best candidate
+        let selected = self
+            .selector
+            .select(&candidates)
+            .ok_or(X402Error::NoMatchingPaymentOption)?;
+
+        #[cfg(feature = "telemetry")]
+        debug!(
+            scheme = %selected.scheme,
+            chain_id = %selected.chain_id,
+            "Selected payment scheme"
+        );
+
+        let signed_payload = selected.sign().await?;
+        let header_name = match &payment_required {
+            proto::PaymentRequired::V1(_) => "X-Payment",
+            proto::PaymentRequired::V2(_) => "Payment-Signature",
+        };
+        let headers = {
+            let mut headers = HeaderMap::new();
+            headers.insert(header_name, signed_payload.parse().unwrap());
+            headers
+        };
+
+        Ok(headers)
+    }
+}
+
+/// Internal collection of registered scheme clients.
+#[derive(Default)]
+pub struct ClientSchemes(Vec<Arc<dyn X402SchemeClient>>);
+
+impl ClientSchemes {
+    /// Adds a scheme client to the collection.
+    pub fn push<T: X402SchemeClient + 'static>(&mut self, client: T) {
+        self.0.push(Arc::new(client));
+    }
+
+    /// Finds all payment candidates that can handle the given payment requirements.
+    pub fn candidates(&self, payment_required: &proto::PaymentRequired) -> Vec<PaymentCandidate> {
+        let mut candidates = vec![];
+        for client in self.0.iter() {
+            let accepted = client.accept(payment_required);
+            candidates.extend(accepted);
+        }
+        candidates
+    }
+}
+
+/// Runs the next middleware or HTTP client with optional telemetry instrumentation.
+#[cfg_attr(
+    feature = "telemetry",
+    instrument(name = "x402.reqwest.next", skip_all)
+)]
+async fn run_next(
+    next: rqm::Next<'_>,
+    req: Request,
+    extensions: &mut Extensions,
+) -> rqm::Result<Response> {
+    next.run(req, extensions).await
+}
+
+#[async_trait::async_trait]
+impl<TSelector> rqm::Middleware for X402Client<TSelector>
+where
+    TSelector: PaymentSelector + Send + Sync + 'static,
+{
+    /// Handles a request, automatically handling 402 responses.
+    ///
+    /// When a 402 response is received, this middleware:
+    /// 1. Extracts payment requirements from the response
+    /// 2. Signs a payment using registered scheme clients
+    /// 3. Retries the request with the payment header
+    #[cfg_attr(
+        feature = "telemetry",
+        instrument(name = "x402.reqwest.handle", skip_all, err)
+    )]
+    async fn handle(
+        &self,
+        req: Request,
+        extensions: &mut Extensions,
+        next: rqm::Next<'_>,
+    ) -> rqm::Result<Response> {
+        let retry_req = req.try_clone();
+        let res = run_next(next.clone(), req, extensions).await?;
+
+        if res.status() != StatusCode::PAYMENT_REQUIRED {
+            #[cfg(feature = "telemetry")]
+            trace!(status = ?res.status(), "No payment required, returning response");
+            return Ok(res);
+        }
+
+        #[cfg(feature = "telemetry")]
+        info!(url = ?res.url(), "Received 402 Payment Required, processing payment");
+
+        let headers = self
+            .make_payment_headers(res)
+            .await
+            .map_err(|e| rqm::Error::Middleware(e.into()))?;
+
+        // Retry with payment
+        let mut retry = retry_req.ok_or(rqm::Error::Middleware(
+            X402Error::RequestNotCloneable.into(),
+        ))?;
+        retry.headers_mut().extend(headers);
+
+        #[cfg(feature = "telemetry")]
+        trace!(url = ?retry.url(), "Retrying request with payment headers");
+
+        run_next(next, retry, extensions).await
+    }
+}
+
+/// Parses a 402 Payment Required response into a [`proto::PaymentRequired`].
+///
+/// Supports both V1 (JSON body) and V2 (base64-encoded header) formats.
+#[cfg_attr(
+    feature = "telemetry",
+    instrument(name = "x402.reqwest.parse_payment_required", skip(response))
+)]
+pub async fn parse_payment_required(response: Response) -> Option<proto::PaymentRequired> {
+    // Try V2 format first (header-based)
+    let headers = response.headers();
+    let v2_payment_required = headers
+        .get("Payment-Required")
+        .and_then(|h| Base64Bytes::from(h.as_bytes()).decode().ok())
+        .and_then(|b| serde_json::from_slice::<v2::PaymentRequired>(&b).ok());
+    if let Some(v2_payment_required) = v2_payment_required {
+        #[cfg(feature = "telemetry")]
+        debug!("Parsed V2 payment required from header");
+        return Some(proto::PaymentRequired::V2(v2_payment_required));
+    }
+
+    // Fall back to V1 format (body-based)
+    let v1_payment_required = response
+        .bytes()
+        .await
+        .ok()
+        .and_then(|b| serde_json::from_slice::<v1::PaymentRequired>(&b).ok());
+    if let Some(v1_payment_required) = v1_payment_required {
+        #[cfg(feature = "telemetry")]
+        debug!("Parsed V1 payment required from body");
+        return Some(proto::PaymentRequired::V1(v1_payment_required));
+    }
+
+    #[cfg(feature = "telemetry")]
+    debug!("Could not parse payment required from response");
+
+    None
+}
diff --git a/bbt-x402-facilitator/crates/x402-reqwest/src/lib.rs b/bbt-x402-facilitator/crates/x402-reqwest/src/lib.rs
new file mode 100644
index 0000000..3ad744b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-reqwest/src/lib.rs
@@ -0,0 +1,60 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Reqwest middleware for automatic [x402](https://www.x402.org) payment handling.
+//!
+//! This crate provides a [`X402Client`] that can be used as a `reqwest` middleware
+//! to automatically handle `402 Payment Required` responses. When a request receives
+//! a 402 response, the middleware extracts payment requirements, signs a payment,
+//! and retries the request with the payment header.
+//!
+//! ## Quickstart
+//!
+//! ```rust,ignore
+//! use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+//! use x402_chain_eip155::V1Eip155ExactClient;
+//! use alloy_signer_local::PrivateKeySigner;
+//! use std::sync::Arc;
+//! use reqwest::Client;
+//!
+//! // Create an X402 client and register scheme clients
+//! let signer = Arc::new("PRIVATE_KEY".parse::<PrivateKeySigner>().unwrap());
+//! let x402_client = X402Client::new()
+//!     .register(V1Eip155ExactClient::new(signer));
+//!
+//! // Build a reqwest client with x402 middleware
+//! let http_client = Client::new()
+//!     .with_payments(x402_client)
+//!     .build();
+//!
+//! // Use the client - payments are handled automatically
+//! let response = http_client
+//!     .get("https://api.example.com/protected")
+//!     .send()
+//!     .await?;
+//! ```
+//!
+//! ## Registering Scheme Clients
+//!
+//! The [`X402Client`] uses a plugin architecture for supporting different payment schemes.
+//! Register scheme clients for each chain/network you want to support:
+//!
+//! - **[`V1Eip155ExactClient`]** - EIP-155 chains, x402 V1 protocol, "exact" payment scheme
+//! - **[`V2Eip155ExactClient`]** - EIP-155 chains, x402 V2 protocol, "exact" payment scheme
+//! - **[`V1SolanaExactClient`]** - Solana chains, x402 V1 protocol, "exact" payment scheme
+//! - **[`V2SolanaExactClient`]** - Solana chains, x402 V2 protocol, "exact" payment scheme
+//!
+//! See [`X402Client::register`] for more details on registering scheme clients.
+//!
+//! ## Payment Selection
+//!
+//! When multiple payment options are available, the [`X402Client`] uses a [`PaymentSelector`]
+//! to choose the best option. By default, it uses [`FirstMatch`] which selects the first
+//! matching scheme. You can implement custom selection logic by providing your own selector.
+//!
+//! See [`X402Client::with_selector`] for custom payment selection.
+
+mod builder;
+mod client;
+
+pub use builder::*;
+pub use client::*;
diff --git a/bbt-x402-facilitator/crates/x402-types/Cargo.toml b/bbt-x402-facilitator/crates/x402-types/Cargo.toml
new file mode 100644
index 0000000..d5e79c9
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/Cargo.toml
@@ -0,0 +1,41 @@
+[package]
+name = "x402-types"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+categories.workspace = true
+keywords.workspace = true
+documentation = "https://docs.rs/x402-types"
+description = "Core types for x402 payments: chain identifiers, protocol messages, and facilitator traits"
+readme = "README.md"
+
+[package.metadata.docs.rs]
+all-features = true
+
+[dependencies]
+thiserror = { workspace = true }
+serde = { workspace = true }
+serde_json = { workspace = true }
+async-trait = { workspace = true }
+alloy-primitives = { workspace = true }
+
+base64 = { version = "0.22.1" }
+rust_decimal = { version = "1.39.0" }
+regex = { version = "1.12.2" }
+serde_with = { version = "3.16.1" }
+
+# CLI
+clap = { workspace = true, optional = true }
+
+# Tracing
+tracing = { workspace = true, optional = true }
+
+[features]
+default = []
+telemetry = ["dep:tracing"]
+cli = ["dep:clap"]
+full = ["cli", "telemetry"]
diff --git a/bbt-x402-facilitator/crates/x402-types/README.md b/bbt-x402-facilitator/crates/x402-types/README.md
new file mode 100644
index 0000000..b45ae44
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/README.md
@@ -0,0 +1,140 @@
+# x402-types
+
+Core types for the x402 payment protocol.
+
+This crate provides the foundational types used throughout the x402 ecosystem for implementing HTTP 402 Payment Required flows. It is designed to be blockchain-agnostic, with chain-specific implementations provided by separate crates.
+
+## Overview
+
+The x402 protocol enables micropayments over HTTP by leveraging the 402 Payment Required status code. When a client requests a paid resource, the server responds with payment requirements. The client signs a payment authorization, which is verified and settled by a facilitator.
+
+```text
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Client â”‚ â”€â”€1â”€â”€â–¶  â”‚ Server â”‚ â”€â”€2â”€â”€â–¶  â”‚ Facilitator â”‚
+â”‚        â”‚ â—€â”€â”€4â”€â”€  â”‚        â”‚ â—€â”€â”€3â”€â”€  â”‚             â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+1. Request paid resource
+2. Verify payment with facilitator
+3. Payment valid / settled
+4. Return resource (or 402 Payment Required)
+```
+
+## Installation
+
+Add to your `Cargo.toml`:
+
+```toml
+[dependencies]
+x402-types = "0.1"
+```
+
+With telemetry support:
+
+```toml
+[dependencies]
+x402-types = { version = "0.1", features = ["telemetry"] }
+```
+
+## Modules
+
+| Module        | Description                                                                        |
+|---------------|------------------------------------------------------------------------------------|
+| `chain`       | Blockchain identifiers and provider abstractions (CAIP-2 chain IDs)                |
+| `config`      | Server configuration, CLI parsing, RPC config, and environment variable resolution |
+| `facilitator` | Core trait for payment verification and settlement                                 |
+| `networks`    | Registry of well-known blockchain networks                                         |
+| `proto`       | Wire format types for protocol messages (V1 and V2)                                |
+| `scheme`      | Payment scheme system for extensible payment methods                               |
+| `timestamp`   | Unix timestamp utilities for payment authorization windows                         |
+| `util`        | Helper types (base64, string literals, money amounts)                              |
+
+## Protocol Versions
+
+The crate supports two protocol versions:
+
+- **V1** (`proto::v1`): x402 protocol v1
+- **V2** (`proto::v2`): x402 protocol v2
+
+## Key Types
+
+### Chain Identifiers
+
+```rust
+use x402_types::chain::ChainId;
+
+// Parse a CAIP-2 chain ID
+let chain_id: ChainId = "eip155:8453".parse().unwrap();
+assert_eq!(chain_id.namespace(), "eip155");
+assert_eq!(chain_id.reference(), "8453");
+
+// Convert from network name (V1 compatibility)
+let chain_id = ChainId::from_network_name("base").unwrap();
+```
+
+### Payment Requirements (V2)
+
+```rust
+use x402_types::proto::v2::{PaymentRequirements, PriceTag};
+
+// Payment requirements returned in 402 response
+let requirements = PaymentRequirements {
+    scheme: "exact".to_string(),
+    chain_id: "eip155:8453".parse().unwrap(),
+    pay_to: "0x...".to_string(),
+    max_amount_required: "1000000".to_string(), // in smallest units
+    resource: "https://api.example.com/premium".to_string(),
+    // ... other fields
+};
+```
+
+### Facilitator Trait
+
+```rust
+use x402_types::facilitator::Facilitator;
+use x402_types::proto::v2::{VerifyRequest, VerifyResponse, SettleRequest, SettleResponse};
+
+// Implement for your payment verification service
+#[async_trait::async_trait]
+impl Facilitator for MyFacilitator {
+    async fn verify(&self, request: VerifyRequest) -> Result<VerifyResponse, Error> {
+        // Verify payment authorization
+    }
+    
+    async fn settle(&self, request: SettleRequest) -> Result<SettleResponse, Error> {
+        // Settle the payment on-chain
+    }
+}
+```
+
+### Timestamps
+
+```rust
+use x402_types::timestamp::UnixTimestamp;
+
+// Create timestamp for payment validity window
+let valid_after = UnixTimestamp::now();
+let valid_before = valid_after + std::time::Duration::from_secs(3600);
+```
+
+## Related Crates
+
+| Crate                                                                | Description                                    |
+|----------------------------------------------------------------------|------------------------------------------------|
+| [`x402-chain-eip155`](https://crates.io/x402-chain-eip155)           | EVM chain support (Ethereum, Base, etc.)       |
+| [`x402-chain-solana`](https://crates.io/x402-chain-solana)           | Solana blockchain support                      |
+| [`x402-chain-aptos`](https://crates.io/x402-chain-aptos)             | Aptos blockchain support                       |
+| [`x402-axum`](https://crates.io/x402-axum)                           | Axum middleware for payment-gated endpoints    |
+| [`x402-reqwest`](https://crates.io/x402-reqwest)                     | Reqwest client with automatic payment handling |
+| [`x402-facilitator-local`](https://crates.io/x402-facilitator-local) | Local facilitator implementation               |
+
+## Feature Flags
+
+| Feature     | Description                                                     |
+|-------------|-----------------------------------------------------------------|
+| `cli`       | Enables CLI argument parsing via clap for configuration loading |
+| `telemetry` | Enables tracing instrumentation for debugging and monitoring    |
+
+## License
+
+Apache-2.0
diff --git a/bbt-x402-facilitator/crates/x402-types/src/chain/chain_id.rs b/bbt-x402-facilitator/crates/x402-types/src/chain/chain_id.rs
new file mode 100644
index 0000000..29073d0
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/chain/chain_id.rs
@@ -0,0 +1,590 @@
+//! CAIP-2 chain identifier types for blockchain-agnostic identification.
+//!
+//! This module implements the [CAIP-2](https://standards.chainagnostic.org/CAIPs/caip-2) standard
+//! for identifying blockchain networks in a chain-agnostic way. A CAIP-2 chain ID
+//! consists of two parts separated by a colon:
+//!
+//! - **Namespace**: The blockchain ecosystem (e.g., `eip155` for EVM, `solana` for Solana)
+//! - **Reference**: The chain-specific identifier (e.g., `8453` for Base, `137` for Polygon)
+//!
+//! # Examples
+//!
+//! ```
+//! use x402_types::chain::ChainId;
+//!
+//! // Create a chain ID for Base mainnet
+//! let base = ChainId::new("eip155", "8453");
+//! assert_eq!(base.to_string(), "eip155:8453");
+//!
+//! // Parse from string
+//! let polygon: ChainId = "eip155:137".parse().unwrap();
+//! assert_eq!(polygon.namespace, "eip155");
+//! assert_eq!(polygon.reference, "137");
+//! ```
+
+use serde::{Deserialize, Deserializer, Serialize, Serializer, de};
+use std::collections::HashSet;
+use std::fmt;
+use std::str::FromStr;
+
+use crate::networks;
+
+/// A CAIP-2 compliant blockchain identifier.
+///
+/// Chain IDs uniquely identify blockchain networks across different ecosystems.
+/// The format is `namespace:reference` where:
+///
+/// - `namespace` identifies the blockchain family (e.g., `eip155`, `solana`)
+/// - `reference` identifies the specific chain within that family
+///
+/// # Serialization
+///
+/// Serializes to/from a colon-separated string: `"eip155:8453"`
+///
+/// # Example
+///
+/// ```
+/// use x402_types::chain::ChainId;
+///
+/// let chain = ChainId::new("eip155", "8453");
+/// let json = serde_json::to_string(&chain).unwrap();
+/// assert_eq!(json, "\"eip155:8453\"");
+/// ```
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+pub struct ChainId {
+    /// The blockchain namespace (e.g., `eip155` for EVM chains, `solana` for Solana).
+    pub namespace: String,
+    /// The chain-specific reference (e.g., `8453` for Base, `137` for Polygon).
+    pub reference: String,
+}
+
+impl ChainId {
+    /// Creates a new chain ID from namespace and reference components.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::ChainId;
+    ///
+    /// let base = ChainId::new("eip155", "8453");
+    /// assert_eq!(base.namespace, "eip155");
+    /// assert_eq!(base.reference, "8453");
+    /// ```
+    pub fn new<N: Into<String>, R: Into<String>>(namespace: N, reference: R) -> Self {
+        Self {
+            namespace: namespace.into(),
+            reference: reference.into(),
+        }
+    }
+
+    /// Returns the namespace component of the chain ID.
+    pub fn namespace(&self) -> &str {
+        &self.namespace
+    }
+
+    /// Returns the reference component of the chain ID.
+    pub fn reference(&self) -> &str {
+        &self.reference
+    }
+
+    /// Creates a chain ID from a well-known network name.
+    ///
+    /// This method looks up the network name in the registry of known networks
+    /// (see [`crate::networks`]) and returns the corresponding chain ID.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::ChainId;
+    ///
+    /// let base = ChainId::from_network_name("base").unwrap();
+    /// assert_eq!(base.to_string(), "eip155:8453");
+    ///
+    /// assert!(ChainId::from_network_name("unknown").is_none());
+    /// ```
+    pub fn from_network_name(network_name: &str) -> Option<Self> {
+        networks::chain_id_by_network_name(network_name).cloned()
+    }
+
+    /// Returns the well-known network name for this chain ID, if any.
+    ///
+    /// This is the reverse of [`ChainId::from_network_name`].
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::ChainId;
+    ///
+    /// let base = ChainId::new("eip155", "8453");
+    /// assert_eq!(base.as_network_name(), Some("base"));
+    ///
+    /// let unknown = ChainId::new("eip155", "999999");
+    /// assert!(unknown.as_network_name().is_none());
+    /// ```
+    pub fn as_network_name(&self) -> Option<&'static str> {
+        networks::network_name_by_chain_id(self)
+    }
+}
+
+impl fmt::Display for ChainId {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}:{}", self.namespace, self.reference)
+    }
+}
+
+impl From<ChainId> for String {
+    fn from(value: ChainId) -> Self {
+        value.to_string()
+    }
+}
+
+/// Error returned when parsing an invalid chain ID string.
+///
+/// A valid chain ID must be in the format `namespace:reference` where both
+/// components are non-empty strings.
+#[derive(Debug, thiserror::Error)]
+#[error("Invalid chain id format {0}")]
+pub struct ChainIdFormatError(String);
+
+impl FromStr for ChainId {
+    type Err = ChainIdFormatError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let parts: Vec<&str> = s.splitn(2, ':').collect();
+        if parts.len() != 2 {
+            return Err(ChainIdFormatError(s.into()));
+        }
+        Ok(ChainId {
+            namespace: parts[0].into(),
+            reference: parts[1].into(),
+        })
+    }
+}
+
+impl Serialize for ChainId {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for ChainId {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        ChainId::from_str(&s).map_err(de::Error::custom)
+    }
+}
+
+/// A pattern for matching chain IDs.
+///
+/// Chain ID patterns allow flexible matching of blockchain networks:
+///
+/// - **Wildcard**: Matches any chain within a namespace (e.g., `eip155:*` matches all EVM chains)
+/// - **Exact**: Matches a specific chain (e.g., `eip155:8453` matches only Base)
+/// - **Set**: Matches any chain from a set (e.g., `eip155:{1,8453,137}` matches Ethereum, Base, or Polygon)
+///
+/// # Serialization
+///
+/// Patterns serialize to human-readable strings:
+/// - Wildcard: `"eip155:*"`
+/// - Exact: `"eip155:8453"`
+/// - Set: `"eip155:{1,8453,137}"`
+///
+/// # Example
+///
+/// ```
+/// use x402_types::chain::{ChainId, ChainIdPattern};
+///
+/// // Match all EVM chains
+/// let all_evm = ChainIdPattern::wildcard("eip155");
+/// assert!(all_evm.matches(&ChainId::new("eip155", "8453")));
+/// assert!(all_evm.matches(&ChainId::new("eip155", "137")));
+/// assert!(!all_evm.matches(&ChainId::new("solana", "mainnet")));
+///
+/// // Match specific chain
+/// let base_only = ChainIdPattern::exact("eip155", "8453");
+/// assert!(base_only.matches(&ChainId::new("eip155", "8453")));
+/// assert!(!base_only.matches(&ChainId::new("eip155", "137")));
+/// ```
+#[derive(Debug, Clone)]
+pub enum ChainIdPattern {
+    /// Matches any chain within the specified namespace.
+    Wildcard {
+        /// The namespace to match (e.g., `eip155`, `solana`).
+        namespace: String,
+    },
+    /// Matches exactly one specific chain.
+    Exact {
+        /// The namespace of the chain.
+        namespace: String,
+        /// The reference of the chain.
+        reference: String,
+    },
+    /// Matches any chain from a set of references within a namespace.
+    Set {
+        /// The namespace of the chains.
+        namespace: String,
+        /// The set of chain references to match.
+        references: HashSet<String>,
+    },
+}
+
+impl ChainIdPattern {
+    /// Creates a wildcard pattern that matches any chain in the given namespace.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::{ChainId, ChainIdPattern};
+    ///
+    /// let pattern = ChainIdPattern::wildcard("eip155");
+    /// assert!(pattern.matches(&ChainId::new("eip155", "1")));
+    /// assert!(pattern.matches(&ChainId::new("eip155", "8453")));
+    /// ```
+    pub fn wildcard<S: Into<String>>(namespace: S) -> Self {
+        Self::Wildcard {
+            namespace: namespace.into(),
+        }
+    }
+
+    /// Creates an exact pattern that matches only the specified chain.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::{ChainId, ChainIdPattern};
+    ///
+    /// let pattern = ChainIdPattern::exact("eip155", "8453");
+    /// assert!(pattern.matches(&ChainId::new("eip155", "8453")));
+    /// assert!(!pattern.matches(&ChainId::new("eip155", "137")));
+    /// ```
+    pub fn exact<N: Into<String>, R: Into<String>>(namespace: N, reference: R) -> Self {
+        Self::Exact {
+            namespace: namespace.into(),
+            reference: reference.into(),
+        }
+    }
+
+    /// Creates a set pattern that matches any chain from the given set of references.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::chain::{ChainId, ChainIdPattern};
+    /// use std::collections::HashSet;
+    ///
+    /// let refs: HashSet<String> = ["1", "8453", "137"].iter().map(|s| s.to_string()).collect();
+    /// let pattern = ChainIdPattern::set("eip155", refs);
+    /// assert!(pattern.matches(&ChainId::new("eip155", "8453")));
+    /// assert!(!pattern.matches(&ChainId::new("eip155", "42")));
+    /// ```
+    pub fn set<N: Into<String>>(namespace: N, references: HashSet<String>) -> Self {
+        Self::Set {
+            namespace: namespace.into(),
+            references,
+        }
+    }
+
+    /// Check if a `ChainId` matches this pattern.
+    ///
+    /// - `Wildcard` matches any chain with the same namespace
+    /// - `Exact` matches only if both namespace and reference are equal
+    /// - `Set` matches if the namespace is equal and the reference is in the set
+    pub fn matches(&self, chain_id: &ChainId) -> bool {
+        match self {
+            ChainIdPattern::Wildcard { namespace } => chain_id.namespace == *namespace,
+            ChainIdPattern::Exact {
+                namespace,
+                reference,
+            } => chain_id.namespace == *namespace && chain_id.reference == *reference,
+            ChainIdPattern::Set {
+                namespace,
+                references,
+            } => chain_id.namespace == *namespace && references.contains(&chain_id.reference),
+        }
+    }
+
+    /// Returns the namespace of this pattern.
+    #[allow(dead_code)]
+    pub fn namespace(&self) -> &str {
+        match self {
+            ChainIdPattern::Wildcard { namespace } => namespace,
+            ChainIdPattern::Exact { namespace, .. } => namespace,
+            ChainIdPattern::Set { namespace, .. } => namespace,
+        }
+    }
+}
+
+impl fmt::Display for ChainIdPattern {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            ChainIdPattern::Wildcard { namespace } => write!(f, "{}:*", namespace),
+            ChainIdPattern::Exact {
+                namespace,
+                reference,
+            } => write!(f, "{}:{}", namespace, reference),
+            ChainIdPattern::Set {
+                namespace,
+                references,
+            } => {
+                let refs: Vec<&str> = references.iter().map(|s| s.as_ref()).collect();
+                write!(f, "{}:{{{}}}", namespace, refs.join(","))
+            }
+        }
+    }
+}
+
+impl FromStr for ChainIdPattern {
+    type Err = ChainIdFormatError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let (namespace, rest) = s.split_once(':').ok_or(ChainIdFormatError(s.into()))?;
+
+        if namespace.is_empty() {
+            return Err(ChainIdFormatError(s.into()));
+        }
+
+        // Wildcard: eip155:*
+        if rest == "*" {
+            return Ok(ChainIdPattern::wildcard(namespace));
+        }
+
+        // Set: eip155:{1,2,3}
+        if let Some(inner) = rest.strip_prefix('{').and_then(|r| r.strip_suffix('}')) {
+            let mut references = HashSet::new();
+
+            for item in inner.split(',') {
+                let item = item.trim();
+                if item.is_empty() {
+                    return Err(ChainIdFormatError(s.into()));
+                }
+                references.insert(item.into());
+            }
+
+            if references.is_empty() {
+                return Err(ChainIdFormatError(s.into()));
+            }
+
+            return Ok(ChainIdPattern::set(namespace, references));
+        }
+
+        // Exact: eip155:1
+        if rest.is_empty() {
+            return Err(ChainIdFormatError(s.into()));
+        }
+
+        Ok(ChainIdPattern::exact(namespace, rest))
+    }
+}
+
+impl Serialize for ChainIdPattern {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for ChainIdPattern {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        ChainIdPattern::from_str(&s).map_err(de::Error::custom)
+    }
+}
+
+impl From<ChainId> for ChainIdPattern {
+    fn from(chain_id: ChainId) -> Self {
+        ChainIdPattern::exact(chain_id.namespace, chain_id.reference)
+    }
+}
+
+impl From<ChainIdPattern> for Vec<ChainIdPattern> {
+    fn from(value: ChainIdPattern) -> Self {
+        vec![value]
+    }
+}
+
+impl From<ChainId> for Vec<ChainId> {
+    fn from(value: ChainId) -> Self {
+        vec![value]
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::networks::{chain_id_by_network_name, network_name_by_chain_id};
+
+    #[test]
+    fn test_chain_id_serialize_eip155() {
+        let chain_id = ChainId::new("eip155", "1");
+        let serialized = serde_json::to_string(&chain_id).unwrap();
+        assert_eq!(serialized, "\"eip155:1\"");
+    }
+
+    #[test]
+    fn test_chain_id_serialize_solana() {
+        let chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+        let serialized = serde_json::to_string(&chain_id).unwrap();
+        assert_eq!(serialized, "\"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"");
+    }
+
+    #[test]
+    fn test_chain_id_deserialize_eip155() {
+        let chain_id: ChainId = serde_json::from_str("\"eip155:1\"").unwrap();
+        assert_eq!(chain_id.namespace, "eip155");
+        assert_eq!(chain_id.reference, "1");
+    }
+
+    #[test]
+    fn test_chain_id_deserialize_solana() {
+        let chain_id: ChainId =
+            serde_json::from_str("\"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"").unwrap();
+        assert_eq!(chain_id.namespace, "solana");
+        assert_eq!(chain_id.reference, "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+    }
+
+    #[test]
+    fn test_chain_id_roundtrip_eip155() {
+        let original = ChainId::new("eip155", "8453");
+        // let original = ChainId::eip155(8453);
+        let serialized = serde_json::to_string(&original).unwrap();
+        let deserialized: ChainId = serde_json::from_str(&serialized).unwrap();
+        assert_eq!(original, deserialized);
+    }
+
+    #[test]
+    fn test_chain_id_roundtrip_solana() {
+        let original = ChainId::new("solana", "devnet");
+        let serialized = serde_json::to_string(&original).unwrap();
+        let deserialized: ChainId = serde_json::from_str(&serialized).unwrap();
+        assert_eq!(original, deserialized);
+    }
+
+    #[test]
+    fn test_chain_id_deserialize_invalid_format() {
+        let result: Result<ChainId, _> = serde_json::from_str("\"invalid\"");
+        assert!(result.is_err());
+    }
+
+    #[test]
+    fn test_chain_id_deserialize_unknown_namespace() {
+        let result: Result<ChainId, _> = serde_json::from_str("\"unknown:1\"");
+        assert!(result.is_ok());
+    }
+
+    #[test]
+    fn test_pattern_wildcard_matches() {
+        let pattern = ChainIdPattern::wildcard("eip155");
+        assert!(pattern.matches(&ChainId::new("eip155", "1")));
+        assert!(pattern.matches(&ChainId::new("eip155", "8453")));
+        assert!(pattern.matches(&ChainId::new("eip155", "137")));
+        assert!(!pattern.matches(&ChainId::new("solana", "mainnet")));
+    }
+
+    #[test]
+    fn test_pattern_exact_matches() {
+        let pattern = ChainIdPattern::exact("eip155", "1");
+        assert!(pattern.matches(&ChainId::new("eip155", "1")));
+        assert!(!pattern.matches(&ChainId::new("eip155", "8453")));
+        assert!(!pattern.matches(&ChainId::new("solana", "1")));
+    }
+
+    #[test]
+    fn test_pattern_set_matches() {
+        let references: HashSet<String> = vec!["1", "8453", "137"]
+            .into_iter()
+            .map(String::from)
+            .collect();
+        let pattern = ChainIdPattern::set("eip155", references);
+        assert!(pattern.matches(&ChainId::new("eip155", "1")));
+        assert!(pattern.matches(&ChainId::new("eip155", "8453")));
+        assert!(pattern.matches(&ChainId::new("eip155", "137")));
+        assert!(!pattern.matches(&ChainId::new("eip155", "42")));
+        assert!(!pattern.matches(&ChainId::new("solana", "1")));
+    }
+
+    #[test]
+    fn test_pattern_namespace() {
+        let wildcard = ChainIdPattern::wildcard("eip155");
+        assert_eq!(wildcard.namespace(), "eip155");
+
+        let exact = ChainIdPattern::exact("solana", "mainnet");
+        assert_eq!(exact.namespace(), "solana");
+
+        let references: HashSet<String> = vec!["1"].into_iter().map(String::from).collect();
+        let set = ChainIdPattern::set("eip155", references);
+        assert_eq!(set.namespace(), "eip155");
+    }
+
+    #[test]
+    fn test_chain_id_from_network_name() {
+        let base = chain_id_by_network_name("base").unwrap();
+        assert_eq!(base.namespace, "eip155");
+        assert_eq!(base.reference, "8453");
+
+        let base_sepolia = chain_id_by_network_name("base-sepolia").unwrap();
+        assert_eq!(base_sepolia.namespace, "eip155");
+        assert_eq!(base_sepolia.reference, "84532");
+
+        let polygon = chain_id_by_network_name("polygon").unwrap();
+        assert_eq!(polygon.namespace, "eip155");
+        assert_eq!(polygon.reference, "137");
+
+        let celo = chain_id_by_network_name("celo").unwrap();
+        assert_eq!(celo.namespace, "eip155");
+        assert_eq!(celo.reference, "42220");
+
+        let solana = chain_id_by_network_name("solana").unwrap();
+        assert_eq!(solana.namespace, "solana");
+        assert_eq!(solana.reference, "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+
+        assert!(chain_id_by_network_name("unknown").is_none());
+    }
+
+    #[test]
+    fn test_network_name_by_chain_id() {
+        let chain_id = ChainId::new("eip155", "8453");
+        let network_name = network_name_by_chain_id(&chain_id).unwrap();
+        assert_eq!(network_name, "base");
+
+        let celo_chain_id = ChainId::new("eip155", "42220");
+        let network_name = network_name_by_chain_id(&celo_chain_id).unwrap();
+        assert_eq!(network_name, "celo");
+
+        let celo_sepolia_chain_id = ChainId::new("eip155", "11142220");
+        let network_name = network_name_by_chain_id(&celo_sepolia_chain_id).unwrap();
+        assert_eq!(network_name, "celo-sepolia");
+
+        let solana_chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+        let network_name = network_name_by_chain_id(&solana_chain_id).unwrap();
+        assert_eq!(network_name, "solana");
+
+        let unknown_chain_id = ChainId::new("eip155", "999999");
+        assert!(network_name_by_chain_id(&unknown_chain_id).is_none());
+    }
+
+    #[test]
+    fn test_chain_id_as_network_name() {
+        let chain_id = ChainId::new("eip155", "8453");
+        assert_eq!(chain_id.as_network_name(), Some("base"));
+
+        let celo_chain_id = ChainId::new("eip155", "42220");
+        assert_eq!(celo_chain_id.as_network_name(), Some("celo"));
+
+        let solana_chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+        assert_eq!(solana_chain_id.as_network_name(), Some("solana"));
+
+        let unknown_chain_id = ChainId::new("eip155", "999999");
+        assert!(unknown_chain_id.as_network_name().is_none());
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/chain/mod.rs b/bbt-x402-facilitator/crates/x402-types/src/chain/mod.rs
new file mode 100644
index 0000000..fc860d8
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/chain/mod.rs
@@ -0,0 +1,158 @@
+//! Blockchain-specific types and providers for x402 payment processing.
+//!
+//! This module provides abstractions for interacting with different blockchain networks
+//! in the x402 protocol.
+//!
+//! # Architecture
+//!
+//! The module is organized around the concept of chain providers and chain identifiers:
+//!
+//! - [`ChainId`] - A CAIP-2 compliant chain identifier (e.g., `eip155:8453` for Base)
+//! - [`ChainIdPattern`] - Pattern matching for chain IDs (exact, wildcard, or set)
+//! - [`ChainRegistry`] - Registry of configured chain providers
+
+mod chain_id;
+
+pub use chain_id::*;
+
+use std::collections::HashMap;
+use std::sync::Arc;
+
+/// Asynchronously constructs an instance of `Self` from a configuration type.
+///
+/// This trait provides a generic mechanism for initializing structs from their
+/// corresponding configuration types. It is used throughout the x402-rs crate
+/// to build providers, registries, and other components from configuration files.
+///
+/// # Type Parameters
+///
+/// - `TConfig` - The configuration type that `Self` can be constructed from
+///
+/// Return an error if:
+/// - Configuration validation fails
+/// - Required external connections (RPC, etc.) cannot be established
+/// - Configuration values are invalid or missing
+#[async_trait::async_trait]
+pub trait FromConfig<TConfig>
+where
+    Self: Sized,
+{
+    async fn from_config(config: &TConfig) -> Result<Self, Box<dyn std::error::Error>>;
+}
+
+/// Common operations available on all chain providers.
+///
+/// This trait provides a unified interface for querying chain provider metadata
+/// regardless of the underlying blockchain type.
+pub trait ChainProviderOps {
+    /// Returns the addresses of all configured signers for this chain.
+    ///
+    /// For EVM chains, these are Ethereum addresses (0x-prefixed hex).
+    /// For Solana, these are base58-encoded public keys.
+    fn signer_addresses(&self) -> Vec<String>;
+
+    /// Returns the CAIP-2 chain identifier for this provider.
+    fn chain_id(&self) -> ChainId;
+}
+
+impl<T: ChainProviderOps> ChainProviderOps for Arc<T> {
+    fn signer_addresses(&self) -> Vec<String> {
+        (**self).signer_addresses()
+    }
+    fn chain_id(&self) -> ChainId {
+        (**self).chain_id()
+    }
+}
+
+/// Registry of configured chain providers indexed by chain ID.
+///
+/// The registry is built from configuration and provides lookup methods
+/// for finding providers by exact chain ID or by pattern matching.
+///
+/// # Type Parameters
+///
+/// - `P` - The chain provider type (e.g., [`ChainProvider`] or a custom provider type)
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_rs::chain::{ChainRegistry, ChainIdPattern, ChainProvider};
+/// use x402_rs::config::Config;
+///
+/// let config = Config::load()?;
+/// let registry = ChainRegistry::from_config(config.chains()).await?;
+///
+/// // Find provider for a specific chain
+/// let base_provider = registry.by_chain_id(ChainId::new("eip155", "8453"));
+///
+/// // Find provider matching a pattern
+/// let any_evm = registry.by_chain_id_pattern(&ChainIdPattern::wildcard("eip155"));
+/// ```
+#[derive(Debug)]
+pub struct ChainRegistry<P>(HashMap<ChainId, P>);
+
+impl<P> ChainRegistry<P> {
+    pub fn new(providers: HashMap<ChainId, P>) -> Self {
+        Self(providers)
+    }
+}
+
+impl<P> ChainRegistry<P> {
+    /// Looks up a provider by exact chain ID.
+    ///
+    /// Returns `None` if no provider is configured for the given chain.
+    #[allow(dead_code)]
+    pub fn by_chain_id(&self, chain_id: ChainId) -> Option<&P> {
+        self.0.get(&chain_id)
+    }
+
+    /// Looks up providers by chain ID pattern matching.
+    ///
+    /// Returns all providers whose chain IDs match the given pattern.
+    /// The pattern can be:
+    /// - Wildcard: Matches any chain within a namespace (e.g., `eip155:*`)
+    /// - Exact: Matches a specific chain (e.g., `eip155:8453`)
+    /// - Set: Matches any chain from a set of references (e.g., `eip155:{1,8453,137}`)
+    ///
+    /// # Example
+    ///
+    /// ```ignore
+    /// use x402_rs::chain::{ChainRegistry, ChainIdPattern};
+    /// use x402_rs::config::Config;
+    ///
+    /// let config = Config::load()?;
+    /// let registry = ChainRegistry::from_config(config.chains()).await?;
+    ///
+    /// // Find all EVM chain providers
+    /// let evm_providers = registry.by_chain_id_pattern(&ChainIdPattern::wildcard("eip155"));
+    /// assert!(!evm_providers.is_empty());
+    ///
+    /// // Find providers for specific chains
+    /// let mainnet_chains = ChainIdPattern::set("eip155", ["1", "8453", "137"].into_iter().map(String::from).collect());
+    /// let mainnet_providers = registry.by_chain_id_pattern(&mainnet_chains);
+    /// ```
+    pub fn by_chain_id_pattern(&self, pattern: &ChainIdPattern) -> Vec<&P> {
+        self.0
+            .iter()
+            .filter_map(|(chain_id, provider)| pattern.matches(chain_id).then_some(provider))
+            .collect()
+    }
+}
+
+/// A token amount paired with its deployment information.
+///
+/// This type associates a numeric amount with the token deployment it refers to,
+/// enabling type-safe handling of token amounts across different chains and tokens.
+///
+/// # Type Parameters
+///
+/// - `TAmount` - The numeric type for the amount (e.g., `U256` for EVM, `u64` for Solana)
+/// - `TToken` - The token deployment type containing chain and address information
+#[derive(Debug, Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct DeployedTokenAmount<TAmount, TToken> {
+    /// The token amount in the token's smallest unit (e.g., wei for ETH, lamports for SOL).
+    pub amount: TAmount,
+    /// The token deployment information including chain, address, and decimals.
+    pub token: TToken,
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/config.rs b/bbt-x402-facilitator/crates/x402-types/src/config.rs
new file mode 100644
index 0000000..cbc052e
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/config.rs
@@ -0,0 +1,314 @@
+//! Configuration types for x402 infrastructure.
+//!
+//! This module provides the core configuration types used throughout the x402 ecosystem,
+//! including server configuration, RPC provider configuration, CLI argument parsing,
+//! and environment variable resolution.
+//!
+//! # Overview
+//!
+//! The configuration system is designed to be reusable across different x402 components:
+//!
+//! - [`Config<T>`] - Generic server configuration parameterized by chain config type
+//! - [`CliArgs`] - CLI argument parsing (requires `cli` feature)
+//! - [`LiteralOrEnv`] - Transparent wrapper for environment variable resolution
+//!
+//! # Configuration File Format
+//!
+//! Configuration is loaded from a JSON file (default: `config.json`) with the following structure:
+//!
+//! ```json
+//! {
+//!   "port": 9090,
+//!   "host": "0.0.0.0",
+//!   "chains": { /* chain-specific configuration */ },
+//!   "schemes": [
+//!     { "scheme": "v2-eip155-exact", "chains": ["eip155:8453"] }
+//!   ]
+//! }
+//! ```
+//!
+//! # Environment Variables
+//!
+//! - `CONFIG` - Path to configuration file (default: `config.json`)
+//! - `PORT` - Server port (default: 9090)
+//! - `HOST` - Server bind address (default: `0.0.0.0`)
+//!
+//! # Environment Variable Resolution
+//!
+//! The [`LiteralOrEnv`] wrapper type allows configuration values to be specified
+//! either as literal values or as references to environment variables:
+//!
+//! ```json
+//! {
+//!   "http": "http://localhost:8545",           // Literal value
+//!   "api_key": "$API_KEY",                     // Simple env var
+//!   "secret": "${DATABASE_SECRET}"             // Braced env var
+//! }
+//! ```
+//!
+//! This is particularly useful for keeping secrets out of configuration files
+//! while still allowing them to be loaded at runtime.
+//!
+//! # Feature Flags
+//!
+//! - `cli` - Enables CLI argument parsing via [`clap`]. When enabled, [`Config::load()`]
+//!   parses command-line arguments to determine the config file path.
+
+use serde::{Deserialize, Serialize};
+use std::fs;
+use std::net::IpAddr;
+use std::ops::{Deref, DerefMut};
+use std::path::PathBuf;
+use std::str::FromStr;
+
+#[cfg(feature = "cli")]
+use clap::Parser;
+#[cfg(feature = "cli")]
+use std::path::Path;
+
+use crate::scheme::SchemeConfig;
+
+// ============================================================================
+// Environment Variable Resolution
+// ============================================================================
+
+/// A transparent wrapper that resolves environment variables during deserialization.
+///
+/// Supports both literal values and environment variable references:
+/// - Literal: `"http://localhost:8083"`
+/// - Simple env var: `"$TREASURY_URL"`
+/// - Braced env var: `"${TREASURY_URL}"`
+///
+/// The wrapper implements `Deref` to provide transparent access to the inner type.
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct LiteralOrEnv<T>(T);
+
+impl<T> LiteralOrEnv<T> {
+    pub fn from_literal(value: T) -> Self {
+        Self(value)
+    }
+
+    /// Get a reference to the inner value
+    #[allow(dead_code)]
+    pub fn inner(&self) -> &T {
+        &self.0
+    }
+
+    /// Consume the wrapper and return the inner value
+    #[allow(dead_code)]
+    pub fn into_inner(self) -> T {
+        self.0
+    }
+
+    /// Parse environment variable syntax from a string.
+    /// Returns the variable name if the string matches `$VAR` or `${VAR}` syntax.
+    fn parse_env_var_syntax(s: &str) -> Option<String> {
+        if s.starts_with("${") && s.ends_with('}') {
+            // ${VAR} syntax
+            Some(s[2..s.len() - 1].to_string())
+        } else if s.starts_with('$') && s.len() > 1 {
+            // $VAR syntax - extract until first non-alphanumeric/underscore character
+            let var_name = &s[1..];
+            if var_name.chars().all(|c| c.is_alphanumeric() || c == '_') {
+                Some(var_name.to_string())
+            } else {
+                None
+            }
+        } else {
+            None
+        }
+    }
+}
+
+impl<T> Deref for LiteralOrEnv<T> {
+    type Target = T;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl<T> DerefMut for LiteralOrEnv<T> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.0
+    }
+}
+
+impl<'de, T> Deserialize<'de> for LiteralOrEnv<T>
+where
+    T: FromStr,
+    T::Err: std::fmt::Display,
+{
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+
+        // Check if it's an environment variable reference
+        let value = if let Some(var_name) = Self::parse_env_var_syntax(&s) {
+            std::env::var(&var_name).map_err(|_| {
+                serde::de::Error::custom(format!(
+                    "Environment variable '{}' not found (referenced as '{}')",
+                    var_name, s
+                ))
+            })?
+        } else {
+            s
+        };
+
+        // Parse the value as type T
+        let parsed = value
+            .parse::<T>()
+            .map_err(|e| serde::de::Error::custom(format!("Failed to parse value: {}", e)))?;
+
+        Ok(LiteralOrEnv(parsed))
+    }
+}
+
+impl<T> serde::Serialize for LiteralOrEnv<T>
+where
+    T: Serialize,
+{
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        self.0.serialize(serializer)
+    }
+}
+
+/// CLI arguments for the x402 facilitator server.
+#[derive(Debug)]
+#[cfg_attr(feature = "cli", derive(Parser))]
+#[cfg_attr(feature = "cli", command(name = "x402-rs"))]
+#[cfg_attr(feature = "cli", command(about = "x402 Facilitator HTTP server"))]
+#[allow(dead_code)] // For downstream crates to use
+pub struct CliArgs {
+    /// Path to the JSON configuration file
+    #[cfg_attr(
+        feature = "cli",
+        arg(long, short, env = "CONFIG", default_value = "config.json")
+    )]
+    pub config: PathBuf,
+}
+
+/// Server configuration.
+///
+/// Fields use serde defaults that fall back to environment variables,
+/// then to hardcoded defaults.
+#[derive(Debug, Clone, Deserialize)]
+pub struct Config<TChainsConfig> {
+    #[serde(default = "config_defaults::default_port")]
+    port: u16,
+    #[serde(default = "config_defaults::default_host")]
+    host: IpAddr,
+    #[serde(default)]
+    chains: TChainsConfig,
+    #[serde(default)]
+    schemes: Vec<SchemeConfig>,
+}
+
+impl<TChainsConfig> Default for Config<TChainsConfig>
+where
+    TChainsConfig: Default,
+{
+    fn default() -> Self {
+        Config {
+            port: config_defaults::default_port(),
+            host: config_defaults::default_host(),
+            chains: TChainsConfig::default(),
+            schemes: Vec::new(),
+        }
+    }
+}
+
+pub mod config_defaults {
+    use std::env;
+    use std::net::IpAddr;
+
+pub const DEFAULT_PORT: u16 = 9090;
+    pub const DEFAULT_HOST: &str = "0.0.0.0";
+
+/// Returns the default port value with fallback: $PORT env var -> 9090
+    pub fn default_port() -> u16 {
+        env::var("PORT")
+            .ok()
+            .and_then(|s| s.parse().ok())
+            .unwrap_or(DEFAULT_PORT)
+    }
+
+    /// Returns the default host value with fallback: $HOST env var -> "0.0.0.0"
+    pub fn default_host() -> IpAddr {
+        env::var("HOST")
+            .ok()
+            .and_then(|s| s.parse().ok())
+            .unwrap_or(IpAddr::V4(DEFAULT_HOST.parse().unwrap()))
+    }
+}
+
+impl<TChainsConfig> Config<TChainsConfig> {
+    /// Get the port value.
+    pub fn port(&self) -> u16 {
+        self.port
+    }
+
+    /// Get the host value as an IpAddr.
+    ///
+    /// Returns an error if the host string cannot be parsed as an IP address.
+    pub fn host(&self) -> IpAddr {
+        self.host
+    }
+
+    /// Get the schemes configuration list.
+    ///
+    /// Each entry specifies a scheme and the chains it applies to.
+    pub fn schemes(&self) -> &Vec<SchemeConfig> {
+        &self.schemes
+    }
+
+    /// Get the chains configuration map.
+    ///
+    /// Keys are CAIP-2 chain identifiers (e.g., "eip155:84532", "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp").
+    pub fn chains(&self) -> &TChainsConfig {
+        &self.chains
+    }
+}
+
+impl<TChainsConfig> Config<TChainsConfig>
+where
+    TChainsConfig: Default + for<'de> Deserialize<'de>,
+{
+    /// Load configuration from CLI arguments and JSON file.
+    ///
+    /// The config file path is determined by:
+    /// 1. `--config <path>` CLI argument
+    /// 2. `./config.json` (if it exists)
+    ///
+    /// Values not present in the config file will be resolved via
+    /// environment variables or defaults during deserialization.
+    #[cfg(feature = "cli")]
+    pub fn load() -> Result<Self, ConfigError> {
+        let cli_args = CliArgs::parse();
+        let config_path = Path::new(&cli_args.config)
+            .canonicalize()
+            .map_err(|e| ConfigError::FileRead(cli_args.config, e))?;
+        Self::load_from_path(config_path)
+    }
+
+    /// Load configuration from a specific path (or use defaults if None).
+    pub fn load_from_path(path: PathBuf) -> Result<Self, ConfigError> {
+        let content = fs::read_to_string(&path).map_err(|e| ConfigError::FileRead(path, e))?;
+        let config: Config<TChainsConfig> = serde_json::from_str(&content)?;
+        Ok(config)
+    }
+}
+
+/// Configuration error types.
+#[derive(Debug, thiserror::Error)]
+pub enum ConfigError {
+    #[error("Failed to read config file at {0}: {1}")]
+    FileRead(PathBuf, std::io::Error),
+    #[error("Failed to parse config file: {0}")]
+    JsonParse(#[from] serde_json::Error),
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/facilitator.rs b/bbt-x402-facilitator/crates/x402-types/src/facilitator.rs
new file mode 100644
index 0000000..c3e77f4
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/facilitator.rs
@@ -0,0 +1,83 @@
+//! Core trait defining the verification and settlement interface for x402 facilitators.
+//!
+//! Implementors of this trait are responsible for validating incoming payment payloads
+//! against specified requirements ([`Facilitator::verify`]) and executing on-chain transfers ([`Facilitator::settle`]).
+
+use std::fmt::{Debug, Display};
+use std::future::Future;
+use std::sync::Arc;
+
+use crate::proto;
+
+/// Trait defining the asynchronous interface for x402 payment facilitators.
+///
+/// This interface is implemented by any type that performs validation and
+/// settlement of payment payloads according to the x402 specification.
+pub trait Facilitator {
+    /// The error type returned by this facilitator.
+    type Error: Debug + Display;
+
+    /// Verifies a proposed x402 payment payload against a [`proto::VerifyRequest`].
+    ///
+    /// This includes checking payload integrity, signature validity, balance sufficiency,
+    /// network compatibility, and compliance with the declared payment requirements.
+    ///
+    /// # Returns
+    ///
+    /// A [`proto::VerifyResponse`] indicating success or failure, wrapped in a [`Result`].
+    ///
+    /// # Errors
+    ///
+    /// Returns [`Self::Error`] if any validation step fails.
+    fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> impl Future<Output = Result<proto::VerifyResponse, Self::Error>> + Send;
+
+    /// Executes an on-chain x402 settlement for a valid [`proto::SettleRequest`].
+    ///
+    /// This method should re-validate the payment and, if valid, perform
+    /// an onchain call to settle the payment.
+    ///
+    /// # Returns
+    ///
+    /// A [`proto::SettleResponse`] indicating whether the settlement was successful, and
+    /// containing any on-chain transaction metadata.
+    ///
+    /// # Errors
+    ///
+    /// Returns [`Self::Error`] if verification or settlement fails.
+    fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> impl Future<Output = Result<proto::SettleResponse, Self::Error>> + Send;
+
+    #[allow(dead_code)] // For some reason clippy believes it is not used.
+    fn supported(
+        &self,
+    ) -> impl Future<Output = Result<proto::SupportedResponse, Self::Error>> + Send;
+}
+
+impl<T: Facilitator> Facilitator for Arc<T> {
+    type Error = T::Error;
+
+    fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> impl Future<Output = Result<proto::VerifyResponse, Self::Error>> + Send {
+        self.as_ref().verify(request)
+    }
+
+    fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> impl Future<Output = Result<proto::SettleResponse, Self::Error>> + Send {
+        self.as_ref().settle(request)
+    }
+
+    fn supported(
+        &self,
+    ) -> impl Future<Output = Result<proto::SupportedResponse, Self::Error>> + Send {
+        self.as_ref().supported()
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/lib.rs b/bbt-x402-facilitator/crates/x402-types/src/lib.rs
new file mode 100644
index 0000000..4f8c913
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/lib.rs
@@ -0,0 +1,46 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Core types for the x402 payment protocol.
+//!
+//! This crate provides the foundational types used throughout the x402 ecosystem
+//! for implementing HTTP 402 Payment Required flows. It is designed to be
+//! blockchain-agnostic, with chain-specific implementations provided by separate crates.
+//!
+//! # Overview
+//!
+//! The x402 protocol enables micropayments over HTTP by leveraging the 402 Payment Required
+//! status code. When a client requests a paid resource, the server responds with payment
+//! requirements. The client signs a payment authorization, which is verified and settled
+//! by a facilitator.
+//!
+//! # Modules
+//!
+//! - [`chain`] - Blockchain identifiers and provider abstractions (CAIP-2 chain IDs)
+//! - [`config`] - Server configuration, CLI parsing, RPC config, and environment variable resolution
+//! - [`facilitator`] - Core trait for payment verification and settlement
+//! - [`networks`] - Registry of well-known blockchain networks
+//! - [`proto`] - Wire format types for protocol messages (V1 and V2)
+//! - [`scheme`] - Payment scheme system for extensible payment methods
+//! - [`timestamp`] - Unix timestamp utilities for payment authorization windows
+//! - [`util`] - Helper types (base64, string literals, money amounts)
+//!
+//! # Protocol Versions
+//!
+//! The crate supports two protocol versions:
+//!
+//! - **V1** ([`proto::v1`]): Original protocol using network names (e.g., "base-sepolia")
+//! - **V2** ([`proto::v2`]): Enhanced protocol using CAIP-2 chain IDs (e.g., "eip155:84532")
+//!
+//! # Feature Flags
+//!
+//! - `cli` - Enables CLI argument parsing via clap for configuration loading
+//! - `telemetry` - Enables tracing instrumentation for debugging and monitoring
+
+pub mod chain;
+pub mod config;
+pub mod facilitator;
+pub mod networks;
+pub mod proto;
+pub mod scheme;
+pub mod timestamp;
+pub mod util;
diff --git a/bbt-x402-facilitator/crates/x402-types/src/networks.rs b/bbt-x402-facilitator/crates/x402-types/src/networks.rs
new file mode 100644
index 0000000..e8bf88b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/networks.rs
@@ -0,0 +1,486 @@
+//! Known blockchain networks and CAIP-2 chain ID management.
+//!
+//! This module provides a comprehensive registry of well-known blockchain networks with their
+//! corresponding CAIP-2 (Chain Agnostic Improvement Proposal 2) chain identifiers. It is designed
+//! to improve developer experience (DX) when working with the x402 protocol, which operates on
+//! CAIP-2 chain IDs.
+//!
+//! # x402 v1 Protocol Relevance
+//!
+//! **This module is primarily relevant for x402 v1 protocol compatibility.** The registry of
+//! known networks represents the set of blockchain networks that were supported in x402 v1.
+//! For x402 v2 and beyond, the protocol is designed to work with any CAIP-2 chain ID without
+//! requiring a predefined registry.
+//!
+//! Despite being v1-focused, this module continues to provide value for improved developer
+//! experience by offering convenient methods to work with well-known networks without manually
+//! constructing CAIP-2 identifiers.
+//!
+//! # Purpose
+//!
+//! This module serves two main purposes:
+//! 1. **x402 v1 Protocol Compatibility**: Maintains support for networks that were known in v1
+//! 2. **Better Developer Experience**: Provides convenient methods to work with well-known networks
+//!    without manually constructing CAIP-2 identifiers
+//!
+//! # Usage Across the Codebase
+//!
+//! This module is used in several ways throughout the x402 ecosystem:
+//!
+//! - **ChainId Methods**: The [`ChainId::from_network_name()`](crate::chain::ChainId::from_network_name)
+//!   and [`ChainId::as_network_name()`](crate::chain::ChainId::as_network_name) methods use this
+//!   module for convenient network name lookups
+//! - **Chain-Specific Traits**: Chain-specific crates (e.g., `x402-chain-eip155`, `x402-chain-solana`)
+//!   implement namespace-specific traits like [`KnownNetworkEip155`] and [`KnownNetworkSolana`]
+//!   for type-safe network access
+//! - **Token Deployments**: The [`USDC`] marker struct is used by chain-specific crates to provide
+//!   per-network token deployment information (e.g., USDC addresses on different chains)
+//!
+//! # CAIP-2 Standard
+//!
+//! CAIP-2 is a standard for identifying blockchain networks in a chain-agnostic way. A CAIP-2
+//! chain ID consists of two parts separated by a colon:
+//! - **Namespace**: The blockchain ecosystem (e.g., "eip155" for EVM, "solana" for Solana)
+//! - **Reference**: The chain-specific identifier (e.g., "8453" for Base, "137" for Polygon)
+//!
+//! For more information, see: https://chainagnostic.org/CAIPs/caip-2
+//!
+//! # Module Contents
+//!
+//! - [`NetworkInfo`]: A struct representing a known network with its name, namespace, and reference
+//! - [`KnownNetworkEip155`]: Trait for convenient access to EVM networks (eip155 namespace)
+//! - [`KnownNetworkSolana`]: Trait for convenient access to Solana networks
+//! - [`KNOWN_NETWORKS`]: A static array of all well-known networks
+//! - [`chain_id_by_network_name`]: Lookup function to get ChainId by network name
+//! - [`network_name_by_chain_id`]: Reverse lookup function to get network name by ChainId
+//! - [`USDC`]: Marker struct used for token deployment implementations
+//!
+//! # Namespace-Specific Traits
+//!
+//! The module provides two namespace-specific traits for better organization and flexibility:
+//!
+//! ## KnownNetworkEip155
+//! Provides convenient static methods for all EVM networks (eip155 namespace):
+//! - Base, Base Sepolia
+//! - Polygon, Polygon Amoy
+//! - Avalanche, Avalanche Fuji
+//! - Sei, Sei Testnet
+//! - XDC, XRPL EVM, Peaq, IoTeX
+//! - Celo, Celo Sepolia
+//!
+//! ## KnownNetworkSolana
+//! Provides convenient static methods for Solana networks:
+//! - Solana mainnet
+//! - Solana devnet
+//!
+//! # Supported Networks
+//!
+//! The module supports 16 blockchain networks across two namespaces:
+//! - **EVM Networks (14)**: All networks in the eip155 namespace
+//! - **Solana Networks (2)**: Solana mainnet and devnet
+//!
+//! # Examples
+//!
+//! ```
+//! use x402_types::chain::ChainId;
+//! use x402_types::networks::chain_id_by_network_name;
+//!
+//! // Using lookup functions
+//! let polygon = chain_id_by_network_name("polygon").unwrap();
+//! assert_eq!(polygon.namespace, "eip155");
+//! assert_eq!(polygon.reference, "137");
+//!
+//! // Using ChainId::from_network_name
+//! let base = ChainId::from_network_name("base").unwrap();
+//! assert_eq!(base.namespace, "eip155");
+//! assert_eq!(base.reference, "8453");
+//!
+//! // Reverse lookup
+//! let chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+//! assert_eq!(chain_id.as_network_name(), Some("solana"));
+//! ```
+
+use std::collections::HashMap;
+use std::sync::LazyLock;
+
+use crate::chain::ChainId;
+
+/// A known network definition with its chain ID and human-readable name.
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct NetworkInfo {
+    /// Human-readable network name (e.g., "base-sepolia", "solana")
+    pub name: &'static str,
+    /// CAIP-2 namespace (e.g., "eip155", "solana")
+    pub namespace: &'static str,
+    /// Chain reference (e.g., "84532" for Base Sepolia, "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp" for Solana mainnet)
+    pub reference: &'static str,
+}
+
+impl NetworkInfo {
+    /// Create a ChainId from this network info
+    pub fn chain_id(&self) -> ChainId {
+        ChainId::new(self.namespace, self.reference)
+    }
+}
+
+/// A static array of well-known blockchain networks.
+///
+/// This array contains a registry of well-known blockchain networks for improved
+/// developer experience and x402 protocol v1 compatibility, organized by ecosystem
+/// (EVM networks first, then Solana networks). Each entry includes the network's
+/// human-readable name, CAIP-2 namespace, and chain reference.
+///
+/// # x402 v1 Protocol Relevance
+///
+/// This registry represents the set of blockchain networks that were known and supported
+/// in x402 v1. For x402 v2 and beyond, the protocol is designed to work with any CAIP-2
+/// chain ID without requiring a predefined registry.
+///
+/// The array is used to populate the lazy-initialized lookup hashmaps:
+/// - [`NAME_TO_CHAIN_ID`] for name-based lookups
+/// - [`CHAIN_ID_TO_NAME`] for ChainId-based lookups
+///
+/// # Developer Experience Benefits
+///
+/// Despite being v1-focused, this registry continues to provide value by:
+/// - Enabling convenient network name lookups via [`ChainId::from_network_name()`](crate::chain::ChainId::from_network_name)
+/// - Providing human-readable network names via [`ChainId::as_network_name()`](crate::chain::ChainId::as_network_name)
+/// - Serving as a reference for commonly used blockchain networks
+pub static KNOWN_NETWORKS: &[NetworkInfo] = &[
+    // EVM Networks
+    // Base
+    NetworkInfo {
+        name: "base",
+        namespace: "eip155",
+        reference: "8453",
+    },
+    NetworkInfo {
+        name: "base-sepolia",
+        namespace: "eip155",
+        reference: "84532",
+    },
+    // Polygon
+    NetworkInfo {
+        name: "polygon",
+        namespace: "eip155",
+        reference: "137",
+    },
+    NetworkInfo {
+        name: "polygon-amoy",
+        namespace: "eip155",
+        reference: "80002",
+    },
+    // Avalanche
+    NetworkInfo {
+        name: "avalanche",
+        namespace: "eip155",
+        reference: "43114",
+    },
+    NetworkInfo {
+        name: "avalanche-fuji",
+        namespace: "eip155",
+        reference: "43113",
+    },
+    // Sei
+    NetworkInfo {
+        name: "sei",
+        namespace: "eip155",
+        reference: "1329",
+    },
+    NetworkInfo {
+        name: "sei-testnet",
+        namespace: "eip155",
+        reference: "1328",
+    },
+    // XDC
+    NetworkInfo {
+        name: "xdc",
+        namespace: "eip155",
+        reference: "50",
+    },
+    // XRPL EVM
+    NetworkInfo {
+        name: "xrpl-evm",
+        namespace: "eip155",
+        reference: "1440000",
+    },
+    // Peaq
+    NetworkInfo {
+        name: "peaq",
+        namespace: "eip155",
+        reference: "3338",
+    },
+    // IoTeX
+    NetworkInfo {
+        name: "iotex",
+        namespace: "eip155",
+        reference: "4689",
+    },
+    // Celo Networks
+    NetworkInfo {
+        name: "celo",
+        namespace: "eip155",
+        reference: "42220",
+    },
+    NetworkInfo {
+        name: "celo-sepolia",
+        namespace: "eip155",
+        reference: "11142220",
+    },
+    // Solana Networks
+    NetworkInfo {
+        name: "solana",
+        namespace: "solana",
+        reference: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
+    },
+    NetworkInfo {
+        name: "solana-devnet",
+        namespace: "solana",
+        reference: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
+    },
+];
+
+/// Lazy-initialized hashmap for network name to ChainId lookups.
+///
+/// Maps human-readable network names (e.g., "base", "polygon", "solana") to their
+/// corresponding [`ChainId`] instances. This hashmap is populated once on first access
+/// from the [`KNOWN_NETWORKS`] array.
+///
+/// # x402 v1 Protocol Relevance
+///
+/// This hashmap provides the network name lookup functionality that was used in x402 v1.
+/// For x402 v2 and beyond, the protocol is designed to work with any CAIP-2 chain ID
+/// without requiring a predefined registry.
+///
+/// # Developer Experience Benefits
+///
+/// Despite being v1-focused, this hashmap continues to provide value by enabling
+/// convenient network name lookups via [`ChainId::from_network_name()`](crate::chain::ChainId::from_network_name).
+///
+/// # Examples
+///
+/// ```
+/// use x402_types::networks::chain_id_by_network_name;
+///
+/// let base = chain_id_by_network_name("base").unwrap();
+/// assert_eq!(base.namespace, "eip155");
+/// assert_eq!(base.reference, "8453");
+/// ```
+pub static NAME_TO_CHAIN_ID: LazyLock<HashMap<&'static str, ChainId>> = LazyLock::new(|| {
+    KNOWN_NETWORKS
+        .iter()
+        .map(|n| (n.name, n.chain_id()))
+        .collect()
+});
+
+/// Lazy-initialized hashmap for ChainId to network name lookups.
+///
+/// Maps [`ChainId`] instances to their human-readable network names. This hashmap is
+/// populated once on first access from the [`KNOWN_NETWORKS`] array. Useful for
+/// reverse lookups when you have a ChainId and need to find its network name.
+///
+/// # x402 v1 Protocol Relevance
+///
+/// This hashmap provides the reverse lookup functionality that was used in x402 v1.
+/// For x402 v2 and beyond, the protocol is designed to work with any CAIP-2 chain ID
+/// without requiring a predefined registry.
+///
+/// # Developer Experience Benefits
+///
+/// Despite being v1-focused, this hashmap continues to provide value by enabling
+/// human-readable network name lookups via [`ChainId::as_network_name()`](crate::chain::ChainId::as_network_name).
+///
+/// # Examples
+///
+/// ```
+/// use x402_types::chain::ChainId;
+/// use x402_types::networks::network_name_by_chain_id;
+///
+/// let chain_id = ChainId::new("eip155", "137");
+/// let name = network_name_by_chain_id(&chain_id).unwrap();
+/// assert_eq!(name, "polygon");
+/// ```
+pub static CHAIN_ID_TO_NAME: LazyLock<HashMap<ChainId, &'static str>> = LazyLock::new(|| {
+    KNOWN_NETWORKS
+        .iter()
+        .map(|n| (n.chain_id(), n.name))
+        .collect()
+});
+
+/// Retrieves a ChainId by its network name.
+///
+/// Performs a lookup in the [`NAME_TO_CHAIN_ID`] hashmap to find the ChainId
+/// corresponding to the given network name. The lookup is case-sensitive.
+///
+/// # x402 v1 Protocol Relevance
+///
+/// This function provides the network name lookup functionality that was used in x402 v1.
+/// For x402 v2 and beyond, the protocol is designed to work with any CAIP-2 chain ID
+/// without requiring a predefined registry.
+///
+/// # Developer Experience Benefits
+///
+/// Despite being v1-focused, this function continues to provide value by enabling
+/// convenient network name lookups. It is used by [`ChainId::from_network_name()`](crate::chain::ChainId::from_network_name)
+/// to provide a developer-friendly API for creating ChainId instances.
+///
+/// # Arguments
+///
+/// * `name` - The human-readable network name (e.g., "base", "polygon-amoy", "solana")
+///
+/// # Returns
+///
+/// Returns `Some(&ChainId)` if the network name is found, or `None` if the name
+/// is not in the known networks registry.
+///
+/// # Examples
+///
+/// ```
+/// use x402_types::networks::chain_id_by_network_name;
+///
+/// let base = chain_id_by_network_name("base").unwrap();
+/// assert_eq!(base.namespace, "eip155");
+/// assert_eq!(base.reference, "8453");
+///
+/// assert!(chain_id_by_network_name("unknown-network").is_none());
+/// ```
+pub fn chain_id_by_network_name(name: &str) -> Option<&ChainId> {
+    NAME_TO_CHAIN_ID.get(name)
+}
+
+/// Retrieves a network name by its ChainId.
+///
+/// Performs a reverse lookup in the [`CHAIN_ID_TO_NAME`] hashmap to find the
+/// human-readable network name corresponding to the given ChainId.
+///
+/// # x402 v1 Protocol Relevance
+///
+/// This function provides the reverse lookup functionality that was used in x402 v1.
+/// For x402 v2 and beyond, the protocol is designed to work with any CAIP-2 chain ID
+/// without requiring a predefined registry.
+///
+/// # Developer Experience Benefits
+///
+/// Despite being v1-focused, this function continues to provide value by enabling
+/// human-readable network name lookups. It is used by [`ChainId::as_network_name()`](crate::chain::ChainId::as_network_name)
+/// to provide a developer-friendly API for displaying network names.
+///
+/// # Arguments
+///
+/// * `chain_id` - A reference to the ChainId to look up
+///
+/// # Returns
+///
+/// Returns `Some(&'static str)` containing the network name if the ChainId is found,
+/// or `None` if the ChainId is not in the known networks registry.
+///
+/// # Examples
+///
+/// ```
+/// use x402_types::chain::ChainId;
+/// use x402_types::networks::network_name_by_chain_id;
+///
+/// let chain_id = ChainId::new("eip155", "8453");
+/// let name = network_name_by_chain_id(&chain_id).unwrap();
+/// assert_eq!(name, "base");
+///
+/// let unknown = ChainId::new("eip155", "999999");
+/// assert!(network_name_by_chain_id(&unknown).is_none());
+/// ```
+pub fn network_name_by_chain_id(chain_id: &ChainId) -> Option<&'static str> {
+    CHAIN_ID_TO_NAME.get(chain_id).copied()
+}
+
+/// Marker struct for USDC token deployment implementations.
+///
+/// This struct is used as a type parameter for chain-specific traits (e.g., `KnownNetworkEip155`,
+/// `KnownNetworkSolana`) to provide per-network USDC token deployment information.
+///
+/// # Usage
+///
+/// Chain-specific crates implement traits for this marker struct to provide USDC token
+/// deployments on different networks. For example:
+///
+/// - `x402-chain-eip155` implements `KnownNetworkEip155<Eip155TokenDeployment>` for `USDC`
+/// - `x402-chain-solana` implements `KnownNetworkSolana<SolanaTokenDeployment>` for `USDC`
+/// - `x402-chain-aptos` implements `KnownNetworkAptos<AptosTokenDeployment>` for `USDC`
+///
+/// # Example
+///
+/// ```ignore
+/// use x402_chain_eip155::{KnownNetworkEip155, Eip155TokenDeployment};
+/// use x402_types::networks::USDC;
+///
+/// // Get USDC deployment on Base mainnet
+/// let usdc_base: Eip155TokenDeployment = USDC::base();
+/// assert_eq!(usdc_base.chain_reference.value(), 8453);
+/// ```
+#[allow(dead_code, clippy::upper_case_acronyms)] // Public for consumption by downstream crates.
+pub struct USDC;
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_chain_id_from_network_name() {
+        let base = chain_id_by_network_name("base").unwrap();
+        assert_eq!(base.namespace, "eip155");
+        assert_eq!(base.reference, "8453");
+
+        let base_sepolia = chain_id_by_network_name("base-sepolia").unwrap();
+        assert_eq!(base_sepolia.namespace, "eip155");
+        assert_eq!(base_sepolia.reference, "84532");
+
+        let polygon = chain_id_by_network_name("polygon").unwrap();
+        assert_eq!(polygon.namespace, "eip155");
+        assert_eq!(polygon.reference, "137");
+
+        let celo = chain_id_by_network_name("celo").unwrap();
+        assert_eq!(celo.namespace, "eip155");
+        assert_eq!(celo.reference, "42220");
+
+        let solana = chain_id_by_network_name("solana").unwrap();
+        assert_eq!(solana.namespace, "solana");
+        assert_eq!(solana.reference, "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+
+        assert!(chain_id_by_network_name("unknown").is_none());
+    }
+
+    #[test]
+    fn test_network_name_by_chain_id() {
+        let chain_id = ChainId::new("eip155", "8453");
+        let network_name = network_name_by_chain_id(&chain_id).unwrap();
+        assert_eq!(network_name, "base");
+
+        let celo_chain_id = ChainId::new("eip155", "42220");
+        let network_name = network_name_by_chain_id(&celo_chain_id).unwrap();
+        assert_eq!(network_name, "celo");
+
+        let celo_sepolia_chain_id = ChainId::new("eip155", "11142220");
+        let network_name = network_name_by_chain_id(&celo_sepolia_chain_id).unwrap();
+        assert_eq!(network_name, "celo-sepolia");
+
+        let solana_chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+        let network_name = network_name_by_chain_id(&solana_chain_id).unwrap();
+        assert_eq!(network_name, "solana");
+
+        let unknown_chain_id = ChainId::new("eip155", "999999");
+        assert!(network_name_by_chain_id(&unknown_chain_id).is_none());
+    }
+
+    #[test]
+    fn test_chain_id_as_network_name() {
+        let chain_id = ChainId::new("eip155", "8453");
+        assert_eq!(chain_id.as_network_name(), Some("base"));
+
+        let celo_chain_id = ChainId::new("eip155", "42220");
+        assert_eq!(celo_chain_id.as_network_name(), Some("celo"));
+
+        let solana_chain_id = ChainId::new("solana", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp");
+        assert_eq!(solana_chain_id.as_network_name(), Some("solana"));
+
+        let unknown_chain_id = ChainId::new("eip155", "999999");
+        assert!(unknown_chain_id.as_network_name().is_none());
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/proto/mod.rs b/bbt-x402-facilitator/crates/x402-types/src/proto/mod.rs
new file mode 100644
index 0000000..e39b606
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/proto/mod.rs
@@ -0,0 +1,367 @@
+//! Protocol types for x402 payment messages.
+//!
+//! This module defines the wire format types used in the x402 protocol for
+//! communication between buyers, sellers, and facilitators. It supports both
+//! protocol version 1 (V1) and version 2 (V2).
+//!
+//! # Protocol Versions
+//!
+//! - **V1** ([`v1`]): Original protocol with network names and simpler structure
+//! - **V2** ([`v2`]): Enhanced protocol with CAIP-2 chain IDs and richer metadata
+//!
+//! # Key Types
+//!
+//! - [`SupportedPaymentKind`] - Describes a payment method supported by a facilitator
+//! - [`SupportedResponse`] - Response from facilitator's `/supported` endpoint
+//! - [`VerifyRequest`] / [`VerifyResponse`] - Payment verification messages
+//! - [`SettleRequest`] / [`SettleResponse`] - Payment settlement messages
+//! - [`PaymentVerificationError`] - Errors that can occur during verification
+//! - [`PaymentProblem`] - Structured error response for payment failures
+//!
+//! # Wire Format
+//!
+//! All types serialize to JSON using camelCase field names. The protocol version
+//! is indicated by the `x402Version` field in payment payloads.
+
+use serde::{Deserialize, Serialize};
+use serde_with::{VecSkipError, serde_as};
+use std::collections::HashMap;
+use std::str::FromStr;
+
+use crate::chain::ChainId;
+use crate::scheme::SchemeHandlerSlug;
+
+pub mod util;
+pub mod v1;
+pub mod v2;
+
+/// Trait for types that have both V1 and V2 protocol variants.
+///
+/// This trait enables generic handling of protocol-versioned types through
+/// the [`ProtocolVersioned`] enum.
+pub trait ProtocolV {
+    /// The V1 protocol variant of this type.
+    type V1;
+    /// The V2 protocol variant of this type.
+    type V2;
+}
+
+/// A versioned protocol type that can be either V1 or V2.
+///
+/// This enum wraps protocol-specific types to allow handling both versions
+/// in a unified way.
+pub enum ProtocolVersioned<T>
+where
+    T: ProtocolV,
+{
+    /// Protocol version 1 variant.
+    #[allow(dead_code)]
+    V1(T::V1),
+    /// Protocol version 2 variant.
+    #[allow(dead_code)]
+    V2(T::V2),
+}
+
+/// Describes a payment method supported by a facilitator.
+///
+/// This type is returned in the [`SupportedResponse`] to indicate what
+/// payment schemes, networks, and protocol versions a facilitator can handle.
+///
+/// # Example
+///
+/// ```json
+/// {
+///   "x402Version": 2,
+///   "scheme": "exact",
+///   "network": "eip155:8453"
+/// }
+/// ```
+#[derive(Clone, Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SupportedPaymentKind {
+    /// The x402 protocol version (1 or 2).
+    pub x402_version: u8,
+    /// The payment scheme identifier (e.g., "exact").
+    pub scheme: String,
+    /// The network identifier (CAIP-2 chain ID for V2, network name for V1).
+    pub network: String,
+    /// Optional scheme-specific extra data.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub extra: Option<serde_json::Value>,
+}
+
+/// Response from a facilitator's `/supported` endpoint.
+///
+/// This response tells clients what payment methods the facilitator supports,
+/// including protocol versions, schemes, networks, and signer addresses.
+///
+/// # Example
+///
+/// ```json
+/// {
+///   "kinds": [
+///     { "x402Version": 2, "scheme": "exact", "network": "eip155:8453" }
+///   ],
+///   "extensions": [],
+///   "signers": {
+///     "eip155:8453": ["0x1234..."]
+///   }
+/// }
+/// ```
+#[serde_as]
+#[derive(Clone, Default, Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct SupportedResponse {
+    /// List of supported payment kinds.
+    #[serde_as(as = "VecSkipError<_>")]
+    pub kinds: Vec<SupportedPaymentKind>,
+    /// List of supported protocol extensions.
+    #[serde(default)]
+    pub extensions: Vec<String>,
+    /// Map of chain IDs to signer addresses for that chain.
+    #[serde(default)]
+    pub signers: HashMap<ChainId, Vec<String>>,
+}
+
+/// Request to verify a payment before settlement.
+///
+/// This wrapper contains the payment payload and requirements sent by a client
+/// to a facilitator for verification. The facilitator checks that the payment
+/// authorization is valid, properly signed, and matches the requirements.
+///
+/// The inner JSON structure varies by protocol version and scheme.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct VerifyRequest(serde_json::Value);
+
+/// Request to settle a verified payment on-chain.
+///
+/// This is the same structure as [`VerifyRequest`], containing the payment
+/// payload that was previously verified.
+pub type SettleRequest = VerifyRequest;
+
+impl From<serde_json::Value> for VerifyRequest {
+    fn from(value: serde_json::Value) -> Self {
+        Self(value)
+    }
+}
+
+impl VerifyRequest {
+    /// Consumes the request and returns the inner JSON value.
+    pub fn into_json(self) -> serde_json::Value {
+        self.0
+    }
+
+    /// Extracts the scheme handler slug from the request.
+    ///
+    /// This determines which scheme handler should process this payment
+    /// based on the protocol version, chain ID, and scheme name.
+    ///
+    /// Returns `None` if the request format is invalid or the scheme is unknown.
+    pub fn scheme_handler_slug(&self) -> Option<SchemeHandlerSlug> {
+        let x402_version: u8 = self.0.get("x402Version")?.as_u64()?.try_into().ok()?;
+        match x402_version {
+            v1::X402Version1::VALUE => {
+                let network_name = self.0.get("paymentPayload")?.get("network")?.as_str()?;
+                let chain_id = ChainId::from_network_name(network_name)?;
+                let scheme = self.0.get("paymentPayload")?.get("scheme")?.as_str()?;
+                let slug = SchemeHandlerSlug::new(chain_id, 1, scheme.into());
+                Some(slug)
+            }
+            v2::X402Version2::VALUE => {
+                let chain_id_string = self
+                    .0
+                    .get("paymentPayload")?
+                    .get("accepted")?
+                    .get("network")?
+                    .as_str()?;
+                let chain_id = ChainId::from_str(chain_id_string).ok()?;
+                let scheme = self
+                    .0
+                    .get("paymentPayload")?
+                    .get("accepted")?
+                    .get("scheme")?
+                    .as_str()?;
+                let slug = SchemeHandlerSlug::new(chain_id, 2, scheme.into());
+                Some(slug)
+            }
+            _ => None,
+        }
+    }
+}
+
+/// Response from a payment verification request.
+///
+/// Contains the verification result as JSON. The structure varies by
+/// protocol version and scheme.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct VerifyResponse(pub serde_json::Value);
+
+/// Response from a payment settlement request.
+///
+/// Contains the settlement result as JSON, typically including the
+/// transaction hash if settlement was successful.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct SettleResponse(pub serde_json::Value);
+
+/// Errors that can occur during payment verification.
+///
+/// These errors are returned when a payment fails validation checks
+/// performed by the facilitator before settlement.
+#[derive(Debug, thiserror::Error)]
+pub enum PaymentVerificationError {
+    /// The payment payload format is invalid or malformed.
+    #[error("Invalid format: {0}")]
+    InvalidFormat(String),
+    /// The payment amount doesn't match the requirements.
+    #[error("Payment amount is invalid with respect to the payment requirements")]
+    InvalidPaymentAmount,
+    /// The payment authorization's `validAfter` timestamp is in the future.
+    #[error("Payment authorization is not yet valid")]
+    Early,
+    /// The payment authorization's `validBefore` timestamp has passed.
+    #[error("Payment authorization is expired")]
+    Expired,
+    /// The payment's chain ID doesn't match the requirements.
+    #[error("Payment chain id is invalid with respect to the payment requirements")]
+    ChainIdMismatch,
+    /// The payment recipient doesn't match the requirements.
+    #[error("Payment recipient is invalid with respect to the payment requirements")]
+    RecipientMismatch,
+    /// The payment asset (token) doesn't match the requirements.
+    #[error("Payment asset is invalid with respect to the payment requirements")]
+    AssetMismatch,
+    /// The payer's on-chain balance is insufficient.
+    #[error("Onchain balance is not enough to cover the payment amount")]
+    InsufficientFunds,
+    /// The payment signature is invalid.
+    #[error("{0}")]
+    InvalidSignature(String),
+    /// Transaction simulation failed.
+    #[error("{0}")]
+    TransactionSimulation(String),
+    /// The chain is not supported by this facilitator.
+    #[error("Unsupported chain")]
+    UnsupportedChain,
+    /// The payment scheme is not supported by this facilitator.
+    #[error("Unsupported scheme")]
+    UnsupportedScheme,
+    /// The accepted payment details don't match the requirements.
+    #[error("Accepted does not match payment requirements")]
+    AcceptedRequirementsMismatch,
+}
+
+impl AsPaymentProblem for PaymentVerificationError {
+    fn as_payment_problem(&self) -> PaymentProblem {
+        let error_reason = match self {
+            PaymentVerificationError::InvalidFormat(_) => ErrorReason::InvalidFormat,
+            PaymentVerificationError::InvalidPaymentAmount => ErrorReason::InvalidPaymentAmount,
+            PaymentVerificationError::InsufficientFunds => ErrorReason::InsufficientFunds,
+            PaymentVerificationError::Early => ErrorReason::InvalidPaymentEarly,
+            PaymentVerificationError::Expired => ErrorReason::InvalidPaymentExpired,
+            PaymentVerificationError::ChainIdMismatch => ErrorReason::ChainIdMismatch,
+            PaymentVerificationError::RecipientMismatch => ErrorReason::RecipientMismatch,
+            PaymentVerificationError::AssetMismatch => ErrorReason::AssetMismatch,
+            PaymentVerificationError::InvalidSignature(_) => ErrorReason::InvalidSignature,
+            PaymentVerificationError::TransactionSimulation(_) => {
+                ErrorReason::TransactionSimulation
+            }
+            PaymentVerificationError::UnsupportedChain => ErrorReason::UnsupportedChain,
+            PaymentVerificationError::UnsupportedScheme => ErrorReason::UnsupportedScheme,
+            PaymentVerificationError::AcceptedRequirementsMismatch => {
+                ErrorReason::AcceptedRequirementsMismatch
+            }
+        };
+        PaymentProblem::new(error_reason, self.to_string())
+    }
+}
+
+impl From<serde_json::Error> for PaymentVerificationError {
+    fn from(value: serde_json::Error) -> Self {
+        Self::InvalidFormat(value.to_string())
+    }
+}
+
+/// Machine-readable error reason codes for payment failures.
+///
+/// These codes are used in error responses to allow clients to
+/// programmatically handle different failure scenarios.
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
+#[serde(rename_all = "snake_case")]
+pub enum ErrorReason {
+    /// The payment payload format is invalid.
+    InvalidFormat,
+    /// The payment amount is incorrect.
+    InvalidPaymentAmount,
+    /// The payment authorization is not yet valid.
+    InvalidPaymentEarly,
+    /// The payment authorization has expired.
+    InvalidPaymentExpired,
+    /// The chain ID doesn't match.
+    ChainIdMismatch,
+    /// The recipient address doesn't match.
+    RecipientMismatch,
+    /// The token asset doesn't match.
+    AssetMismatch,
+    /// The accepted details don't match requirements.
+    AcceptedRequirementsMismatch,
+    /// The signature is invalid.
+    InvalidSignature,
+    /// Transaction simulation failed.
+    TransactionSimulation,
+    /// Insufficient on-chain balance.
+    InsufficientFunds,
+    /// The chain is not supported.
+    UnsupportedChain,
+    /// The scheme is not supported.
+    UnsupportedScheme,
+    /// An unexpected error occurred.
+    UnexpectedError,
+}
+
+/// Trait for converting errors into structured payment problems.
+pub trait AsPaymentProblem {
+    /// Converts this error into a [`PaymentProblem`].
+    fn as_payment_problem(&self) -> PaymentProblem;
+}
+
+/// A structured payment error with reason code and details.
+///
+/// This type is used to return detailed error information to clients
+/// when a payment fails verification or settlement.
+pub struct PaymentProblem {
+    /// The machine-readable error reason.
+    reason: ErrorReason,
+    /// Human-readable error details.
+    details: String,
+}
+
+impl PaymentProblem {
+    /// Creates a new payment problem with the given reason and details.
+    pub fn new(reason: ErrorReason, details: String) -> Self {
+        Self { reason, details }
+    }
+
+    /// Returns the error reason code.
+    pub fn reason(&self) -> ErrorReason {
+        self.reason
+    }
+
+    /// Returns the human-readable error details.
+    pub fn details(&self) -> &str {
+        &self.details
+    }
+}
+
+/// Protocol version marker for [`PaymentRequired`] responses.
+pub struct PaymentRequiredV;
+
+impl ProtocolV for PaymentRequiredV {
+    type V1 = v1::PaymentRequired;
+    type V2 = v2::PaymentRequired;
+}
+
+/// A payment required response that can be either V1 or V2.
+///
+/// This is returned with HTTP 402 status to indicate that payment is required.
+pub type PaymentRequired = ProtocolVersioned<PaymentRequiredV>;
diff --git a/bbt-x402-facilitator/crates/x402-types/src/proto/util.rs b/bbt-x402-facilitator/crates/x402-types/src/proto/util.rs
new file mode 100644
index 0000000..4bf44bd
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/proto/util.rs
@@ -0,0 +1,71 @@
+//! Utility types for protocol serialization.
+//!
+//! This module provides helper types for serializing values in the x402 wire format.
+
+use serde::de::Error;
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::str::FromStr;
+
+/// A `u64` value that serializes as a string.
+///
+/// Some JSON parsers (particularly in JavaScript) cannot accurately represent
+/// large integers. This type serializes `u64` values as strings to preserve
+/// precision across all platforms.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_types::proto::util::U64String;
+///
+/// let value = U64String::from(12345678901234567890u64);
+/// let json = serde_json::to_string(&value).unwrap();
+/// assert_eq!(json, "\"12345678901234567890\"");
+/// ```
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct U64String(u64);
+
+impl U64String {
+    /// Returns the inner `u64` value.
+    pub fn inner(&self) -> u64 {
+        self.0
+    }
+}
+
+impl FromStr for U64String {
+    type Err = <u64 as FromStr>::Err;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        s.parse::<u64>().map(Self)
+    }
+}
+
+impl From<u64> for U64String {
+    fn from(value: u64) -> Self {
+        Self(value)
+    }
+}
+
+impl From<U64String> for u64 {
+    fn from(value: U64String) -> Self {
+        value.0
+    }
+}
+
+impl Serialize for U64String {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&self.0.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for U64String {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        s.parse::<u64>().map(Self).map_err(D::Error::custom)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/proto/v1.rs b/bbt-x402-facilitator/crates/x402-types/src/proto/v1.rs
new file mode 100644
index 0000000..b3d7d6b
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/proto/v1.rs
@@ -0,0 +1,525 @@
+//! Protocol version 1 (V1) types for x402.
+//!
+//! This module defines the wire format types for the original x402 protocol version.
+//! V1 uses network names (e.g., "base-sepolia") instead of CAIP-2 chain IDs.
+//!
+//! # Key Types
+//!
+//! - [`X402Version1`] - Version marker that serializes as `1`
+//! - [`PaymentPayload`] - Signed payment authorization from the buyer
+//! - [`PaymentRequirements`] - Payment terms set by the seller
+//! - [`PaymentRequired`] - HTTP 402 response body
+//! - [`VerifyRequest`] / [`VerifyResponse`] - Verification messages
+//! - [`SettleResponse`] - Settlement result
+//! - [`PriceTag`] - Builder for creating payment requirements
+
+use serde::de::DeserializeOwned;
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::fmt;
+use std::fmt::Display;
+use std::str::FromStr;
+use std::sync::Arc;
+
+use crate::proto;
+use crate::proto::SupportedResponse;
+
+/// Version marker for x402 protocol version 1.
+///
+/// This type serializes as the integer `1` and is used to identify V1 protocol
+/// messages in the wire format.
+#[derive(Debug, Copy, Clone, Default, PartialEq, Eq)]
+pub struct X402Version1;
+
+impl X402Version1 {
+    pub const VALUE: u8 = 1;
+}
+
+impl PartialEq<u8> for X402Version1 {
+    fn eq(&self, other: &u8) -> bool {
+        *other == Self::VALUE
+    }
+}
+
+impl From<X402Version1> for u8 {
+    fn from(_: X402Version1) -> Self {
+        X402Version1::VALUE
+    }
+}
+
+impl Serialize for X402Version1 {
+    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
+        serializer.serialize_u8(Self::VALUE)
+    }
+}
+
+impl<'de> Deserialize<'de> for X402Version1 {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let num = u8::deserialize(deserializer)?;
+        if num == Self::VALUE {
+            Ok(X402Version1)
+        } else {
+            Err(serde::de::Error::custom(format!(
+                "expected version {}, got {}",
+                Self::VALUE,
+                num
+            )))
+        }
+    }
+}
+
+impl Display for X402Version1 {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}", Self::VALUE)
+    }
+}
+
+/// Response from a payment settlement request.
+///
+/// Indicates whether the payment was successfully settled on-chain.
+pub enum SettleResponse {
+    /// Settlement succeeded.
+    Success {
+        /// The address that paid.
+        payer: String,
+        /// The transaction hash.
+        transaction: String,
+        /// The network where settlement occurred.
+        network: String,
+    },
+    /// Settlement failed.
+    Error {
+        /// The reason for failure.
+        reason: String,
+        /// The network where settlement was attempted.
+        network: String,
+    },
+}
+
+impl From<SettleResponse> for proto::SettleResponse {
+    fn from(val: SettleResponse) -> Self {
+        proto::SettleResponse(
+            serde_json::to_value(val).expect("SettleResponse serialization failed"),
+        )
+    }
+}
+
+#[derive(Serialize, Deserialize)]
+struct SettleResponseWire {
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error_reason: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub payer: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub transaction: Option<String>,
+    pub network: String,
+}
+
+impl Serialize for SettleResponse {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        let wire = match self {
+            SettleResponse::Success {
+                payer,
+                transaction,
+                network,
+            } => SettleResponseWire {
+                success: true,
+                error_reason: None,
+                payer: Some(payer.clone()),
+                transaction: Some(transaction.clone()),
+                network: network.clone(),
+            },
+            SettleResponse::Error { reason, network } => SettleResponseWire {
+                success: false,
+                error_reason: Some(reason.clone()),
+                payer: None,
+                transaction: None,
+                network: network.clone(),
+            },
+        };
+        wire.serialize(serializer)
+    }
+}
+
+impl<'de> Deserialize<'de> for SettleResponse {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let wire = SettleResponseWire::deserialize(deserializer)?;
+        match wire.success {
+            true => {
+                let payer = wire
+                    .payer
+                    .ok_or_else(|| serde::de::Error::missing_field("payer"))?;
+                let transaction = wire
+                    .transaction
+                    .ok_or_else(|| serde::de::Error::missing_field("transaction"))?;
+                Ok(SettleResponse::Success {
+                    payer,
+                    transaction,
+                    network: wire.network,
+                })
+            }
+            false => {
+                let reason = wire
+                    .error_reason
+                    .ok_or_else(|| serde::de::Error::missing_field("error_reason"))?;
+                Ok(SettleResponse::Error {
+                    reason,
+                    network: wire.network,
+                })
+            }
+        }
+    }
+}
+
+/// Result returned by a facilitator after verifying a [`PaymentPayload`] against the provided [`PaymentRequirements`].
+///
+/// This response indicates whether the payment authorization is valid and identifies the payer. If invalid,
+/// it includes a reason describing why verification failed (e.g., wrong network, an invalid scheme, insufficient funds).
+#[derive(Debug)]
+pub enum VerifyResponse {
+    /// The payload matches the requirements and passes all checks.
+    Valid { payer: String },
+    /// The payload was well-formed but failed verification due to the specified [`FacilitatorErrorReason`]
+    Invalid {
+        reason: String,
+        payer: Option<String>,
+    },
+}
+
+impl From<VerifyResponse> for proto::VerifyResponse {
+    fn from(val: VerifyResponse) -> Self {
+        proto::VerifyResponse(
+            serde_json::to_value(val).expect("VerifyResponse serialization failed"),
+        )
+    }
+}
+
+impl TryFrom<proto::VerifyResponse> for VerifyResponse {
+    type Error = serde_json::Error;
+    fn try_from(value: proto::VerifyResponse) -> Result<Self, Self::Error> {
+        let json = value.0;
+        serde_json::from_value(json)
+    }
+}
+
+impl VerifyResponse {
+    /// Constructs a successful verification response with the given `payer` address.
+    ///
+    /// Indicates that the provided payment payload has been validated against the payment requirements.
+    pub fn valid(payer: String) -> Self {
+        VerifyResponse::Valid { payer }
+    }
+
+    /// Constructs a failed verification response with the given `payer` address and error `reason`.
+    ///
+    /// Indicates that the payment was recognized but rejected due to reasons such as
+    /// insufficient funds, invalid network, or scheme mismatch.
+    #[allow(dead_code)]
+    pub fn invalid(payer: Option<String>, reason: String) -> Self {
+        VerifyResponse::Invalid { reason, payer }
+    }
+}
+
+#[derive(Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+struct VerifyResponseWire {
+    is_valid: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    payer: Option<String>,
+    #[serde(default)]
+    invalid_reason: Option<String>,
+}
+
+impl Serialize for VerifyResponse {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        let wire = match self {
+            VerifyResponse::Valid { payer } => VerifyResponseWire {
+                is_valid: true,
+                payer: Some(payer.clone()),
+                invalid_reason: None,
+            },
+            VerifyResponse::Invalid { reason, payer } => VerifyResponseWire {
+                is_valid: false,
+                payer: payer.clone(),
+                invalid_reason: Some(reason.clone()),
+            },
+        };
+        wire.serialize(serializer)
+    }
+}
+
+impl<'de> Deserialize<'de> for VerifyResponse {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let wire = VerifyResponseWire::deserialize(deserializer)?;
+        match wire.is_valid {
+            true => {
+                let payer = wire
+                    .payer
+                    .ok_or_else(|| serde::de::Error::missing_field("payer"))?;
+                Ok(VerifyResponse::Valid { payer })
+            }
+            false => {
+                let reason = wire
+                    .invalid_reason
+                    .ok_or_else(|| serde::de::Error::missing_field("invalid_reason"))?;
+                let payer = wire.payer;
+                Ok(VerifyResponse::Invalid { reason, payer })
+            }
+        }
+    }
+}
+
+/// Request to verify a V1 payment.
+///
+/// Contains the payment payload and requirements for verification.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct VerifyRequest<TPayload, TRequirements> {
+    /// Protocol version (always 1).
+    pub x402_version: X402Version1,
+    /// The signed payment authorization.
+    pub payment_payload: TPayload,
+    /// The payment requirements to verify against.
+    pub payment_requirements: TRequirements,
+}
+
+impl<TPayload, TRequirements> VerifyRequest<TPayload, TRequirements>
+where
+    Self: DeserializeOwned,
+{
+    pub fn from_proto(
+        request: proto::VerifyRequest,
+    ) -> Result<Self, proto::PaymentVerificationError> {
+        let deserialized: Self = serde_json::from_value(request.into_json())?;
+        Ok(deserialized)
+    }
+}
+
+impl<TPayload, TRequirements> TryInto<proto::VerifyRequest>
+    for VerifyRequest<TPayload, TRequirements>
+where
+    TPayload: Serialize,
+    TRequirements: Serialize,
+{
+    type Error = serde_json::Error;
+    fn try_into(self) -> Result<proto::VerifyRequest, Self::Error> {
+        let json = serde_json::to_value(self)?;
+        Ok(proto::VerifyRequest(json))
+    }
+}
+
+/// A signed payment authorization from the buyer.
+///
+/// This contains the cryptographic proof that the buyer has authorized
+/// a payment, along with metadata about the payment scheme and network.
+///
+/// # Type Parameters
+///
+/// - `TScheme` - The scheme identifier type (default: `String`)
+/// - `TPayload` - The scheme-specific payload type (default: raw JSON)
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentPayload<TScheme = String, TPayload = Box<serde_json::value::RawValue>> {
+    /// Protocol version (always 1).
+    pub x402_version: X402Version1,
+    /// The payment scheme (e.g., "exact").
+    pub scheme: TScheme,
+    /// The network name (e.g., "base-sepolia").
+    pub network: String,
+    /// The scheme-specific signed payload.
+    pub payload: TPayload,
+}
+
+/// Payment requirements set by the seller.
+///
+/// Defines the terms under which a payment will be accepted, including
+/// the amount, recipient, asset, and timing constraints.
+///
+/// # Type Parameters
+///
+/// - `TScheme` - The scheme identifier type (default: `String`)
+/// - `TAmount` - The amount type (default: `String`)
+/// - `TAddress` - The address type (default: `String`)
+/// - `TExtra` - Scheme-specific extra data type (default: `serde_json::Value`)
+#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentRequirements<
+    TScheme = String,
+    TAmount = String,
+    TAddress = String,
+    TExtra = serde_json::Value,
+> {
+    /// The payment scheme (e.g., "exact").
+    pub scheme: TScheme,
+    /// The network name (e.g., "base-sepolia").
+    pub network: String,
+    /// The maximum amount required for payment.
+    pub max_amount_required: TAmount,
+    /// The resource URL being paid for.
+    pub resource: String,
+    /// Human-readable description of the resource.
+    pub description: String,
+    /// MIME type of the resource.
+    pub mime_type: String,
+    /// Optional JSON schema for the resource output.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub output_schema: Option<serde_json::Value>,
+    /// The recipient address for payment.
+    pub pay_to: TAddress,
+    /// Maximum time in seconds for payment validity.
+    pub max_timeout_seconds: u64,
+    /// The token asset address.
+    pub asset: TAddress,
+    /// Scheme-specific extra data.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub extra: Option<TExtra>,
+}
+
+impl PaymentRequirements {
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn as_concrete<
+        TScheme: FromStr,
+        TAmount: FromStr,
+        TAddress: FromStr,
+        TExtra: DeserializeOwned,
+    >(
+        &self,
+    ) -> Option<PaymentRequirements<TScheme, TAmount, TAddress, TExtra>> {
+        let scheme = self.scheme.parse::<TScheme>().ok()?;
+        let max_amount_required = self.max_amount_required.parse::<TAmount>().ok()?;
+        let pay_to = self.pay_to.parse::<TAddress>().ok()?;
+        let asset = self.asset.parse::<TAddress>().ok()?;
+        let extra = self
+            .extra
+            .as_ref()
+            .and_then(|v| serde_json::from_value(v.clone()).ok());
+        Some(PaymentRequirements {
+            scheme,
+            network: self.network.clone(),
+            max_amount_required,
+            resource: self.resource.clone(),
+            description: self.description.clone(),
+            mime_type: self.mime_type.clone(),
+            output_schema: self.output_schema.clone(),
+            pay_to,
+            max_timeout_seconds: self.max_timeout_seconds,
+            asset,
+            extra,
+        })
+    }
+}
+
+/// HTTP 402 Payment Required response body for V1.
+///
+/// This is returned when a resource requires payment. It contains
+/// the list of acceptable payment methods.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentRequired {
+    /// Protocol version (always 1).
+    pub x402_version: X402Version1,
+    /// List of acceptable payment methods.
+    #[serde(default)]
+    pub accepts: Vec<PaymentRequirements>,
+    /// Optional error message if the request was malformed.
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+/// Builder for creating payment requirements.
+///
+/// A `PriceTag` is a convenient way to specify payment terms that can
+/// be converted into [`PaymentRequirements`] for inclusion in a 402 response.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_types::proto::v1::PriceTag;
+///
+/// let price = PriceTag {
+///     scheme: "exact".to_string(),
+///     pay_to: "0x1234...".to_string(),
+///     asset: "0xUSDC...".to_string(),
+///     network: "base".to_string(),
+///     amount: "1000000".to_string(), // 1 USDC
+///     max_timeout_seconds: 300,
+///     extra: None,
+///     enricher: None,
+/// };
+/// ```
+#[derive(Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct PriceTag {
+    /// The payment scheme (e.g., "exact").
+    pub scheme: String,
+    /// The recipient address.
+    pub pay_to: String,
+    /// The token asset address.
+    pub asset: String,
+    /// The network name.
+    pub network: String,
+    /// The payment amount in token units.
+    pub amount: String,
+    /// Maximum time in seconds for payment validity.
+    pub max_timeout_seconds: u64,
+    /// Scheme-specific extra data.
+    pub extra: Option<serde_json::Value>,
+    /// Optional enrichment function for adding facilitator-specific data.
+    #[doc(hidden)]
+    pub enricher: Option<Enricher>,
+}
+
+impl fmt::Debug for PriceTag {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("PriceTag")
+            .field("scheme", &self.scheme)
+            .field("pay_to", &self.pay_to)
+            .field("asset", &self.asset)
+            .field("network", &self.network)
+            .field("amount", &self.amount)
+            .field("max_timeout_seconds", &self.max_timeout_seconds)
+            .field("extra", &self.extra)
+            .finish()
+    }
+}
+
+/// Enrichment function type for price tags.
+///
+/// Enrichers are called with the facilitator's capabilities to add
+/// facilitator-specific data to price tags (e.g., fee payer addresses).
+pub type Enricher = Arc<dyn Fn(&mut PriceTag, &SupportedResponse) + Send + Sync>;
+
+impl PriceTag {
+    /// Applies the enrichment function if one is set.
+    ///
+    /// This is called automatically when building payment requirements
+    /// to add facilitator-specific data.
+    #[allow(dead_code)]
+    pub fn enrich(&mut self, capabilities: &SupportedResponse) {
+        if let Some(enricher) = self.enricher.clone() {
+            enricher(self, capabilities);
+        }
+    }
+
+    /// Sets the maximum timeout for this price tag.
+    #[allow(dead_code)]
+    pub fn with_timeout(mut self, seconds: u64) -> Self {
+        self.max_timeout_seconds = seconds;
+        self
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/proto/v2.rs b/bbt-x402-facilitator/crates/x402-types/src/proto/v2.rs
new file mode 100644
index 0000000..ab9ab90
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/proto/v2.rs
@@ -0,0 +1,322 @@
+//! Protocol version 2 (V2) types for x402.
+//!
+//! This module defines the wire format types for the enhanced x402 protocol version.
+//! V2 uses CAIP-2 chain IDs (e.g., "eip155:8453") instead of network names, and
+//! includes richer resource metadata.
+//!
+//! # Key Differences from V1
+//!
+//! - Uses CAIP-2 chain IDs instead of network names
+//! - Includes [`ResourceInfo`] with URL, description, and MIME type
+//! - Simplified [`PaymentRequirements`] structure
+//! - Payment payload includes accepted requirements for verification
+//!
+//! # Key Types
+//!
+//! - [`X402Version2`] - Version marker that serializes as `2`
+//! - [`PaymentPayload`] - Signed payment with accepted requirements
+//! - [`PaymentRequirements`] - Payment terms set by the seller
+//! - [`PaymentRequired`] - HTTP 402 response body
+//! - [`ResourceInfo`] - Metadata about the paid resource
+//! - [`PriceTag`] - Builder for creating payment requirements
+
+use crate::chain::ChainId;
+use crate::proto;
+use crate::proto::SupportedResponse;
+use crate::proto::v1;
+use serde::de::DeserializeOwned;
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::fmt;
+use std::fmt::{Display, Formatter};
+use std::str::FromStr;
+use std::sync::Arc;
+
+/// Version marker for x402 protocol version 2.
+///
+/// This type serializes as the integer `2` and is used to identify V2 protocol
+/// messages in the wire format.
+#[derive(Debug, Copy, Clone, Default, PartialEq, Eq)]
+pub struct X402Version2;
+
+impl X402Version2 {
+    pub const VALUE: u8 = 2;
+}
+
+impl PartialEq<u8> for X402Version2 {
+    fn eq(&self, other: &u8) -> bool {
+        *other == Self::VALUE
+    }
+}
+
+impl From<X402Version2> for u8 {
+    fn from(_: X402Version2) -> Self {
+        X402Version2::VALUE
+    }
+}
+
+impl Serialize for X402Version2 {
+    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
+        serializer.serialize_u8(Self::VALUE)
+    }
+}
+
+impl<'de> Deserialize<'de> for X402Version2 {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let num = u8::deserialize(deserializer)?;
+        if num == Self::VALUE {
+            Ok(X402Version2)
+        } else {
+            Err(serde::de::Error::custom(format!(
+                "expected version {}, got {}",
+                Self::VALUE,
+                num
+            )))
+        }
+    }
+}
+
+impl Display for X402Version2 {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(f, "{}", Self::VALUE)
+    }
+}
+
+/// Response from a V2 payment verification request.
+///
+/// V2 uses the same response format as V1.
+pub type VerifyResponse = v1::VerifyResponse;
+
+/// Response from a V2 payment settlement request.
+///
+/// V2 uses the same response format as V1.
+pub type SettleResponse = v1::SettleResponse;
+
+/// Metadata about the resource being paid for.
+///
+/// This provides human-readable information about what the buyer is paying for.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ResourceInfo {
+    /// Human-readable description of the resource.
+    pub description: String,
+    /// MIME type of the resource content.
+    pub mime_type: String,
+    /// URL of the resource.
+    pub url: String,
+}
+
+/// Request to verify a V2 payment.
+///
+/// Contains the payment payload and requirements for verification.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct VerifyRequest<TPayload, TRequirements> {
+    /// Protocol version (always 2).
+    pub x402_version: X402Version2,
+    /// The signed payment authorization.
+    pub payment_payload: TPayload,
+    /// The payment requirements to verify against.
+    pub payment_requirements: TRequirements,
+}
+
+impl<TPayload, TRequirements> VerifyRequest<TPayload, TRequirements>
+where
+    Self: DeserializeOwned,
+{
+    pub fn from_proto(
+        request: proto::VerifyRequest,
+    ) -> Result<Self, proto::PaymentVerificationError> {
+        let deserialized: Self = serde_json::from_value(request.into_json())?;
+        Ok(deserialized)
+    }
+}
+
+/// A signed payment authorization from the buyer (V2 format).
+///
+/// In V2, the payment payload includes the accepted requirements, allowing
+/// the facilitator to verify that the buyer agreed to specific terms.
+///
+/// # Type Parameters
+///
+/// - `TAccepted` - The accepted requirements type
+/// - `TPayload` - The scheme-specific payload type
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentPayload<TAccepted, TPayload> {
+    /// The payment requirements the buyer accepted.
+    pub accepted: TAccepted,
+    /// The scheme-specific signed payload.
+    pub payload: TPayload,
+    /// Information about the resource being paid for.
+    pub resource: Option<ResourceInfo>,
+    /// Protocol version (always 2).
+    pub x402_version: X402Version2,
+}
+
+/// Payment requirements set by the seller (V2 format).
+///
+/// Defines the terms under which a payment will be accepted. V2 uses
+/// CAIP-2 chain IDs and has a simplified structure compared to V1.
+///
+/// # Type Parameters
+///
+/// - `TScheme` - The scheme identifier type (default: `String`)
+/// - `TAmount` - The amount type (default: `String`)
+/// - `TAddress` - The address type (default: `String`)
+/// - `TExtra` - Scheme-specific extra data type (default: `serde_json::Value`)
+#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentRequirements<
+    TScheme = String,
+    TAmount = String,
+    TAddress = String,
+    TExtra = serde_json::Value,
+> {
+    /// The payment scheme (e.g., "exact").
+    pub scheme: TScheme,
+    /// The CAIP-2 chain ID (e.g., "eip155:8453").
+    pub network: ChainId,
+    /// The payment amount in token units.
+    pub amount: TAmount,
+    /// The recipient address for payment.
+    pub pay_to: TAddress,
+    /// Maximum time in seconds for payment validity.
+    pub max_timeout_seconds: u64,
+    /// The token asset address.
+    pub asset: TAddress,
+    /// Scheme-specific extra data.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub extra: Option<TExtra>,
+}
+
+impl PaymentRequirements {
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub fn as_concrete<
+        TScheme: FromStr,
+        TAmount: FromStr,
+        TAddress: FromStr,
+        TExtra: DeserializeOwned,
+    >(
+        &self,
+    ) -> Option<PaymentRequirements<TScheme, TAmount, TAddress, TExtra>> {
+        let scheme = self.scheme.parse::<TScheme>().ok()?;
+        let amount = self.amount.parse::<TAmount>().ok()?;
+        let pay_to = self.pay_to.parse::<TAddress>().ok()?;
+        let asset = self.asset.parse::<TAddress>().ok()?;
+        let extra = self
+            .extra
+            .as_ref()
+            .and_then(|v| serde_json::from_value(v.clone()).ok());
+        Some(PaymentRequirements {
+            scheme,
+            network: self.network.clone(),
+            amount,
+            pay_to,
+            max_timeout_seconds: self.max_timeout_seconds,
+            asset,
+            extra,
+        })
+    }
+}
+
+/// HTTP 402 Payment Required response body for V2.
+///
+/// This is returned when a resource requires payment. It contains
+/// the list of acceptable payment methods and resource metadata.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PaymentRequired {
+    /// Protocol version (always 2).
+    pub x402_version: X402Version2,
+    /// Optional error message if the request was malformed.
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+    /// Information about the resource being paid for.
+    pub resource: ResourceInfo,
+    /// List of acceptable payment methods.
+    #[serde(default)]
+    pub accepts: Vec<PaymentRequirements>,
+}
+
+/// Builder for creating V2 payment requirements.
+///
+/// A `PriceTag` wraps [`PaymentRequirements`] and provides enrichment
+/// capabilities for adding facilitator-specific data.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_types::proto::v2::{PriceTag, PaymentRequirements};
+/// use x402_types::chain::ChainId;
+///
+/// let requirements = PaymentRequirements {
+///     scheme: "exact".to_string(),
+///     network: "eip155:8453".parse().unwrap(),
+///     amount: "1000000".to_string(),
+///     pay_to: "0x1234...".to_string(),
+///     asset: "0xUSDC...".to_string(),
+///     max_timeout_seconds: 300,
+///     extra: None,
+/// };
+///
+/// let price = PriceTag {
+///     requirements,
+///     enricher: None,
+/// };
+/// ```
+#[derive(Clone)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct PriceTag {
+    /// The payment requirements.
+    pub requirements: PaymentRequirements,
+    /// Optional enrichment function for adding facilitator-specific data.
+    #[doc(hidden)]
+    pub enricher: Option<Enricher>,
+}
+
+impl fmt::Debug for PriceTag {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("PriceTag")
+            .field("requirements", &self.requirements)
+            .finish()
+    }
+}
+
+/// Enrichment function type for V2 price tags.
+///
+/// Enrichers are called with the facilitator's capabilities to add
+/// facilitator-specific data to price tags (e.g., fee payer addresses).
+pub type Enricher = Arc<dyn Fn(&mut PriceTag, &SupportedResponse) + Send + Sync>;
+
+impl PriceTag {
+    /// Applies the enrichment function if one is set.
+    ///
+    /// This is called automatically when building payment requirements
+    /// to add facilitator-specific data.
+    #[allow(dead_code)]
+    pub fn enrich(&mut self, capabilities: &SupportedResponse) {
+        if let Some(enricher) = self.enricher.clone() {
+            enricher(self, capabilities);
+        }
+    }
+
+    /// Sets the maximum timeout for this price tag.
+    #[allow(dead_code)]
+    pub fn with_timeout(mut self, seconds: u64) -> Self {
+        self.requirements.max_timeout_seconds = seconds;
+        self
+    }
+}
+
+/// Compares a [`PriceTag`] with [`PaymentRequirements`].
+///
+/// This allows checking if a price tag matches specific requirements.
+impl PartialEq<PaymentRequirements> for PriceTag {
+    fn eq(&self, b: &PaymentRequirements) -> bool {
+        let a = &self.requirements;
+        a == b
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/scheme/client.rs b/bbt-x402-facilitator/crates/x402-types/src/scheme/client.rs
new file mode 100644
index 0000000..4544f1a
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/scheme/client.rs
@@ -0,0 +1,184 @@
+//! Client-side payment scheme support.
+//!
+//! This module provides types for client applications (buyers) to select and
+//! sign payments in response to 402 Payment Required responses.
+//!
+//! # Payment Flow
+//!
+//! 1. Client receives a 402 response with payment requirements
+//! 2. [`X402SchemeClient`] implementations generate [`PaymentCandidate`]s
+//! 3. A [`PaymentSelector`] chooses the best candidate
+//! 4. The candidate is signed and sent back to the server
+//!
+//! # Payment Selection
+//!
+//! Multiple selectors are available:
+//! - [`FirstMatch`] - Takes the first available option
+//! - [`PreferChain`] - Prefers specific chains in priority order
+//! - [`MaxAmount`] - Only accepts payments up to a maximum amount
+
+use alloy_primitives::U256;
+use async_trait::async_trait;
+
+use crate::chain::{ChainId, ChainIdPattern};
+use crate::proto;
+use crate::scheme::X402SchemeId;
+
+/// A payment option that can be signed and submitted.
+///
+/// Payment candidates are generated by scheme clients when they find
+/// a matching payment requirement they can fulfill.
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct PaymentCandidate {
+    /// The chain where payment will be made.
+    pub chain_id: ChainId,
+    /// The token asset address.
+    pub asset: String,
+    /// The payment amount in token units.
+    pub amount: U256,
+    /// The payment scheme name.
+    pub scheme: String,
+    /// The x402 protocol version.
+    pub x402_version: u8,
+    /// The recipient address.
+    pub pay_to: String,
+    /// The signer that can authorize this payment.
+    pub signer: Box<dyn PaymentCandidateSigner + Send + Sync>,
+}
+
+impl PaymentCandidate {
+    /// Signs this payment candidate, producing a payment payload.
+    #[allow(dead_code)] // Public for consumption by downstream crates.
+    pub async fn sign(&self) -> Result<String, X402Error> {
+        self.signer.sign_payment().await
+    }
+}
+
+/// Trait for scheme clients that can process payment requirements.
+///
+/// Implementations examine 402 responses and generate payment candidates
+/// for requirements they can fulfill.
+#[async_trait]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub trait X402SchemeClient: X402SchemeId + Send + Sync {
+    /// Generates payment candidates for the given payment requirements.
+    fn accept(&self, payment_required: &proto::PaymentRequired) -> Vec<PaymentCandidate>;
+}
+
+/// Trait for signing payment authorizations.
+#[async_trait]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub trait PaymentCandidateSigner {
+    /// Signs a payment authorization.
+    async fn sign_payment(&self) -> Result<String, X402Error>;
+}
+
+/// Errors that can occur during client-side payment processing.
+#[derive(Debug, thiserror::Error)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub enum X402Error {
+    /// No payment option matched the client's capabilities.
+    #[error("No matching payment option found")]
+    NoMatchingPaymentOption,
+
+    /// The HTTP request body cannot be cloned (e.g., streaming).
+    #[error("Request is not cloneable (streaming body?)")]
+    RequestNotCloneable,
+
+    /// Failed to parse the 402 response body.
+    #[error("Failed to parse 402 response: {0}")]
+    ParseError(String),
+
+    /// Failed to sign the payment authorization.
+    #[error("Failed to sign payment: {0}")]
+    SigningError(String),
+
+    /// JSON serialization/deserialization error.
+    #[error("JSON error: {0}")]
+    JsonError(#[from] serde_json::Error),
+}
+
+// ============================================================================
+// PaymentSelector - Selection strategy
+// ============================================================================
+
+/// Trait for selecting the best payment candidate from available options.
+///
+/// Implement this trait to customize how payments are selected when
+/// multiple options are available.
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub trait PaymentSelector: Send + Sync {
+    /// Selects a payment candidate from the available options.
+    fn select<'a>(&self, candidates: &'a [PaymentCandidate]) -> Option<&'a PaymentCandidate>;
+}
+
+/// Selector that returns the first matching candidate.
+///
+/// This is the simplest selection strategy. The order of candidates
+/// is determined by the registration order of scheme clients.
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct FirstMatch;
+
+impl PaymentSelector for FirstMatch {
+    fn select<'a>(&self, candidates: &'a [PaymentCandidate]) -> Option<&'a PaymentCandidate> {
+        candidates.first()
+    }
+}
+
+/// Selector that prefers specific chains in priority order.
+///
+/// Patterns are tried in order; the first matching candidate is returned.
+/// If no patterns match, falls back to the first available candidate.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_types::scheme::client::PreferChain;
+/// use x402_types::chain::ChainIdPattern;
+///
+/// // Prefer Base, then any EVM chain, then anything else
+/// let selector = PreferChain::new(vec![
+///     "eip155:8453".parse().unwrap(),  // Base mainnet
+///     "eip155:*".parse().unwrap(),     // Any EVM chain
+/// ]);
+/// ```
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct PreferChain(Vec<ChainIdPattern>);
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl PreferChain {
+    /// Creates a new chain preference selector.
+    pub fn new<P: Into<Vec<ChainIdPattern>>>(patterns: P) -> Self {
+        Self(patterns.into())
+    }
+
+    /// Adds additional chain patterns with lower priority.
+    pub fn or_chain<P: Into<Vec<ChainIdPattern>>>(self, patterns: P) -> PreferChain {
+        PreferChain(self.0.into_iter().chain(patterns.into()).collect())
+    }
+}
+
+impl PaymentSelector for PreferChain {
+    fn select<'a>(&self, candidates: &'a [PaymentCandidate]) -> Option<&'a PaymentCandidate> {
+        // Try each pattern in priority order
+        for pattern in &self.0 {
+            if let Some(candidate) = candidates.iter().find(|c| pattern.matches(&c.chain_id)) {
+                return Some(candidate);
+            }
+        }
+        // Fall back to first match if no patterns matched
+        candidates.first()
+    }
+}
+
+/// Selector that only accepts payments up to a maximum amount.
+///
+/// Useful for limiting spending or implementing budget controls.
+#[allow(dead_code)]
+pub struct MaxAmount(pub U256);
+
+impl PaymentSelector for MaxAmount {
+    fn select<'a>(&self, candidates: &'a [PaymentCandidate]) -> Option<&'a PaymentCandidate> {
+        candidates.iter().find(|c| c.amount <= self.0)
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/scheme/mod.rs b/bbt-x402-facilitator/crates/x402-types/src/scheme/mod.rs
new file mode 100644
index 0000000..0f9435e
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/scheme/mod.rs
@@ -0,0 +1,339 @@
+//! Payment scheme implementations for x402.
+//!
+//! This module provides the extensible scheme system that allows different
+//! payment methods to be plugged into the x402 protocol. Each scheme defines
+//! how payments are authorized, verified, and settled.
+//!
+//! # Architecture
+//!
+//! The scheme system has three main components:
+//!
+//! 1. **Blueprints** ([`SchemeBlueprints`]) - Factories that create scheme handlers
+//! 2. **Handlers** ([`X402SchemeFacilitator`]) - Process verify/settle requests
+//! 3. **Registry** ([`SchemeRegistry`]) - Maps chain+scheme combinations to handlers
+//!
+//! # Available Schemes
+//!
+//! Scheme implementations are provided by chain-specific crates:
+//!
+//! - **EVM chains** (`x402-chain-eip155`): `v1-eip155-exact`, `v2-eip155-exact`
+//! - **Solana** (`x402-chain-solana`): `v1-solana-exact`, `v2-solana-exact`
+//! - **Aptos** (`x402-chain-aptos`): `v2-aptos-exact`
+//!
+//! # Implementing a Custom Scheme
+//!
+//! To implement a custom scheme:
+//!
+//! 1. Implement [`X402SchemeId`] to identify your scheme
+//! 2. Implement [`X402SchemeFacilitatorBuilder`] to create handlers
+//! 3. Implement [`X402SchemeFacilitator`] for the actual verification/settlement logic
+//! 4. Register your scheme with [`SchemeBlueprints::register`]
+//!
+//! See the `docs/how-to-write-a-scheme.md` guide in the repository for details.
+
+pub mod client;
+
+use crate::chain::{ChainId, ChainIdPattern, ChainProviderOps, ChainRegistry};
+use crate::proto;
+use crate::proto::{AsPaymentProblem, ErrorReason, PaymentProblem, PaymentVerificationError};
+use serde::{Deserialize, Serialize};
+use std::collections::HashMap;
+use std::fmt::{Debug, Display, Formatter};
+use std::marker::PhantomData;
+use std::ops::Deref;
+
+/// Trait for scheme handlers that process payment verification and settlement.
+///
+/// Implementations of this trait handle the core payment processing logic:
+/// verifying that payments are valid and settling them on-chain.
+#[async_trait::async_trait]
+pub trait X402SchemeFacilitator: Send + Sync {
+    /// Verifies a payment authorization without settling it.
+    ///
+    /// This checks that the payment is properly signed, matches the requirements,
+    /// and the payer has sufficient funds.
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, X402SchemeFacilitatorError>;
+
+    /// Settles a verified payment on-chain.
+    ///
+    /// This submits the payment transaction to the blockchain and waits
+    /// for confirmation.
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, X402SchemeFacilitatorError>;
+
+    /// Returns the payment methods supported by this handler.
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError>;
+}
+
+/// Marker trait for types that are both identifiable and buildable.
+///
+/// This combines [`X402SchemeId`] and [`X402SchemeFacilitatorBuilder`] for
+/// use in the blueprint registry.
+pub trait X402SchemeBlueprint<P>:
+    X402SchemeId + for<'a> X402SchemeFacilitatorBuilder<&'a P>
+{
+}
+impl<T, P> X402SchemeBlueprint<P> for T where
+    T: X402SchemeId + for<'a> X402SchemeFacilitatorBuilder<&'a P>
+{
+}
+
+/// Trait for identifying a payment scheme.
+///
+/// Each scheme has a unique identifier composed of the protocol version,
+/// chain namespace, and scheme name.
+pub trait X402SchemeId {
+    /// Returns the x402 protocol version (1 or 2).
+    fn x402_version(&self) -> u8 {
+        2
+    }
+    /// Returns the chain namespace (e.g., "eip155", "solana").
+    fn namespace(&self) -> &str;
+    /// Returns the scheme name (e.g., "exact").
+    fn scheme(&self) -> &str;
+    /// Returns the full scheme identifier (e.g., "v2-eip155-exact").
+    fn id(&self) -> String {
+        format!(
+            "v{}-{}-{}",
+            self.x402_version(),
+            self.namespace(),
+            self.scheme(),
+        )
+    }
+}
+
+/// Trait for building scheme handlers from chain providers.
+///
+/// The type parameter `P` represents the chain provider type.
+/// Implementations use ['FromChainProvider'] trait to get the specific provider they need.
+pub trait X402SchemeFacilitatorBuilder<P> {
+    /// Creates a new scheme handler for the given chain provider.
+    ///
+    /// # Arguments
+    ///
+    /// * `provider` - The chain provider to use for on-chain operations
+    /// * `config` - Optional scheme-specific configuration
+    fn build(
+        &self,
+        provider: P,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>>;
+}
+
+/// Errors that can occur during scheme operations.
+#[derive(Debug, thiserror::Error)]
+pub enum X402SchemeFacilitatorError {
+    /// Payment verification failed.
+    #[error(transparent)]
+    PaymentVerification(#[from] PaymentVerificationError),
+    /// On-chain operation failed.
+    #[error("Onchain error: {0}")]
+    OnchainFailure(String),
+}
+
+impl AsPaymentProblem for X402SchemeFacilitatorError {
+    fn as_payment_problem(&self) -> PaymentProblem {
+        match self {
+            X402SchemeFacilitatorError::PaymentVerification(e) => e.as_payment_problem(),
+            X402SchemeFacilitatorError::OnchainFailure(e) => {
+                PaymentProblem::new(ErrorReason::UnexpectedError, e.to_string())
+            }
+        }
+    }
+}
+
+/// Registry of scheme blueprints (factories).
+///
+/// Blueprints are used to create scheme handlers for specific chain providers.
+/// Register blueprints at startup, then use them to build handlers.
+///
+/// # Type Parameters
+///
+/// - `P` - The chain provider type that blueprints can extract from using [`FromChainProvider`]
+#[derive(Default)]
+pub struct SchemeBlueprints<P>(
+    HashMap<String, Box<dyn X402SchemeBlueprint<P>>>,
+    PhantomData<P>,
+);
+
+impl<P> Debug for SchemeBlueprints<P> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        let slugs: Vec<String> = self.0.keys().map(|s| s.to_string()).collect();
+        f.debug_tuple("SchemeBlueprints").field(&slugs).finish()
+    }
+}
+
+impl<P> SchemeBlueprints<P> {
+    /// Creates an empty blueprint registry.
+    pub fn new() -> Self {
+        Self(HashMap::new(), PhantomData)
+    }
+
+    /// Registers a blueprint and returns self for chaining.
+    pub fn and_register<B: X402SchemeBlueprint<P> + 'static>(mut self, blueprint: B) -> Self {
+        self.register(blueprint);
+        self
+    }
+
+    /// Registers a scheme blueprint.
+    pub fn register<B: X402SchemeBlueprint<P> + 'static>(&mut self, blueprint: B) {
+        self.0.insert(blueprint.id(), Box::new(blueprint));
+    }
+
+    /// Gets a blueprint by its ID.
+    pub fn get(&self, id: &str) -> Option<&dyn X402SchemeBlueprint<P>> {
+        self.0.get(id).map(|v| v.deref())
+    }
+}
+
+/// Unique identifier for a scheme handler instance.
+///
+/// Combines the chain ID, protocol version, and scheme name to uniquely
+/// identify a handler that can process payments for a specific combination.
+#[derive(Debug, PartialEq, Eq, Hash, Clone)]
+pub struct SchemeHandlerSlug {
+    /// The chain this handler operates on.
+    pub chain_id: ChainId,
+    /// The x402 protocol version.
+    pub x402_version: u8,
+    /// The scheme name (e.g., "exact").
+    pub name: String,
+}
+
+impl SchemeHandlerSlug {
+    /// Creates a new scheme handler slug.
+    pub fn new(chain_id: ChainId, x402_version: u8, name: String) -> Self {
+        Self {
+            chain_id,
+            x402_version,
+            name,
+        }
+    }
+}
+
+impl Display for SchemeHandlerSlug {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(
+            f,
+            "{}:{}:v{}:{}",
+            self.chain_id.namespace, self.chain_id.reference, self.x402_version, self.name
+        )
+    }
+}
+
+/// Registry of active scheme handlers.
+///
+/// Maps chain+scheme combinations to their handlers. Built from blueprints
+/// and chain providers based on configuration.
+#[derive(Default)]
+pub struct SchemeRegistry(HashMap<SchemeHandlerSlug, Box<dyn X402SchemeFacilitator>>);
+
+impl Debug for SchemeRegistry {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        let slugs: Vec<String> = self.0.keys().map(|s| s.to_string()).collect();
+        f.debug_tuple("SchemeRegistry").field(&slugs).finish()
+    }
+}
+
+impl SchemeRegistry {
+    /// Builds a scheme registry from blueprints and configuration.
+    ///
+    /// For each enabled scheme in the config, this finds the matching blueprint
+    /// and chain provider, then builds a handler.
+    pub fn build<P: ChainProviderOps>(
+        chains: ChainRegistry<P>,
+        blueprints: SchemeBlueprints<P>,
+        config: &Vec<SchemeConfig>,
+    ) -> Self {
+        let mut handlers = HashMap::with_capacity(config.len());
+        for config in config {
+            if !config.enabled {
+                #[cfg(feature = "telemetry")]
+                tracing::info!(
+                    "Skipping disabled scheme {} for chains {}",
+                    config.id,
+                    config.chains
+                );
+                continue;
+            }
+            let blueprint = match blueprints.get(&config.id) {
+                Some(blueprint) => blueprint,
+                None => {
+                    #[cfg(feature = "telemetry")]
+                    tracing::warn!("No scheme registered: {}", config.id);
+                    continue;
+                }
+            };
+            let chain_providers = chains.by_chain_id_pattern(&config.chains);
+            if chain_providers.is_empty() {
+                #[cfg(feature = "telemetry")]
+                tracing::warn!("No chain provider found for {}", config.chains);
+                continue;
+            }
+
+            for chain_provider in chain_providers {
+                let chain_id = chain_provider.chain_id();
+                let handler = match blueprint.build(chain_provider, config.config.clone()) {
+                    Ok(handler) => handler,
+                    Err(_err) => {
+                        #[cfg(feature = "telemetry")]
+                        tracing::error!(
+                            "Error building scheme handler for {}: {}",
+                            config.id,
+                            _err
+                        );
+                        continue;
+                    }
+                };
+                let slug = SchemeHandlerSlug::new(
+                    chain_id.clone(),
+                    blueprint.x402_version(),
+                    blueprint.scheme().to_string(),
+                );
+                #[cfg(feature = "telemetry")]
+                tracing::info!(chain_id = %chain_id, scheme = %blueprint.scheme(), id=blueprint.id(), "Registered scheme handler");
+                handlers.insert(slug, handler);
+            }
+        }
+        Self(handlers)
+    }
+
+    /// Gets a handler by its slug.
+    pub fn by_slug(&self, slug: &SchemeHandlerSlug) -> Option<&dyn X402SchemeFacilitator> {
+        let handler = self.0.get(slug)?.deref();
+        Some(handler)
+    }
+
+    /// Returns an iterator over all registered handlers.
+    pub fn values(&self) -> impl Iterator<Item = &dyn X402SchemeFacilitator> {
+        self.0.values().map(|v| v.deref())
+    }
+}
+
+/// Configuration for a specific scheme.
+///
+/// Each scheme entry specifies which scheme to use and which chains it applies to.
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct SchemeConfig {
+    /// Whether this scheme is enabled (defaults to true).
+    #[serde(default = "scheme_config_defaults::default_enabled")]
+    pub enabled: bool,
+    /// The scheme id (e.g., "v1-eip155-exact").
+    pub id: String,
+    /// The chain pattern this scheme applies to (e.g., "eip155:84532", "eip155:*", "eip155:{1,8453}").
+    pub chains: ChainIdPattern,
+    /// Scheme-specific configuration (optional).
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub config: Option<serde_json::Value>,
+}
+
+mod scheme_config_defaults {
+    pub fn default_enabled() -> bool {
+        true
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/timestamp.rs b/bbt-x402-facilitator/crates/x402-types/src/timestamp.rs
new file mode 100644
index 0000000..96b89ea
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/timestamp.rs
@@ -0,0 +1,132 @@
+//! Unix timestamp utilities for x402 payment authorization windows.
+//!
+//! This module provides the [`UnixTimestamp`] type used throughout the x402 protocol
+//! to represent time-bounded payment authorizations. Timestamps are used in ERC-3009
+//! `transferWithAuthorization` messages and Solana payment instructions to specify
+//! when a payment authorization becomes valid and when it expires.
+
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use std::fmt::{Display, Formatter};
+use std::ops::Add;
+use std::time::SystemTime;
+
+/// A Unix timestamp representing seconds since the Unix epoch (1970-01-01T00:00:00Z).
+///
+/// This type is used throughout the x402 protocol for time-bounded payment authorizations:
+///
+/// - **`validAfter`**: The earliest time a payment authorization can be executed
+/// - **`validBefore`**: The latest time a payment authorization remains valid
+///
+/// # Serialization
+///
+/// Serialized as a stringified integer to avoid loss of precision in JSON, since
+/// JavaScript's `Number` type cannot safely represent all 64-bit integers.
+///
+/// ```json
+/// "1699999999"
+/// ```
+///
+/// # Example
+///
+/// ```
+/// use x402_types::timestamp::UnixTimestamp;
+///
+/// // Create a timestamp for "now"
+/// let now = UnixTimestamp::now();
+///
+/// // Create a timestamp 1 hour in the future
+/// let expires = now + 3600;
+///
+/// // Create from a specific value
+/// let specific = UnixTimestamp::from_secs(1699999999);
+/// assert_eq!(specific.as_secs(), 1699999999);
+/// ```
+#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Ord, Eq)]
+pub struct UnixTimestamp(u64);
+
+impl Serialize for UnixTimestamp {
+    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
+        serializer.serialize_str(&self.0.to_string())
+    }
+}
+
+impl<'de> Deserialize<'de> for UnixTimestamp {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        let ts = s
+            .parse::<u64>()
+            .map_err(|_| serde::de::Error::custom("timestamp must be a non-negative integer"))?;
+        Ok(UnixTimestamp(ts))
+    }
+}
+
+impl Display for UnixTimestamp {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl Add<u64> for UnixTimestamp {
+    type Output = Self;
+
+    fn add(self, rhs: u64) -> Self::Output {
+        UnixTimestamp(self.0 + rhs)
+    }
+}
+
+impl UnixTimestamp {
+    /// Creates a new [`UnixTimestamp`] from a raw seconds value.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::timestamp::UnixTimestamp;
+    ///
+    /// let ts = UnixTimestamp::from_secs(1699999999);
+    /// assert_eq!(ts.as_secs(), 1699999999);
+    /// ```
+    pub fn from_secs(secs: u64) -> Self {
+        Self(secs)
+    }
+
+    /// Returns the current system time as a [`UnixTimestamp`].
+    ///
+    /// # Panics
+    ///
+    /// Panics if the system clock is set to a time before the Unix epoch,
+    /// which should never happen on properly configured systems.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::timestamp::UnixTimestamp;
+    ///
+    /// let now = UnixTimestamp::now();
+    /// // Timestamp should be after year 2020
+    /// assert!(now.as_secs() > 1577836800);
+    /// ```
+    pub fn now() -> Self {
+        let now = SystemTime::now()
+            .duration_since(SystemTime::UNIX_EPOCH)
+            .expect("SystemTime before UNIX epoch?!?")
+            .as_secs();
+        Self(now)
+    }
+
+    /// Returns the timestamp as raw seconds since the Unix epoch.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// use x402_types::timestamp::UnixTimestamp;
+    ///
+    /// let ts = UnixTimestamp::from_secs(1699999999);
+    /// assert_eq!(ts.as_secs(), 1699999999);
+    /// ```
+    pub fn as_secs(&self) -> u64 {
+        self.0
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/util/b64.rs b/bbt-x402-facilitator/crates/x402-types/src/util/b64.rs
new file mode 100644
index 0000000..1bdd0fe
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/util/b64.rs
@@ -0,0 +1,66 @@
+//! Base64 encoding and decoding utilities.
+//!
+//! This module provides [`Base64Bytes`], a wrapper type for working with
+//! base64-encoded data in the x402 protocol.
+
+use base64::Engine;
+use base64::engine::general_purpose::STANDARD as b64;
+use std::borrow::Cow;
+use std::fmt::Display;
+
+/// A wrapper for base64-encoded byte data.
+///
+/// This type holds bytes that represent base64-encoded data and provides
+/// methods for encoding and decoding. It uses copy-on-write semantics
+/// to avoid unnecessary allocations.
+///
+/// # Example
+///
+/// ```rust
+/// use x402_types::util::Base64Bytes;
+///
+/// // Encode some data
+/// let encoded = Base64Bytes::encode(b"hello world");
+/// assert_eq!(encoded.to_string(), "aGVsbG8gd29ybGQ=");
+///
+/// // Decode it back
+/// let decoded = encoded.decode().unwrap();
+/// assert_eq!(decoded, b"hello world");
+/// ```
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct Base64Bytes<'a>(pub Cow<'a, [u8]>);
+
+impl Base64Bytes<'_> {
+    /// Decodes the base64 string bytes to raw binary data.
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if the data is not valid base64.
+    pub fn decode(&self) -> Result<Vec<u8>, base64::DecodeError> {
+        b64.decode(&self.0)
+    }
+
+    /// Encodes raw binary data into base64 string bytes.
+    pub fn encode<T: AsRef<[u8]>>(input: T) -> Base64Bytes<'static> {
+        let encoded = b64.encode(input.as_ref());
+        Base64Bytes(Cow::Owned(encoded.into_bytes()))
+    }
+}
+
+impl AsRef<[u8]> for Base64Bytes<'_> {
+    fn as_ref(&self) -> &[u8] {
+        self.0.as_ref()
+    }
+}
+
+impl<'a> From<&'a [u8]> for Base64Bytes<'a> {
+    fn from(slice: &'a [u8]) -> Self {
+        Base64Bytes(Cow::Borrowed(slice))
+    }
+}
+
+impl Display for Base64Bytes<'_> {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", String::from_utf8_lossy(self.0.as_ref()))
+    }
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/util/lit_str.rs b/bbt-x402-facilitator/crates/x402-types/src/util/lit_str.rs
new file mode 100644
index 0000000..b14caa1
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/util/lit_str.rs
@@ -0,0 +1,85 @@
+//! Compile-time string literal type generation.
+//!
+//! This module provides the [`lit_str!`](macro@lit_str) macro for creating types that
+//! represent specific string literals at compile time. These types are
+//! useful for ensuring type safety when working with fixed string values
+//! in protocol messages.
+//!
+//! # Example
+//!
+//! ```rust
+//! use x402_types::lit_str;
+//!
+//! lit_str!(ExactScheme, "exact");
+//!
+//! // The type only accepts the exact string
+//! let scheme: ExactScheme = "exact".parse().unwrap();
+//! assert_eq!(scheme.to_string(), "exact");
+//!
+//! // Other strings are rejected
+//! assert!("other".parse::<ExactScheme>().is_err());
+//! ```
+
+/// Creates a type that represents a specific string literal.
+///
+/// The generated type:
+/// - Has a `VALUE` constant with the string
+/// - Implements `FromStr` (only accepts the exact string)
+/// - Implements `Serialize`/`Deserialize` (as the string)
+/// - Implements `Display` (outputs the string)
+#[macro_export]
+macro_rules! lit_str {
+    ($struct_name:ident, $val:expr) => {
+        #[doc = concat!("A unit struct representing the string literal \"", $val, "\".")]
+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+        pub struct $struct_name;
+
+        impl $struct_name {
+            pub const VALUE: &'static str = $val;
+        }
+
+        impl AsRef<str> for $struct_name {
+            fn as_ref(&self) -> &str {
+                Self::VALUE
+            }
+        }
+
+        impl std::str::FromStr for $struct_name {
+            type Err = String;
+            fn from_str(s: &str) -> Result<Self, Self::Err> {
+                if s == Self::VALUE {
+                    Ok($struct_name)
+                } else {
+                    Err(format!("expected '{}', got '{}'", Self::VALUE, s))
+                }
+            }
+        }
+
+        impl serde::Serialize for $struct_name {
+            fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
+                serializer.serialize_str(Self::VALUE)
+            }
+        }
+
+        impl<'de> serde::Deserialize<'de> for $struct_name {
+            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
+                let s = String::deserialize(deserializer)?;
+                if s == Self::VALUE {
+                    Ok($struct_name)
+                } else {
+                    Err(serde::de::Error::custom(format!(
+                        "expected '{}', got '{}'",
+                        Self::VALUE,
+                        s
+                    )))
+                }
+            }
+        }
+
+        impl std::fmt::Display for $struct_name {
+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                write!(f, $val)
+            }
+        }
+    };
+}
diff --git a/bbt-x402-facilitator/crates/x402-types/src/util/mod.rs b/bbt-x402-facilitator/crates/x402-types/src/util/mod.rs
new file mode 100644
index 0000000..f54a7b0
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/util/mod.rs
@@ -0,0 +1,13 @@
+//! Utility types and functions for x402.
+//!
+//! This module provides various helper types used throughout the x402 crate:
+//!
+//! - [`b64`] - Base64 encoding/decoding utilities
+//! - [`lit_str`] - Compile-time string literal types
+//! - [`money_amount`] - Human-readable currency amount parsing
+
+pub mod b64;
+pub mod lit_str;
+pub mod money_amount;
+
+pub use b64::*;
diff --git a/bbt-x402-facilitator/crates/x402-types/src/util/money_amount.rs b/bbt-x402-facilitator/crates/x402-types/src/util/money_amount.rs
new file mode 100644
index 0000000..2d69a93
--- /dev/null
+++ b/bbt-x402-facilitator/crates/x402-types/src/util/money_amount.rs
@@ -0,0 +1,180 @@
+//! Human-readable currency amount parsing.
+//!
+//! This module provides [`MoneyAmount`], a type for parsing human-readable
+//! currency strings into precise decimal values suitable for conversion to
+//! on-chain token amounts.
+//!
+//! # Supported Formats
+//!
+//! - Plain numbers: `"100"`, `"0.01"`
+//! - With currency symbols: `"$10.50"`, `"â‚¬20"`
+//! - With thousand separators: `"1,000"`, `"1,000,000.50"`
+//!
+//! # Example
+//!
+//! ```rust
+//! use x402_types::util::money_amount::MoneyAmount;
+//!
+//! let amount = MoneyAmount::parse("$10.50").unwrap();
+//! assert_eq!(amount.scale(), 2);  // 2 decimal places
+//! assert_eq!(amount.mantissa(), 1050);  // 10.50 as integer
+//! ```
+
+use regex::Regex;
+use rust_decimal::Decimal;
+use rust_decimal::prelude::FromPrimitive;
+use std::fmt;
+use std::fmt::Display;
+use std::str::FromStr;
+
+/// A parsed monetary amount with decimal precision.
+///
+/// This type represents a non-negative decimal value parsed from a
+/// human-readable string. It preserves the original precision, which
+/// is important when converting to token amounts with specific decimal places.
+///
+/// # Precision
+///
+/// The [`scale`](MoneyAmount::scale) method returns the number of decimal places,
+/// and [`mantissa`](MoneyAmount::mantissa) returns the value as an integer.
+/// For example, `"10.50"` has scale 2 and mantissa 1050.
+#[derive(Debug, Clone, PartialEq)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub struct MoneyAmount(pub Decimal);
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl MoneyAmount {
+    /// Returns the number of decimal places in the original input.
+    ///
+    /// This is used to verify that the input precision doesn't exceed
+    /// the token's decimal places.
+    pub fn scale(&self) -> u32 {
+        self.0.scale()
+    }
+
+    /// Returns the value as an unsigned integer (without decimal point).
+    ///
+    /// For example, `"12.34"` returns `1234`.
+    pub fn mantissa(&self) -> u128 {
+        self.0.mantissa().unsigned_abs()
+    }
+}
+
+/// Errors that can occur when parsing a monetary amount.
+#[derive(Debug, thiserror::Error)]
+#[allow(dead_code)] // Public for consumption by downstream crates.
+pub enum MoneyAmountParseError {
+    /// The input string could not be parsed as a number.
+    #[error("Invalid number format")]
+    InvalidFormat,
+    /// The value is outside the allowed range.
+    #[error(
+        "Amount must be between {} and {}",
+        constants::MIN_STR,
+        constants::MAX_STR
+    )]
+    OutOfRange,
+    /// Negative values are not allowed.
+    #[error("Negative value is not allowed")]
+    Negative,
+    /// The input has more decimal places than the token supports.
+    #[error("Too big of a precision: {money} vs {token} on token")]
+    WrongPrecision {
+        /// Decimal places in the input.
+        money: u32,
+        /// Decimal places supported by the token.
+        token: u32,
+    },
+}
+
+mod constants {
+    use super::*;
+    use std::sync::LazyLock;
+
+    pub const MIN_STR: &str = "0.000000001";
+    pub const MAX_STR: &str = "999999999";
+
+    pub static MIN: LazyLock<Decimal> =
+        LazyLock::new(|| Decimal::from_str(MIN_STR).expect("valid decimal"));
+    pub static MAX: LazyLock<Decimal> =
+        LazyLock::new(|| Decimal::from_str(MAX_STR).expect("valid decimal"));
+}
+
+#[allow(dead_code)] // Public for consumption by downstream crates.
+impl MoneyAmount {
+    /// Parses a human-readable currency string into a [`MoneyAmount`].
+    ///
+    /// Currency symbols, thousand separators, and whitespace are stripped
+    /// before parsing. The result must be a non-negative number within
+    /// the allowed range.
+    ///
+    /// # Errors
+    ///
+    /// Returns an error if:
+    /// - The string cannot be parsed as a number
+    /// - The value is negative
+    /// - The value is outside the allowed range
+    pub fn parse(input: &str) -> Result<Self, MoneyAmountParseError> {
+        // Remove anything that isn't digit, dot, minus
+        let cleaned = Regex::new(r"[^\d\.\-]+")
+            .unwrap()
+            .replace_all(input, "")
+            .to_string();
+
+        let parsed =
+            Decimal::from_str(&cleaned).map_err(|_| MoneyAmountParseError::InvalidFormat)?;
+
+        if parsed.is_sign_negative() {
+            return Err(MoneyAmountParseError::Negative);
+        }
+
+        if parsed < *constants::MIN || parsed > *constants::MAX {
+            return Err(MoneyAmountParseError::OutOfRange);
+        }
+
+        Ok(MoneyAmount(parsed))
+    }
+}
+
+impl FromStr for MoneyAmount {
+    type Err = MoneyAmountParseError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        MoneyAmount::parse(s)
+    }
+}
+
+impl TryFrom<&str> for MoneyAmount {
+    type Error = MoneyAmountParseError;
+
+    fn try_from(value: &str) -> Result<Self, Self::Error> {
+        MoneyAmount::from_str(value)
+    }
+}
+
+impl From<u128> for MoneyAmount {
+    fn from(value: u128) -> Self {
+        MoneyAmount(Decimal::from(value))
+    }
+}
+
+impl TryFrom<f64> for MoneyAmount {
+    type Error = MoneyAmountParseError;
+
+    fn try_from(value: f64) -> Result<Self, Self::Error> {
+        let decimal = Decimal::from_f64(value).ok_or(MoneyAmountParseError::OutOfRange)?;
+        if decimal.is_sign_negative() {
+            return Err(MoneyAmountParseError::Negative);
+        }
+        if decimal < *constants::MIN || decimal > *constants::MAX {
+            return Err(MoneyAmountParseError::OutOfRange);
+        }
+        Ok(MoneyAmount(decimal))
+    }
+}
+
+impl Display for MoneyAmount {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}", self.0.normalize())
+    }
+}
diff --git a/bbt-x402-facilitator/docs/build-your-own-facilitator.md b/bbt-x402-facilitator/docs/build-your-own-facilitator.md
new file mode 100644
index 0000000..d16e05d
--- /dev/null
+++ b/bbt-x402-facilitator/docs/build-your-own-facilitator.md
@@ -0,0 +1,428 @@
+# Build Your Own Facilitator
+
+This guide explains how to build a custom x402 facilitator implementation using the x402-rs ecosystem.
+
+## Overview
+
+A facilitator is a service that:
+- **Verifies** payment payloads signed by clients
+- **Settles** payments on-chain
+- **Manages** blockchain connections and signers
+
+The x402-rs ecosystem provides building blocks to create custom facilitators tailored to your needs.
+
+## Why Build a Custom Facilitator?
+
+You might want to build a custom facilitator for several reasons:
+
+1. **Support for custom blockchains** â€” You need to support a blockchain that is not yet supported by the official x402-rs crates. This involves implementing a custom chain provider and adapting the payment schemes to work with it.
+
+2. **Custom chain provider behavior** â€” You want to customize how the facilitator interacts with a supported chain. For example, you might want to implement a custom `Eip155MetaTransactionProvider` for EVM chains to add custom transaction signing logic, gas pricing strategies, or nonce management.
+
+3. **Chain-specific deployment** â€” You want to run a facilitator that only supports specific chains or schemes, reducing the binary size and attack surface. This can be achieved through feature flags in the `facilitator` crate or by creating a minimal custom facilitator.
+
+4. **Custom middleware or authentication** â€” You need to add custom HTTP middleware, authentication, or logging that is specific to your infrastructure.
+
+5. **Integration with existing infrastructure** â€” You want to integrate the x402 facilitator into an existing application or service, rather than running it as a standalone binary.
+
+## Architecture
+
+The facilitator architecture consists of:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚         Your HTTP Server                â”‚
+â”‚      (Axum, Actix, Rocket, etc.)        â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                 â”‚
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚    x402-facilitator-local               â”‚
+â”‚  (Verification & Settlement Logic)      â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                 â”‚
+     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+     â”‚                         â”‚
+â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
+â”‚ Chain      â”‚        â”‚ Scheme      â”‚
+â”‚ Registry   â”‚        â”‚ Registry    â”‚
+â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
+    â”‚                        â”‚
+    â”œâ”€ EIP-155 Provider      â”œâ”€ V1Eip155Exact
+    â”œâ”€ Solana Provider       â”œâ”€ V2Eip155Exact
+    â””â”€ Aptos Provider        â”œâ”€ V1SolanaExact
+                             â”œâ”€ V2SolanaExact
+                             â””â”€ V2AptosExact
+```
+
+## Getting Started
+
+### 1. Add Dependencies
+
+> **Note:** The versions shown below are indicative. Please check the latest versions on [crates.io](https://crates.io) or the source repository if the packages are not published on crates.io.
+
+```toml
+[dependencies]
+x402-types = { version = "1.0", features = ["cli"] }
+x402-facilitator-local = { version = "1.0" }
+x402-chain-eip155 = { version = "1.0", features = ["facilitator"] }
+x402-chain-solana = { version = "1.0", features = ["facilitator"] }
+
+dotenvy = "0.15"
+serde_json = "1.0"
+tokio = { version = "1.35", features = ["full"] }
+async-trait = "0.1"
+axum = "0.8"
+tower-http = "0.9"
+rustls = { version = "0.23", features = ["ring"] }
+```
+
+### 2. Initialize the Facilitator
+
+```rust
+use x402_facilitator_local::{FacilitatorLocal, handlers};
+use x402_types::chain::{ChainRegistry, FromConfig};
+use x402_types::scheme::{SchemeBlueprints, SchemeRegistry};
+use x402_chain_eip155::{V1Eip155Exact, V2Eip155Exact};
+use x402_chain_solana::{V1SolanaExact, V2SolanaExact};
+use std::sync::Arc;
+use axum::Router;
+use tower_http::cors;
+use axum::http::Method;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    // Initialize rustls crypto provider
+    rustls::crypto::CryptoProvider::install_default(
+        rustls::crypto::ring::default_provider()
+    ).expect("Failed to initialize rustls crypto provider");
+
+    // Load .env variables
+    dotenvy::dotenv().ok();
+
+    // Load configuration
+    let config = Config::load()?;
+
+    // Initialize chain registry from config
+    let chain_registry = ChainRegistry::from_config(config.chains()).await?;
+
+    // Register supported schemes
+    let scheme_blueprints = {
+        let mut blueprints = SchemeBlueprints::new();
+        blueprints.register(V1Eip155Exact);
+        blueprints.register(V2Eip155Exact);
+        blueprints.register(V1SolanaExact);
+        blueprints.register(V2SolanaExact);
+        blueprints
+    };
+
+    // Build scheme registry
+    let scheme_registry =
+        SchemeRegistry::build(chain_registry, scheme_blueprints, config.schemes());
+
+    // Create facilitator
+    let facilitator = FacilitatorLocal::new(scheme_registry);
+    let state = Arc::new(facilitator);
+
+    // Create HTTP routes with CORS
+    let app = Router::new()
+        .merge(handlers::routes().with_state(state))
+        .layer(
+            cors::CorsLayer::new()
+                .allow_origin(cors::Any)
+                .allow_methods([Method::GET, Method::POST])
+                .allow_headers(cors::Any),
+        );
+
+    // Run server
+    let addr = SocketAddr::new(config.host(), config.port());
+    let listener = tokio::net::TcpListener::bind(addr).await?;
+    axum::serve(listener, app).await?;
+
+    Ok(())
+}
+```
+
+### 3. Configuration
+
+Create a `config.json` file:
+
+```json
+{
+  "port": 9090,
+  "host": "0.0.0.0",
+  "chains": {
+    "eip155:8453": {
+      "eip1559": true,
+      "flashblocks": true,
+      "signers": ["$FACILITATOR_PRIVATE_KEY"],
+      "rpc": [
+        {
+          "http": "https://mainnet.base.org",
+          "rate_limit": 100
+        }
+      ]
+    },
+    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "signer": "$SOLANA_PRIVATE_KEY",
+      "rpc": "https://api.mainnet-beta.solana.com",
+      "pubsub": "wss://api.mainnet-beta.solana.com"
+    }
+  },
+  "schemes": [
+    {
+      "id": "v1-eip155-exact",
+      "chains": "eip155:*"
+    },
+    {
+      "id": "v2-eip155-exact",
+      "chains": "eip155:*"
+    },
+    {
+      "id": "v1-solana-exact",
+      "chains": "solana:*"
+    },
+    {
+      "id": "v2-solana-exact",
+      "chains": "solana:*"
+    }
+  ]
+}
+```
+
+## Advanced Customization
+
+### Custom Scheme Implementation
+
+To implement a custom payment scheme:
+
+1. Implement the `X402SchemeFacilitator` trait from `x402-types`
+2. Implement the `X402SchemeFacilitatorBuilder` trait
+3. Implement the `X402SchemeId` trait
+4. Register it with the `SchemeBlueprints`
+
+See the [How to Write a Scheme](./how-to-write-a-scheme.md) guide for detailed instructions.
+
+### Custom Chain Support
+
+To add support for a new blockchain that is not yet supported by x402-rs:
+
+1. **Implement the `ChainProviderOps` trait** for your provider type. This trait provides basic operations like getting signer addresses and chain ID.
+
+2. **Implement the `FromConfig` trait** to construct your provider from configuration. This allows your provider to be initialized from the JSON configuration file.
+
+3. **Create scheme implementations for your chain**. For each scheme you want to support (e.g., `exact`), implement the `X402SchemeFacilitator` trait. Your scheme will use your custom chain provider to interact with the blockchain.
+
+4. **Register with the `ChainRegistry`**. Add your chain provider to the registry so it can be discovered by the scheme registry.
+
+5. **Add the scheme to your facilitator's `schemes.rs`**. Similar to how the `facilitator` crate has a `schemes.rs` file that implements `X402SchemeFacilitatorBuilder` for each scheme, you'll need to add your scheme there to bridge the generic `ChainProvider` enum to your chain-specific provider type.
+
+### Custom Chain Provider for Supported Chains
+
+Even for supported chains like EIP-155 (EVM), you might want to customize the chain provider behavior. The EIP-155 schemes use the `Eip155MetaTransactionProvider` trait to send transactions. You can implement this trait to customize:
+
+- **Transaction signing logic** â€” Add custom signature validation or multi-sig support
+- **Gas pricing strategies** â€” Implement dynamic gas pricing based on network conditions
+- **Nonce management** â€” Customize how nonces are tracked and reset
+- **Transaction submission** â€” Add retry logic, batching, or fallback to different RPC endpoints
+
+To do this:
+
+1. Create a new type that wraps or replaces `Eip155ChainProvider`
+2. Implement `Eip155MetaTransactionProvider` for your type
+3. Implement `ChainProviderOps` and `FromConfig` for your type
+4. Use your custom provider when building the `ChainRegistry`
+
+### Chain-Specific Facilitator Deployment
+
+If you want to run a facilitator that only supports specific chains (e.g., only Solana, only EVM chains), you have two options:
+
+**Option 1: Use the `facilitator` crate with feature flags**
+
+The `facilitator` crate supports feature flags to enable only specific chains. Since this crate is not published on crates.io, use a git dependency:
+
+```toml
+[dependencies]
+x402-facilitator = { git = "https://github.com/x402-rs/x402-rs", default-features = false, features = ["chain-solana"] }
+```
+
+Available features:
+- `chain-eip155` â€” Enable EIP-155 (EVM) chain support
+- `chain-solana` â€” Enable Solana chain support
+- `chain-aptos` â€” Enable Aptos chain support
+- `telemetry` â€” Enable OpenTelemetry tracing
+
+Then in your `main.rs`, simply call the `run` function:
+
+```rust
+#[tokio::main]
+async fn main() {
+    let result = x402_facilitator::run().await;
+    if let Err(e) = result {
+        eprintln!("{e}");
+        std::process::exit(1)
+    }
+}
+```
+
+**Option 2: Create a minimal custom facilitator**
+
+Follow the "Getting Started" section above, but only register the schemes you need:
+
+```rust
+// Only register Solana schemes
+let scheme_blueprints = {
+    let mut blueprints = SchemeBlueprints::new();
+    blueprints.register(V1SolanaExact);
+    blueprints.register(V2SolanaExact);
+    blueprints
+};
+```
+
+This approach gives you full control over the binary size and dependencies.
+
+### Middleware Integration
+
+Integrate with your existing HTTP framework:
+
+```rust
+use axum::{middleware, Router};
+
+let app = Router::new()
+    .route("/verify", post(verify_handler))
+    .route("/settle", post(settle_handler))
+    .layer(middleware::from_fn(your_auth_middleware));
+```
+
+### Adding Pre/Post Processing Logic
+
+You can wrap `FacilitatorLocal` to add custom logic before or after payment verification and settlement. This is useful for:
+
+- **Logging and auditing** â€” Log all payment attempts for compliance
+- **Rate limiting** â€” Enforce limits on verification/settlement calls
+- **Custom validation** â€” Add business-specific validation rules
+- **Metrics collection** â€” Track payment success rates, latency, etc.
+
+To do this, create a wrapper struct and implement the `Facilitator` trait:
+
+```rust
+use x402_facilitator_local::FacilitatorLocal;
+use x402_types::facilitator::Facilitator;
+use x402_types::proto;
+use std::sync::Arc;
+
+/// A wrapper around FacilitatorLocal that adds custom pre/post processing.
+pub struct FancyFacilitator<A> {
+    inner: FacilitatorLocal<A>,
+}
+
+impl<A> FancyFacilitator<A> {
+    pub fn new(inner: FacilitatorLocal<A>) -> Self {
+        Self { inner }
+    }
+}
+
+impl<A: Clone + Send + Sync + 'static> Facilitator for FancyFacilitator<A>
+where
+    FacilitatorLocal<A>: Facilitator,
+{
+    type Error = <FacilitatorLocal<A> as Facilitator>::Error;
+
+    async fn verify(
+        &self,
+        request: &proto::VerifyRequest,
+    ) -> Result<proto::VerifyResponse, Self::Error> {
+        // Pre-processing: custom validation, logging, rate limiting, etc.
+        println!("Verifying payment for scheme: {:?}", request.scheme);
+        
+        // Delegate to inner facilitator
+        let response = self.inner.verify(request).await?;
+        
+        // Post-processing: audit logging, metrics, etc.
+        println!("Payment verified: payer={}", response.payer);
+        
+        Ok(response)
+    }
+
+    async fn settle(
+        &self,
+        request: &proto::SettleRequest,
+    ) -> Result<proto::SettleResponse, Self::Error> {
+        // Pre-processing
+        println!("Settling payment...");
+        
+        // Delegate to inner facilitator
+        let response = self.inner.settle(request).await?;
+        
+        // Post-processing
+        println!("Payment settled: tx={}", response.transaction);
+        
+        Ok(response)
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, Self::Error> {
+        self.inner.supported().await
+    }
+}
+
+// Usage:
+let facilitator = FacilitatorLocal::new(scheme_registry);
+let fancy_facilitator = FancyFacilitator::new(facilitator);
+let state = Arc::new(fancy_facilitator);
+```
+
+## Deployment
+
+### Docker
+
+Create a `Dockerfile`:
+
+```dockerfile
+FROM rust:1.88 as builder
+WORKDIR /app
+COPY . .
+RUN cargo build --release
+
+FROM debian:bookworm-slim
+COPY --from=builder /app/target/release/your-facilitator /usr/local/bin/
+ENTRYPOINT ["your-facilitator"]
+```
+
+### Environment Variables
+
+- `HOST` - Server bind address (default: `0.0.0.0`)
+- `PORT` - Server port (default: `9090`)
+- `CONFIG` - Path to configuration file (default: `config.json`)
+- `RUST_LOG` - Log level (default: `info`)
+- `OTEL_EXPORTER_OTLP_ENDPOINT` - OpenTelemetry collector endpoint
+
+## Observability
+
+Enable OpenTelemetry tracing:
+
+```rust
+use x402_facilitator_local::util::Telemetry;
+
+let telemetry = Telemetry::new()
+    .with_name("my-facilitator")
+    .with_version("1.0.0")
+    .register();
+
+let tracing_layer = telemetry.http_tracing();
+
+let app = Router::new()
+    .merge(handlers::routes().with_state(state))
+    .layer(tracing_layer);
+```
+
+## Examples
+
+- [x402-facilitator](../facilitator) - Production-ready facilitator binary
+- [x402-axum-example](../examples/x402-axum-example) - Server example
+- [x402-reqwest-example](../examples/x402-reqwest-example) - Client example
+
+## Support
+
+For questions or issues:
+- Open an issue on [GitHub](https://github.com/x402-rs/x402-rs)
+- Check the [x402 protocol documentation](https://x402.org)
+- Review individual crate documentation on [docs.rs](https://docs.rs)
diff --git a/bbt-x402-facilitator/docs/how-to-write-a-scheme.md b/bbt-x402-facilitator/docs/how-to-write-a-scheme.md
new file mode 100644
index 0000000..01769a7
--- /dev/null
+++ b/bbt-x402-facilitator/docs/how-to-write-a-scheme.md
@@ -0,0 +1,561 @@
+# How to Write a Scheme for x402-rs
+
+This guide explains how to create a custom payment scheme for the x402-rs **facilitator** (server-side). Schemes define how the facilitator verifies and settles payments on behalf of resource servers.
+
+## What is a Scheme?
+
+A **scheme** defines how a payment is verified and settled on a specific blockchain. It encapsulates:
+
+- **Payload format** â€” The structure of payment data (signatures, transactions, authorizations)
+- **Verification logic** â€” How to validate a payment is correct before execution
+- **Settlement logic** â€” How to execute the payment on-chain
+- **Supported chains** â€” Which blockchain networks the scheme works with
+
+For example, the `exact` scheme implements ERC-3009 `transferWithAuthorization` for EVM chains and SPL token transfers for Solana. You might create a new scheme for subscription payments, escrow flows, or alternative token standards.
+
+## Overview
+
+| Concept               | Open/Closed | Description                                                                                                           |
+|-----------------------|-------------|-----------------------------------------------------------------------------------------------------------------------|
+| **Schemes**           | **Open**    | Widely extensible. Anyone can create custom schemes for new payment flows.                                            |
+| **Protocol Versions** | Closed      | Fixed set: v1 and v2. Defined by the x402 specification. (v1 is legacy, v2 will probably live for the next few years) |
+| **Chain Providers**   | Closed      | Predefined set for the implementation due to chain-specific complexity.                                               |
+
+## Architecture
+
+```mermaid
+flowchart TB
+    subgraph Registration
+        SB[SchemeBlueprints] -->|by id| BP[X402SchemeBlueprint]
+        BP -->|build with ChainProvider| H[Box dyn X402SchemeFacilitator]
+    end
+
+    subgraph Runtime
+        SR[SchemeRegistry] -->|by_slug| H
+        H -->|verify| VR[VerifyResponse]
+        H -->|settle| SR2[SettleResponse]
+        H -->|supported| SPR[SupportedResponse]
+    end
+```
+
+## Crate Structure
+
+Schemes are organized in chain-specific crates under `crates/chains/`:
+
+```
+crates/
+â”œâ”€â”€ x402-types/           # Core types and traits
+â”‚   â””â”€â”€ src/scheme/       # X402SchemeId, X402SchemeFacilitator, etc.
+â”œâ”€â”€ x402-chain-solana/    # Solana-specific implementations
+â”‚   â””â”€â”€ src/
+â”‚       â”œâ”€â”€ v1_solana_exact/
+â”‚       â””â”€â”€ v2_solana_exact/
+â”œâ”€â”€ x402-chain-eip155/    # EVM-specific implementations
+â”‚   â””â”€â”€ src/
+â”‚       â”œâ”€â”€ v1_eip155_exact/
+â”‚       â””â”€â”€ v2_eip155_exact/
+â””â”€â”€ x402-chain-aptos/     # Aptos-specific implementations
+    â””â”€â”€ src/
+        â””â”€â”€ v2_aptos_exact/
+```
+
+Each scheme directory contains:
+- `mod.rs` - Module exports and scheme ID implementation
+- `facilitator.rs` - Facilitator implementation (server-side)
+- `client.rs` - Client implementation (optional)
+- `server.rs` - Server types (optional)
+- `types.rs` - Scheme-specific types
+
+## Naming Convention
+
+Scheme IDs follow the pattern: `v{version}-{namespace}-{scheme}`
+
+| ID | Struct Name | Directory |
+|------|-------------|-----------|
+| `v2-solana-exact` | `V2SolanaExact` | `v2_solana_exact/` |
+| `v1-eip155-exact` | `V1Eip155Exact` | `v1_eip155_exact/` |
+| `v2-solana-myscheme` | `V2SolanaMyscheme` | `v2_solana_myscheme/` |
+
+This makes it easy to map between IDs, chain namespaces, scheme names, and code.
+
+## Core Traits and Structs
+
+### X402SchemeId
+
+Provides identification for a scheme. This trait defines the scheme's version, namespace, and name:
+
+```rust
+pub trait X402SchemeId {
+    /// The x402 protocol version (1 or 2). Defaults to 2.
+    fn x402_version(&self) -> u8 {
+        2
+    }
+    
+    /// The chain namespace (e.g., "eip155", "solana")
+    fn namespace(&self) -> &str;
+    
+    /// The scheme name (e.g., "exact", "myscheme")
+    fn scheme(&self) -> &str;
+    
+    /// Computed ID: "v{version}-{namespace}-{scheme}"
+    fn id(&self) -> String {
+        format!(
+            "v{}-{}-{}",
+            self.x402_version(),
+            self.namespace(),
+            self.scheme()
+        )
+    }
+}
+```
+
+### X402SchemeFacilitatorBuilder
+
+Factory for creating scheme facilitators:
+
+```rust
+pub trait X402SchemeFacilitatorBuilder<P> {
+    /// Creates a new scheme handler for the given chain provider.
+    ///
+    /// # Arguments
+    ///
+    /// * `provider` - The chain provider to use for on-chain operations
+    /// * `config` - Optional scheme-specific configuration
+    fn build(
+        &self,
+        provider: P,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>>;
+}
+```
+
+- The type parameter `P` represents the chain provider type (e.g., `&ChainProvider`, `Arc<SolanaChainProvider>`)
+- The `build` method receives a chain providerâ€”implementations typically use a chain-specific trait like `SolanaChainProviderLike` to access provider methods
+- The optional `config` allows scheme-specific configuration (parse however you wish, see "Configure in JSON" section)
+
+### X402SchemeBlueprint
+
+A combined trait that requires both `X402SchemeId` and `X402SchemeFacilitatorBuilder`. This is automatically implemented for any type that implements both traits:
+
+```rust
+pub trait X402SchemeBlueprint<P>:
+    X402SchemeId + for<'a> X402SchemeFacilitatorBuilder<&'a P>
+{
+}
+impl<T, P> X402SchemeBlueprint<P> for T where
+    T: X402SchemeId + for<'a> X402SchemeFacilitatorBuilder<&'a P>
+{
+}
+```
+
+The type parameter `P` represents the chain provider type that the blueprint can work with.
+
+### X402SchemeFacilitator
+
+Three core operations every scheme facilitator must implement:
+
+```rust
+#[async_trait::async_trait]
+pub trait X402SchemeFacilitator: Send + Sync {
+    async fn verify(&self, request: &proto::VerifyRequest)
+        -> Result<proto::VerifyResponse, X402SchemeFacilitatorError>;
+    async fn settle(&self, request: &proto::SettleRequest)
+        -> Result<proto::SettleResponse, X402SchemeFacilitatorError>;
+    async fn supported(&self)
+        -> Result<proto::SupportedResponse, X402SchemeFacilitatorError>;
+}
+```
+
+| Method      | Purpose                                            |
+|-------------|----------------------------------------------------|
+| `verify`    | Validate a payment without executing it.           |
+| `settle`    | Execute the payment on-chain.                      |
+| `supported` | Advertise what payment kinds this scheme supports. |
+
+### SchemeHandlerSlug
+
+At runtime, handlers are identified by a slug combining chain ID, version, and scheme name:
+
+```rust
+pub struct SchemeHandlerSlug {
+    pub chain_id: ChainId,
+    pub x402_version: u8,
+    pub name: String,
+}
+```
+
+This allows the same scheme blueprint to create different handlers for different chains.
+
+## Step-by-Step Guide
+
+### Step 1: Define Types
+
+Use proto generics. For v2 schemes:
+
+```rust
+// In crates/chains/x402-chain-solana/src/v2_solana_myscheme/types.rs
+use x402_types::proto::v2;
+
+pub type PaymentRequirements = v2::PaymentRequirements<MyScheme, MyAmountType, MyAddressType, MyExtra>;
+pub type PaymentPayload = v2::PaymentPayload<PaymentRequirements, MyPayload>;
+pub type VerifyRequest = v2::VerifyRequest<PaymentPayload, PaymentRequirements>;
+pub type SettleRequest = VerifyRequest;
+```
+
+### Step 2: Implement X402SchemeId
+
+```rust
+// In crates/chains/x402-chain-solana/src/v2_solana_myscheme/mod.rs
+use x402_types::scheme::X402SchemeId;
+
+pub struct V2SolanaMyscheme;
+
+impl X402SchemeId for V2SolanaMyscheme {
+    // x402_version() defaults to 2, no need to override
+
+    fn namespace(&self) -> &str {
+        "solana"
+    }
+
+    fn scheme(&self) -> &str {
+        "myscheme"
+    }
+}
+```
+
+### Step 3: Implement X402SchemeFacilitatorBuilder
+
+In the chain-specific crate, implement the builder for the chain-specific provider type:
+
+```rust
+// In crates/chains/x402-chain-solana/src/v2_solana_myscheme/facilitator.rs
+use crate::chain::provider::SolanaChainProviderLike;
+use x402_types::chain::ChainProviderOps;
+use x402_types::scheme::X402SchemeFacilitator;
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V2SolanaMyscheme
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync + 'static,
+{
+    fn build(
+        &self,
+        provider: P,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn Error>>
+    {
+        // Optionally parse config here
+        let config = config
+            .map(serde_json::from_value::<V2SolanaMyschemeFacilitatorConfig>)
+            .transpose()?
+            .unwrap_or_default();
+
+        Ok(Box::new(V2SolanaMyschemeFacilitator::new(provider, config)))
+    }
+}
+```
+
+Then, in the facilitator crate, implement the adapter for the generic `ChainProvider` enum:
+
+```rust
+// In facilitator/src/schemes.rs
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::V2SolanaMyscheme;
+
+#[cfg(feature = "chain-solana")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V2SolanaMyscheme {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        let solana_provider = if let ChainProvider::Solana(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V2SolanaMyscheme::build: provider must be a SolanaChainProvider".into());
+        };
+        self.build(solana_provider, config)
+    }
+}
+```
+
+### Step 4: Implement Facilitator
+
+```rust
+// In crates/chains/x402-chain-solana/src/v2_solana_myscheme/facilitator.rs
+use crate::chain::provider::SolanaChainProviderLike;
+use x402_types::chain::ChainProviderOps;
+use x402_types::proto;
+use x402_types::proto::v2;
+use x402_types::scheme::{
+    X402SchemeFacilitator, X402SchemeFacilitatorError,
+};
+
+/// Configuration for V2 Solana Myscheme facilitator
+#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
+#[serde(default)]
+pub struct V2SolanaMyschemeFacilitatorConfig {
+    // Add your scheme-specific configuration fields here
+}
+
+impl Default for V2SolanaMyschemeFacilitatorConfig {
+    fn default() -> Self {
+        Self {
+            // Set default values for your configuration
+        }
+    }
+}
+
+pub struct V2SolanaMyschemeFacilitator<P> {
+    provider: P,
+    config: V2SolanaMyschemeFacilitatorConfig,
+}
+
+impl<P> V2SolanaMyschemeFacilitator<P> {
+    pub fn new(provider: P, config: V2SolanaMyschemeFacilitatorConfig) -> Self {
+        Self { provider, config }
+    }
+}
+
+#[async_trait::async_trait]
+impl<P> X402SchemeFacilitator for V2SolanaMyschemeFacilitator<P>
+where
+    P: SolanaChainProviderLike + ChainProviderOps + Send + Sync,
+{
+    async fn verify(&self, request: &proto::VerifyRequest)
+        -> Result<proto::VerifyResponse, X402SchemeFacilitatorError>
+    {
+        let request = types::VerifyRequest::from_proto(request.clone())?;
+        // Your verification logic...
+        Ok(proto::v2::VerifyResponse::valid(payer.to_string()).into())
+    }
+
+    async fn settle(&self, request: &proto::SettleRequest)
+        -> Result<proto::SettleResponse, X402SchemeFacilitatorError>
+    {
+        // Your settlement logic...
+        Ok(proto::v2::SettleResponse::Success { payer, transaction, network }.into())
+    }
+
+    async fn supported(&self) -> Result<proto::SupportedResponse, X402SchemeFacilitatorError> {
+        let chain_id = self.provider.chain_id();
+        let kinds = vec![proto::SupportedPaymentKind {
+            x402_version: proto::v2::X402Version2.into(),
+            scheme: "myscheme".to_string(),
+            network: chain_id.to_string(),
+            extra: None,
+        }];
+        let signers = {
+            let mut signers = HashMap::with_capacity(1);
+            signers.insert(chain_id, self.provider.signer_addresses());
+            signers
+        };
+        Ok(proto::SupportedResponse {
+            kinds,
+            extensions: Vec::new(),
+            signers,
+        })
+    }
+}
+```
+
+### Step 5: Register the Scheme
+
+For custom facilitators, register dynamically in the facilitator crate:
+
+```rust,ignore
+// In facilitator/src/schemes.rs
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::V2SolanaMyscheme;
+
+// Then in your initialization code:
+let blueprints = SchemeBlueprints::new().and_register(V2SolanaMyscheme);
+```
+
+### Step 6: Configure in JSON
+
+```json
+{
+  "schemes": [
+    {
+      "enabled": true,
+      "id": "v2-solana-myscheme",
+      "chains": "solana:*",
+      "config": { "yourOption": "value" }
+    }
+  ]
+}
+```
+
+- `id`: The scheme blueprint ID (matches `X402SchemeId::id()`)
+- `chains`: Pattern matching (`*` for all, `{a,b}` for specific chain references)
+- `config`: Passed to your `build()` method
+
+## Per-Chain Custom Handlers
+
+A powerful feature of the scheme system is the ability to have **different handlers for the same scheme on different chains**. This is useful when:
+
+- A specific chain requires custom logic (e.g., different gas handling, chain-specific optimizations)
+- You want to override the default behavior for a particular chain
+- You need chain-specific configuration
+
+### How It Works
+
+1. **Create a custom scheme blueprint** that extends or modifies the base scheme behavior
+2. **Register it with a unique ID** (e.g., `v1-eip155-exact-custom`)
+3. **Enable it for specific chains** in your config
+
+### Example: Custom Handler for a Specific Chain
+
+Suppose you want `eip155:3` to use custom logic while all other EVM chains use the standard `v1-eip155-exact`:
+
+**Step 1: Create the custom scheme**
+
+```rust
+// In crates/chains/x402-chain-eip155/src/v1_eip155_exact_custom/mod.rs
+use x402_types::scheme::X402SchemeId;
+
+pub struct V1Eip155ExactCustom;
+
+impl X402SchemeId for V1Eip155ExactCustom {
+    fn x402_version(&self) -> u8 {
+        1
+    }
+
+    fn namespace(&self) -> &str {
+        "eip155"
+    }
+
+    fn scheme(&self) -> &str {
+        "exact"  // Same scheme name - will handle "exact" payments
+    }
+
+    // Override the default ID to distinguish from the standard scheme
+    fn id(&self) -> String {
+        "v1-eip155-exact-custom".to_string()
+    }
+}
+
+// In crates/chains/x402-chain-eip155/src/v1_eip155_exact_custom/facilitator.rs
+use crate::chain::provider::Eip155ChainProviderLike;
+use x402_types::chain::ChainProviderOps;
+use x402_types::scheme::X402SchemeFacilitator;
+
+impl<P> X402SchemeFacilitatorBuilder<P> for V1Eip155ExactCustom
+where
+    P: Eip155ChainProviderLike + ChainProviderOps + Send + Sync + 'static,
+{
+    fn build(&self, provider: P, config: Option<serde_json::Value>)
+        -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn Error>>
+    {
+        // Your custom facilitator with chain-specific logic
+        Ok(Box::new(V1Eip155ExactCustomFacilitator::new(provider, config)))
+    }
+}
+
+// In facilitator/src/schemes.rs
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::V1Eip155ExactCustom;
+
+#[cfg(feature = "chain-eip155")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V1Eip155ExactCustom {
+    fn build(&self, provider: &ChainProvider, config: Option<serde_json::Value>)
+        -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>>
+    {
+        let eip155_provider = if let ChainProvider::Eip155(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V1Eip155ExactCustom::build: provider must be an Eip155ChainProvider".into());
+        };
+        self.build(eip155_provider, config)
+    }
+}
+```
+
+**Step 2: Register both schemes**
+
+```rust,ignore
+// In facilitator/src/schemes.rs
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::{V1Eip155Exact, V1Eip155ExactCustom};
+
+// Then in your initialization code:
+let blueprints = SchemeBlueprints::new()
+    .and_register(V1Eip155Exact)        // Standard handler
+    .and_register(V1Eip155ExactCustom); // Custom handler
+```
+
+**Step 3: Configure in JSON**
+
+```json,ignore
+{
+  "chains": {
+    "eip155:1": { ... },
+    "eip155:3": { ... },
+    "eip155:8453": { ... }
+  },
+  "schemes": [
+    {
+      "id": "v1-eip155-exact",
+      "chains": "eip155:*"
+    },
+    {
+      "id": "v1-eip155-exact-custom",
+      "chains": "eip155:3",
+      "config": { "customOption": "value" }
+    }
+  ]
+}
+```
+
+### Key Points
+
+- The **scheme name** (returned by `scheme()`) determines which payment requests the handler processes
+- The **ID** (returned by `id()`) is used to match config entries to blueprints
+- Multiple blueprints can have the same `scheme()` but different `id()` values
+- The `chains` pattern in config determines which chain(s) each blueprint instance handles
+- Each config entry creates a separate handler instance for matching chains
+
+### Chain Pattern Matching
+
+The `chains` field supports several patterns:
+
+| Pattern | Matches |
+|---------|---------|
+| `eip155:84532` | Exact chain ID |
+| `eip155:*` | All EVM chains |
+| `solana:*` | All Solana chains |
+| `eip155:{1,8453}` | Specific chain references |
+
+## Contributing to Upstream x402-rs
+
+If you want your scheme included in the default x402-rs distribution:
+
+1. Create module structure under `crates/chains/x402-chain-{namespace}/src/v{version}_{namespace}_{scheme}/`
+2. Add module declaration in the chain crate's `lib.rs`:
+    ```rust
+    pub mod v2_solana_myscheme;
+    ```
+3. Add the scheme to the chain crate's `Cargo.toml` features if needed
+4. Register in the facilitator crate's `schemes.rs`:
+    ```rust,ignore
+    #[cfg(feature = "chain-solana")]
+    use x402_chain_solana::V2SolanaMyscheme;
+
+    // Then in your initialization code:
+    let blueprints = SchemeBlueprints::new().and_register(V2SolanaMyscheme);
+    ```
+
+## Checklist for creating a new scheme
+
+- [ ] Create module structure under `crates/chains/x402-chain-{namespace}/src/v{version}_{namespace}_{scheme}/`
+- [ ] Declare a struct for your new scheme, for example, `V2SolanaMyscheme`
+- [ ] Declare a struct for the scheme facilitator, for example, `V2SolanaMyschemeFacilitator<P>`
+- [ ] Implement `X402SchemeId` for `V2SolanaMyscheme` with correct `x402_version()`, `namespace()`, and `scheme()`
+- [ ] Optionally override `id()` for custom scheme variants
+- [ ] Implement `X402SchemeFacilitatorBuilder<P>` for `V2SolanaMyscheme` with `build()` method in the chain crate
+- [ ] Implement `X402SchemeFacilitatorBuilder<&ChainProvider>` for `V2SolanaMyscheme` in the facilitator crate
+- [ ] Implement `X402SchemeFacilitator` (verify/settle/supported) for `V2SolanaMyschemeFacilitator<P>`
+- [ ] Define concrete types for the scheme using proto v2 generics
+- [ ] Add module declaration in the chain crate's `lib.rs`
+- [ ] Register in `SchemeBlueprints` in the facilitator crate
+- [ ] Configure in `config.json` with appropriate `id` and `chains` pattern, and update `config.json.example`
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/.env.example b/bbt-x402-facilitator/examples/x402-axum-example/.env.example
new file mode 100644
index 0000000..8d49e73
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-axum-example/.env.example
@@ -0,0 +1,6 @@
+FACILITATOR_URL=https://x402.org/facilitator
+
+# OpenTelemetry Desktop Viewer
+OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4318"
+OTEL_TRACES_EXPORTER="otlp"
+OTEL_EXPORTER_OTLP_PROTOCOL="http/protobuf"
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/Cargo.toml b/bbt-x402-facilitator/examples/x402-axum-example/Cargo.toml
new file mode 100644
index 0000000..36fc661
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-axum-example/Cargo.toml
@@ -0,0 +1,22 @@
+[package]
+name = "x402-axum-example"
+version = "0.1.0"
+edition = "2024"
+publish = false
+
+[dependencies]
+x402-types = { workspace = true }
+x402-chain-eip155 = { workspace = true, features = ["server", "telemetry"] }
+x402-chain-solana = { workspace = true, features = ["server", "telemetry"] }
+x402-axum = { workspace = true, features = ["telemetry"] }
+http = { workspace = true }
+axum = { workspace = true }
+tokio = { workspace = true }
+dotenvy = { workspace = true }
+alloy-primitives = { workspace = true }
+
+solana-pubkey = { version = "4.0.0" }
+
+# Tracing and OpenTelemetry
+tracing = { workspace = true }
+tracing-subscriber = { workspace = true }
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/LICENSE b/bbt-x402-facilitator/examples/x402-axum-example/LICENSE
new file mode 100644
index 0000000..0e18545
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-axum-example/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2025 Sergey Ukustov
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
\ No newline at end of file
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/README.md b/bbt-x402-facilitator/examples/x402-axum-example/README.md
new file mode 100644
index 0000000..9294bcb
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-axum-example/README.md
@@ -0,0 +1,158 @@
+# x402-axum-example
+
+An example Axum server demonstrating how to protect routes using the [`x402-axum`](https://crates.io/crates/x402-axum) crate
+and enforce payments using the [x402 protocol](https://www.x402.org).
+
+This example shows how to:
+- Configure a remote facilitator for payment verification and settlement.
+- Gate access to an API endpoint using the [`x402-axum`](https://crates.io/crates/x402-axum) middleware
+  that requires on-chain payment before responding.
+- Use **dynamic pricing** to adjust prices based on request parameters.
+- Implement **conditional free access** by returning an empty price tags vector.
+- Enable structured logging and distributed tracing using `tracing` and OpenTelemetry to observe what's happening inside the middleware.
+- Support **multiple chains** (EVM and Solana) and **multiple schemes** (v1 and v2 protocols).
+
+## Whatâ€™s Included
+
+- **Axum setup**
+  - Defines multiple protected routes with different pricing strategies.
+- **x402 middleware usage**
+  - Demonstrates both **static pricing** and **dynamic pricing** approaches.
+  - Shows **multi-chain support** with EVM (Base Sepolia) and Solana payment options.
+  - Includes **conditional free access** by returning empty price tags.
+  - Adds human-readable metadata via `.with_description(...)` and `.with_mime_type(...)`.
+- **Tracing setup**
+  - HTTP-level tracing via `tower_http::trace::TraceLayer`
+  - OpenTelemetry integration via `x402_rs::telemetry::Telemetry`
+  - Rich per-request spans that capture method, URI, latency, status, and middleware internals.
+
+## Prerequisites
+
+- Rust 1.76+ (Rust 2024 Edition)
+- A running x402 facilitator
+- Optional `.env` file to configure OpenTelemetry endpoint
+
+## Try It
+
+```bash
+git clone https://github.com/x402-rs/x402-rs x402-rs
+cd x402-rs/examples/x402-axum-example
+cargo run
+```
+
+The server will start on http://localhost:3000 and exposes multiple protected routes:
+
+- `GET /static-price-v1` - Static pricing with v1 protocol (EVM + Solana)
+- `GET /static-price-v2` - Static pricing with v2 protocol (EVM + Solana)
+- `GET /dynamic-price-v2` - Dynamic pricing "exact" scheme with v2 protocol (adjusts based on `discount` query param)
+- `GET /conditional-free-v2` - Conditional free access (bypasses payment with `free` query param)
+
+All routes are protected by x402 middleware and require valid x402 payments unless conditional free access is triggered.
+If no valid payment is provided, the server responds with a 402 Payment Required status and detailed requirements.
+
+### Dynamic Pricing Endpoints
+
+The example includes endpoints demonstrating dynamic pricing:
+
+**Dynamic price with discount:**
+```bash
+# Full price (100 units of USDC on both EVM and Solana)
+curl http://localhost:3000/dynamic-price-v2
+
+# Discounted price (50 units of USDC on both EVM and Solana)
+curl http://localhost:3000/dynamic-price-v2?discount
+```
+
+**Conditional free access:**
+```bash
+# Requires payment (returns 402)
+curl http://localhost:3000/conditional-free-v2
+
+# Bypasses payment entirely (returns content directly)
+curl http://localhost:3000/conditional-free-v2?free
+```
+
+The conditional free access works by returning an empty price tags vector from the dynamic pricing callback. When the middleware receives an empty vector, it bypasses payment enforcement and forwards the request directly to the handler.
+
+This demonstrates the flexibility, allowing for complex pricing strategies including free tiers, promotional access, and conditional pricing based on any request criteria.
+
+**Example (Request with payment):**
+
+If you use an x402-compatible client like [`x402-fetch`](https://www.npmjs.com/package/x402-fetch),
+it will automatically perform payment (e.g., 0.01 USDC on Base Sepolia or 100 USDC on Solana) before fetching any of the protected routes, and receive the protected response.
+
+<details>
+<summary>Example JS code to access a paid endpoint</summary>
+
+```typescript
+import { createWalletClient, http } from "viem";  // https://viem.sh/
+import { privateKeyToAccount } from "viem/accounts";
+import { baseSepolia } from "viem/chains";
+import { wrapFetchWithPayment } from "x402-fetch"; // https://www.npmjs.com/package/x402-fetch
+
+// Create a wallet client
+const account = privateKeyToAccount("0xYourPrivateKey");
+const client = createWalletClient({
+  account,
+  transport: http(),
+  chain: baseSepolia,
+});
+
+// Wrap the fetch function with payment handling
+const fetchWithPay = wrapFetchWithPayment(fetch, client);
+
+// Make a request that may require payment
+const response = await fetchWithPay("http://localhost:3000/static-price-v2", {
+  method: "GET",
+});
+
+const data = await response.json(); //=> { "hello": "paid-content" }
+```
+</details>
+
+## Telemetry
+
+To enable tracing, configure OpenTelemetry using environment variables.
+For use with local [OpenTelemetry Desktop Viewer](https://github.com/CtrlSpice/otel-desktop-viewer) create a `.env` file:
+
+```dotenv
+OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4318"
+OTEL_TRACES_EXPORTER="otlp"
+OTEL_EXPORTER_OTLP_PROTOCOL="http/protobuf"
+```
+
+With telemetry enabled, traces will include spans like:
+- `x402.handle_request`, 
+- `x402.verify_payment`, 
+- `x402.facilitator_client.verify`.
+
+These can be visualized in tools like Jaeger, Tempo, or Grafana.
+
+<details>
+<summary>See how x402 traces look in the OpenTelemetry Desktop Viewer</summary>
+
+- **Payment Required:** Request received without payment, and the middleware returned a `402 Payment Required` response:
+
+  ![Trace: Payment Required](./screenshots/trace-payment-required.webp)
+
+  Note how the span includes a `status=402` event emitted by the middleware:
+
+  ![Trace Event: 402 Payment Required](./screenshots/trace-payment-required-event.webp)
+
+- **Payment Accepted:** A valid x402 payment was provided; the middleware allowed the request and settled the payment:
+
+  ![Trace: Payment Provided](./screenshots/trace-payment-provided.webp)
+
+  The span includes an event showing `status=200`:
+
+  ![Trace Event: 200 OK](./screenshots/trace-payment-provided-event.webp)
+
+</details>
+
+## Related Crates
+- [`x402-axum`](https://crates.io/crates/x402-axum) â€“ Axum middleware used in this example.
+- [`x402-rs`](https://crates.io/crates/x402-rs) â€“ Core x402 protocol types, client traits, and utilities.
+
+## License
+
+[Apache-2.0](LICENSE)
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided-event.webp b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided-event.webp
new file mode 100644
index 0000000..377ecf9
Binary files /dev/null and b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided-event.webp differ
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided.webp b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided.webp
new file mode 100644
index 0000000..cbf4e4c
Binary files /dev/null and b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-provided.webp differ
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required-event.webp b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required-event.webp
new file mode 100644
index 0000000..c7b9b22
Binary files /dev/null and b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required-event.webp differ
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required.webp b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required.webp
new file mode 100644
index 0000000..fa23cdb
Binary files /dev/null and b/bbt-x402-facilitator/examples/x402-axum-example/screenshots/trace-payment-required.webp differ
diff --git a/bbt-x402-facilitator/examples/x402-axum-example/src/main.rs b/bbt-x402-facilitator/examples/x402-axum-example/src/main.rs
new file mode 100644
index 0000000..1424856
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-axum-example/src/main.rs
@@ -0,0 +1,140 @@
+use alloy_primitives::address;
+use axum::Router;
+use axum::http::StatusCode;
+use axum::response::IntoResponse;
+use axum::routing::get;
+use dotenvy::dotenv;
+use solana_pubkey::pubkey;
+use std::env;
+use tracing::instrument;
+use x402_axum::X402Middleware;
+use x402_chain_eip155::{KnownNetworkEip155, V1Eip155Exact, V2Eip155Exact};
+use x402_chain_solana::{KnownNetworkSolana, V1SolanaExact, V2SolanaExact};
+use x402_types::networks::USDC;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    dotenv().ok();
+    init_tracing();
+
+    let facilitator_url =
+        env::var("FACILITATOR_URL").unwrap_or("https://facilitator.x402.rs".to_string());
+
+    let x402 = X402Middleware::try_from(facilitator_url)?;
+
+    let app = Router::new()
+        .route(
+            "/static-price-v1",
+            get(my_handler).layer(
+                x402.with_price_tag(V1Eip155Exact::price_tag(
+                    address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                    USDC::base_sepolia().parse("0.01")?,
+                ))
+                .with_price_tag(V1SolanaExact::price_tag(
+                    pubkey!("EGBQqKn968sVv5cQh5Cr72pSTHfxsuzq7o7asqYB5uEV"),
+                    USDC::solana().amount(100),
+                )),
+            ),
+        )
+        .route(
+            "/static-price-v2",
+            get(my_handler).layer(
+                x402.with_price_tag(V2Eip155Exact::price_tag(
+                    address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                    USDC::base_sepolia().amount(10u64),
+                ))
+                .with_price_tag(V2SolanaExact::price_tag(
+                    pubkey!("EGBQqKn968sVv5cQh5Cr72pSTHfxsuzq7o7asqYB5uEV"),
+                    USDC::solana().amount(100),
+                )),
+            ),
+        )
+        // Dynamic pricing: adjust price based on request parameters
+        // GET /dynamic-price-v2 -> 100 units
+        // GET /dynamic-price-v2?discount -> 50 units (discounted)
+        .route(
+            "/dynamic-price-v2",
+            get(my_handler).layer(x402.with_dynamic_price(|_headers, uri, _base_url| {
+                // Check if "discount" query parameter is present (before async block)
+                let has_discount = uri.query().map(|q| q.contains("discount")).unwrap_or(false);
+                let amount: u64 = if has_discount { 50 } else { 100 };
+
+                async move {
+                    vec![
+                        // V2 EIP155 (Base Sepolia) price tag
+                        V2Eip155Exact::price_tag(
+                            address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                            USDC::base_sepolia().amount(amount),
+                        ),
+                        // V2 Solana price tag
+                        V2SolanaExact::price_tag(
+                            pubkey!("EGBQqKn968sVv5cQh5Cr72pSTHfxsuzq7o7asqYB5uEV"),
+                            USDC::solana().amount(amount),
+                        ),
+                    ]
+                }
+            })),
+        )
+        // Conditional free access: bypass payment when "free" query parameter is present
+        // GET /conditional-free-v2 -> requires payment (402)
+        // GET /conditional-free-v2?free -> bypasses payment, returns content directly
+        //
+        // This demonstrates returning an empty price tags vector to skip payment enforcement.
+        // Useful for implementing free tiers, promotional access, or conditional pricing.
+        .route(
+            "/conditional-free-v2",
+            get(my_handler).layer(x402.with_dynamic_price(|_headers, uri, _base_url| {
+                // Check if "free" query parameter is present - if so, bypass payment
+                let is_free = uri.query().map(|q| q.contains("free")).unwrap_or(false);
+
+                async move {
+                    if is_free {
+                        // Return empty vector to bypass payment enforcement entirely.
+                        // The middleware will forward the request directly to the handler
+                        // without requiring any payment.
+                        vec![]
+                    } else {
+                        // Normal pricing - payment required
+                        vec![
+                            V2Eip155Exact::price_tag(
+                                address!("0xBAc675C310721717Cd4A37F6cbeA1F081b1C2a07"),
+                                USDC::base_sepolia().amount(100u64),
+                            ),
+                            V2SolanaExact::price_tag(
+                                pubkey!("EGBQqKn968sVv5cQh5Cr72pSTHfxsuzq7o7asqYB5uEV"),
+                                USDC::solana().amount(100),
+                            ),
+                        ]
+                    }
+                }
+            })),
+        );
+
+    tracing::info!("Using facilitator on {}", x402.facilitator_url());
+
+    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
+        .await
+        .expect("Can not start server");
+    tracing::info!("Listening on {}", listener.local_addr().unwrap());
+    axum::serve(listener, app).await.unwrap();
+
+    Ok(())
+}
+
+#[instrument(skip_all)]
+async fn my_handler() -> impl IntoResponse {
+    (StatusCode::OK, "This is a VIP content!")
+}
+
+fn init_tracing() {
+    use tracing_subscriber::{EnvFilter, fmt};
+    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("trace"));
+
+    fmt()
+        .with_env_filter(filter)
+        .with_target(false) // cleaner logs
+        .with_level(true)
+        .with_thread_ids(false)
+        .with_thread_names(false)
+        .init();
+}
diff --git a/bbt-x402-facilitator/examples/x402-reqwest-example/.env.example b/bbt-x402-facilitator/examples/x402-reqwest-example/.env.example
new file mode 100644
index 0000000..d0414f1
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-reqwest-example/.env.example
@@ -0,0 +1,4 @@
+EVM_PRIVATE_KEY=0xPrivateKey
+SOLANA_PRIVATE_KEY=SolanaPrivateKey
+
+SOLANA_RPC_URL=https://solana-endpoint.com/
diff --git a/bbt-x402-facilitator/examples/x402-reqwest-example/Cargo.toml b/bbt-x402-facilitator/examples/x402-reqwest-example/Cargo.toml
new file mode 100644
index 0000000..67dee47
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-reqwest-example/Cargo.toml
@@ -0,0 +1,20 @@
+[package]
+name = "x402-reqwest-example"
+version = "0.1.0"
+edition = "2024"
+publish = false
+
+[dependencies]
+x402-chain-eip155 = { workspace = true, features = ["client", "telemetry"] }
+x402-chain-solana = { workspace = true, features = ["client", "telemetry"] }
+x402-reqwest = { workspace = true, features = ["telemetry"] }
+reqwest = { workspace = true }
+tokio = { workspace = true }
+dotenvy = { workspace = true }
+
+# EVM: Alloy
+alloy-signer-local = { version = "1.4" }
+
+# Solana
+solana-client = { version = "3.1.4" }
+solana-keypair = { version = "3.1.0" }
diff --git a/bbt-x402-facilitator/examples/x402-reqwest-example/README.md b/bbt-x402-facilitator/examples/x402-reqwest-example/README.md
new file mode 100644
index 0000000..116d646
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-reqwest-example/README.md
@@ -0,0 +1,54 @@
+# x402-reqwest-example
+
+An example client that uses [`x402-reqwest`](https://crates.io/crates/x402-reqwest) to pay for HTTP requests using the x402 protocol.
+
+This small demo shows how to configure a reqwest client to:
+- Interact with x402-protected endpoints
+- Apply token preferences and per-token payment caps
+- Support multiple chains (EVM and Solana) and multiple schemes (v1 and v2 protocols)
+
+## What it does
+
+On startup, this example:
+- Reads your private keys from env variables `EVM_PRIVATE_KEY` and `SOLANA_PRIVATE_KEY`
+- Builds a `reqwest` client using [`reqwest-middleware`](https://crates.io/crates/reqwest-middleware) and  [`x402-reqwest`](https://crates.io/crates/x402-reqwest)
+- Registers both V1 and V2 scheme clients for both EVM and Solana chains
+- Sends a request to a protected endpoint
+
+If the server responds with a 402 Payment Required, the client:
+- Parses the serverâ€™s requirements (supports both V1 and V2 protocols)
+- Selects a supported token (e.g. USDC on Base Sepolia or Solana)
+- Signs a `TransferWithAuthorization` (EVM) or SPL token transfer (Solana)
+- Retries with the signed payment attached
+
+The best part? **You donâ€™t have to worry about any of this.**
+Just set your token preferences and treat it like any other `reqwest` HTTP client.
+
+# Prerequisites
+- Private keys with testnet funds (Base Sepolia USDC for EVM, Solana Devnet USDC for Solana)
+- Rust + Cargo
+- `EVM_PRIVATE_KEY` and/or `SOLANA_PRIVATE_KEY` set in your environment (or in `.env` file, see `.env.example`)
+
+## Running the Example
+```shell
+# 1. Clone the repo and cd into this example folder
+# 2. Create `.env` file
+cp .env.example .env
+# 3. Set your EVM_PRIVATE_KEY and/or SOLANA_PRIVATE_KEY inside `.env`
+# 4. Run
+cargo run
+```
+You should see the request succeed and print the serverâ€™s response.
+
+## Behind the scenes
+
+This example uses:
+-	[`x402-reqwest`](https://crates.io/crates/x402-reqwest) to intercept 402s and attach signed payments
+-	[`alloy`](https://alloy.rs) for signing
+-	[`dotenvy`](https://crates.io/crates/dotenvy) to load the `.env` file
+-	[`x402-rs`](https://crates.io/crates/x402-rs) for token/network definitions and amount conversion
+
+## Related
+- [`x402-rs`](https://crates.io/crates/x402-rs): Common types and facilitator logic
+- [`x402-axum`](https://crates.io/crates/x402-axum): Axum server-side middleware to accept payments
+- [`x402-reqwest`](https://crates.io/crates/x402-reqwest): The crate this example is showcasing
diff --git a/bbt-x402-facilitator/examples/x402-reqwest-example/src/main.rs b/bbt-x402-facilitator/examples/x402-reqwest-example/src/main.rs
new file mode 100644
index 0000000..689e109
--- /dev/null
+++ b/bbt-x402-facilitator/examples/x402-reqwest-example/src/main.rs
@@ -0,0 +1,61 @@
+use alloy_signer_local::PrivateKeySigner;
+use dotenvy::dotenv;
+use reqwest::Client;
+use solana_client::nonblocking::rpc_client::RpcClient;
+use solana_keypair::Keypair;
+use std::env;
+use std::sync::Arc;
+use x402_chain_eip155::{V1Eip155ExactClient, V2Eip155ExactClient};
+use x402_chain_solana::{V1SolanaExactClient, V2SolanaExactClient};
+use x402_reqwest::{ReqwestWithPayments, ReqwestWithPaymentsBuild, X402Client};
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    dotenv().ok();
+
+    let mut x402_client = X402Client::new();
+    // Register eip155 "exact" scheme
+    {
+        let signer: Option<PrivateKeySigner> = env::var("EVM_PRIVATE_KEY")
+            .ok()
+            .and_then(|key| key.parse().ok());
+        if let Some(signer) = signer {
+            println!("Using EVM signer address: {:?}", signer.address());
+            let signer = Arc::new(signer);
+            x402_client = x402_client
+                .register(V1Eip155ExactClient::new(signer.clone()))
+                .register(V2Eip155ExactClient::new(signer));
+            println!("Enabled eip155 exact scheme")
+        }
+    };
+
+    // Register solana "exact" scheme
+    {
+        let keypair = env::var("SOLANA_PRIVATE_KEY")
+            .ok()
+            .map(|v| Keypair::from_base58_string(&v));
+        let rpc_client = env::var("SOLANA_RPC_URL").ok().map(RpcClient::new);
+        if let Some((keypair, rpc_client)) = keypair.zip(rpc_client) {
+            let keypair = Arc::new(keypair);
+            let rpc_client = Arc::new(rpc_client);
+            x402_client = x402_client
+                .register(V1SolanaExactClient::new(
+                    keypair.clone(),
+                    rpc_client.clone(),
+                ))
+                .register(V2SolanaExactClient::new(keypair, rpc_client));
+            println!("Enabled solana exact scheme")
+        }
+    }
+
+    let http_client = Client::new().with_payments(x402_client).build();
+
+    let response = http_client
+        .get("http://localhost:3000/protected-route")
+        .send()
+        .await?;
+
+    println!("Response: {:?}", response.text().await?);
+
+    Ok(())
+}
diff --git a/bbt-x402-facilitator/facilitator/Cargo.toml b/bbt-x402-facilitator/facilitator/Cargo.toml
new file mode 100644
index 0000000..1284acf
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/Cargo.toml
@@ -0,0 +1,46 @@
+[package]
+name = "x402-facilitator"
+version.workspace = true
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+homepage.workspace = true
+rust-version.workspace = true
+categories.workspace = true
+keywords.workspace = true
+description = "Production-ready x402 facilitator server binary"
+readme = "README.md"
+publish = false
+
+[package.metadata.docs.rs]
+all-features = true
+
+[[bin]]
+name = "x402-facilitator"
+path = "src/main.rs"
+
+[features]
+default = ["telemetry", "chain-eip155", "chain-solana"]
+telemetry = ["dep:tracing", "x402-types/telemetry", "x402-facilitator-local/telemetry", "x402-chain-eip155?/telemetry", "x402-chain-solana?/telemetry", "x402-chain-aptos?/telemetry"]
+chain-aptos = ["dep:x402-chain-aptos"]
+chain-eip155 = ["dep:x402-chain-eip155"]
+chain-solana = ["dep:x402-chain-solana"]
+full = ["telemetry", "chain-aptos", "chain-eip155", "chain-solana"]
+
+[dependencies]
+x402-types = { workspace = true, features = ["cli"]}
+x402-facilitator-local = { workspace = true }
+x402-chain-eip155 = { workspace = true, features = ["facilitator"], optional = true }
+x402-chain-solana = { workspace = true, features = ["facilitator"], optional = true }
+x402-chain-aptos = { workspace = true, features = ["facilitator"], optional = true }
+
+dotenvy = { workspace = true }
+serde_json = { workspace = true }
+serde = { workspace = true }
+tokio = { workspace = true }
+tracing = { workspace = true, optional = true }
+async-trait = { workspace = true }
+axum = { workspace = true }
+tower-http = { workspace = true }
+rustls = { version = "0.23", features = ["ring"] }
diff --git a/bbt-x402-facilitator/facilitator/README.md b/bbt-x402-facilitator/facilitator/README.md
new file mode 100644
index 0000000..8a97162
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/README.md
@@ -0,0 +1,184 @@
+# x402-facilitator
+
+A production-ready x402 facilitator server binary.
+
+This crate provides a complete, runnable HTTP server that implements the [x402](https://www.x402.org) payment protocol. It supports multiple blockchain networks (EVM/EIP-155, Solana, Aptos) and can verify and settle payments on-chain.
+
+The crate can also be used as a library to build custom facilitator implementations.
+
+## Features
+
+- **Multi-chain Support**: EVM (EIP-155), Solana, and Aptos blockchains
+- **Multiple Payment Schemes**: V1 and V2 protocol implementations
+- **OpenTelemetry Integration**: Optional distributed tracing and metrics (`telemetry` feature)
+- **Graceful Shutdown**: Clean shutdown on SIGTERM/SIGINT signals
+- **CORS Support**: Cross-origin requests enabled for web clients
+- **Flexible Configuration**: JSON-based configuration with environment variable overrides
+- **Modular Chain Support**: Enable only the blockchain networks you need via feature flags
+
+## Installation
+
+### As a Binary (via cargo install)
+
+```bash
+# Install from git
+cargo install --git https://github.com/x402-rs/x402-rs --package x402-facilitator
+
+# Run the installed binary
+x402-facilitator --config /path/to/config.json # Or provide config path via $CONF env var
+```
+
+### As a Library
+
+Add to your `Cargo.toml`:
+
+```toml
+[dependencies]
+x402-facilitator = { git = "https://github.com/x402-rs/x402-rs" }
+```
+
+**Note**: If you enable the `chain-aptos` feature, you must also include the required patches in your `Cargo.toml`:
+
+```toml
+[patch.crates-io]
+merlin = { git = "https://github.com/aptos-labs/merlin" }
+
+[patch."https://github.com/aptos-labs/aptos-core"]
+aptos-runtimes = { path = "https://github.com/x402-rs/x402-rs/patches/aptos-runtimes" }
+```
+
+## Usage
+
+### Running the Server
+
+```bash
+# Build and run from source
+cargo run --package x402-facilitator
+
+# With telemetry
+cargo run --package x402-facilitator --features telemetry
+
+# With specific chains only
+cargo run --package x402-facilitator --features chain-eip155,chain-solana
+
+# With all chains including Aptos (requires patches)
+cargo run --package x402-facilitator --features chain-eip155,chain-solana,chain-aptos
+
+# With the full feature (all chains + telemetry)
+cargo run --package x402-facilitator --features full
+
+# Specify custom config file
+cargo run --package x402-facilitator -- --config /path/to/config.json
+```
+
+### Configuration
+
+Create a `config.json` file:
+
+```json
+{
+  "port": 9090,
+  "host": "0.0.0.0",
+  "chains": {
+    "eip155:8453": {
+      "eip1559": true,
+      "signers": ["$FACILITATOR_PRIVATE_KEY"],
+      "rpc": [
+        {
+          "http": "https://mainnet.base.org",
+          "rate_limit": 100
+        }
+      ]
+    },
+    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "signers": ["$SOLANA_PRIVATE_KEY"],
+      "rpc": [
+        {
+          "http": "https://api.mainnet-beta.solana.com"
+        }
+      ]
+    }
+  },
+  "schemes": [
+    {
+      "scheme": "v2-eip155-exact",
+      "chains": ["eip155:8453"]
+    },
+    {
+      "scheme": "v2-solana-exact",
+      "chains": ["solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"]
+    }
+  ]
+}
+```
+
+### Environment Variables
+
+| Variable                      | Description                      | Default       |
+|-------------------------------|----------------------------------|---------------|
+| `HOST`                        | Server bind address              | `0.0.0.0`     |
+| `PORT`                        | Server port                      | `9090`        |
+| `CONFIG`                      | Path to config file              | `config.json` |
+| `OTEL_EXPORTER_OTLP_ENDPOINT` | OpenTelemetry collector endpoint | -             |
+| `OTEL_SERVICE_NAME`           | Service name for traces          | -             |
+
+## HTTP Endpoints
+
+| Endpoint     | Method | Description             |
+|--------------|--------|-------------------------|
+| `/`          | GET    | Server greeting         |
+| `/verify`    | GET    | Schema information      |
+| `/verify`    | POST   | Verify payment payload  |
+| `/settle`    | GET    | Schema information      |
+| `/settle`    | POST   | Settle payment on-chain |
+| `/supported` | GET    | List supported schemes  |
+| `/health`    | GET    | Health check            |
+
+## Architecture
+
+The facilitator is built on top of the `x402-facilitator-local` crate and uses:
+
+- **Axum**: HTTP server framework
+- **Tokio**: Async runtime
+- **x402-types**: Core protocol types and configuration (via `x402_types::config`)
+- **x402-chain-\\\\*\\\**: Chain-specific implementations
+
+```text
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   Axum HTTP â”‚
+â”‚   Server    â”‚
+â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
+       â”‚
+â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
+â”‚ Facilitator â”‚
+â”‚   Local     â”‚
+â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
+       â”‚
+â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
+â”‚   Scheme    â”‚
+â”‚  Registry   â”‚
+â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
+       â”‚
+  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
+  â–¼         â–¼
+â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”
+â”‚EIP  â”‚  â”‚Sol  â”‚  â”‚Apt  â”‚
+â”‚155  â”‚  â”‚ana  â”‚  â”‚os   â”‚
+â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜
+```
+
+## Feature Flags
+
+| Feature        | Description                                   |
+|----------------|-----------------------------------------------|
+| `telemetry`    | Enable OpenTelemetry tracing and metrics      |
+| `chain-eip155` | Enable EVM/EIP-155 chain support              |
+| `chain-solana` | Enable Solana chain support                   |
+| `chain-aptos`  | Enable Aptos chain support (requires patches) |
+| `full`         | Enable all features: telemetry + all chains   |
+
+**Note**: The `chain-aptos` feature requires additional patches due to its dependencies on Aptos core libraries. See the [Installation](#installation) section for details.
+
+## License
+
+Apache-2.0
diff --git a/bbt-x402-facilitator/facilitator/config.json.example b/bbt-x402-facilitator/facilitator/config.json.example
new file mode 100644
index 0000000..66d5f81
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/config.json.example
@@ -0,0 +1,45 @@
+{
+  "port": 9090,
+  "host": "0.0.0.0",
+  "chains": {
+    "eip155:84532": {
+      "_comment": "Base Sepolia"
+      "eip1559": true,
+      "flashblocks": true,
+      "signers": [
+          "0xWALLET"
+      ],
+      "rpc": [
+        {
+          "http": "https://rpc.com/eip155/84532",
+          "rate_limit": 50
+        }
+      ]
+    },
+    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+      "_comment": "Solana Mainnet"
+      "signer": "SOLANA_PRIVATE_KEY",
+      "rpc": "https://rpc.com/solana/5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
+      "pubsub": "wss://rpc.com/solana/5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
+    }
+  },
+  "schemes": [
+      {
+        "id": "v1-eip155-exact",
+        "chains": "eip155:*"
+      },
+      {
+        "id": "v2-eip155-exact",
+        "chains": "eip155:*"
+      },
+      {
+        "_comment": "Solana schemes allow Phantom Lighthouse program by default",
+        "id": "v1-solana-exact",
+        "chains": "solana:*"
+      },
+      {
+        "id": "v2-solana-exact",
+        "chains": "solana:*"
+      }
+    ]
+}
diff --git a/bbt-x402-facilitator/facilitator/src/chain.rs b/bbt-x402-facilitator/facilitator/src/chain.rs
new file mode 100644
index 0000000..d218cbb
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/chain.rs
@@ -0,0 +1,160 @@
+//! Blockchain-specific types and providers for x402 payment processing.
+//!
+//! This module provides abstractions for interacting with different blockchain networks
+//! in the x402 protocol. It supports multiple blockchain families:
+//!
+//! - **EIP-155 (EVM)**: Ethereum and EVM-compatible chains like Base, Polygon, Avalanche
+//! - **Solana**: The Solana blockchain
+//! - **Aptos**: The Aptos blockchain
+//!
+//! # Architecture
+//!
+//! The module is organized around the concept of chain providers and chain identifiers:
+//!
+//! - [`ChainId`] - A CAIP-2 compliant chain identifier (e.g., `eip155:8453` for Base)
+//! - [`ChainProvider`] - Enum wrapping chain-specific providers
+//! - [`ChainRegistry`] - Registry of configured chain providers
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_types::chain::{ChainId, ChainIdPattern};
+//!
+//! // Create a specific chain ID
+//! let base = ChainId::new("eip155", "8453");
+//!
+//! // Create a pattern that matches all EVM chains
+//! let all_evm = ChainIdPattern::wildcard("eip155");
+//! assert!(all_evm.matches(&base));
+//!
+//! // Create a pattern for specific chains
+//! let mainnet_chains = ChainIdPattern::set("eip155", ["1", "8453", "137"].into_iter().map(String::from).collect());
+//! assert!(mainnet_chains.matches(&base));
+//! ```
+
+use std::collections::HashMap;
+#[cfg(any(
+    feature = "chain-aptos",
+    feature = "chain-eip155",
+    feature = "chain-solana"
+))]
+use std::sync::Arc;
+#[cfg(feature = "chain-aptos")]
+use x402_chain_aptos::chain as aptos;
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::chain as eip155;
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::chain as solana;
+use x402_types::chain::{ChainId, ChainProviderOps, ChainRegistry, FromConfig};
+
+use crate::config::{ChainConfig, ChainsConfig};
+
+/// A blockchain provider that can interact with EVM, Solana, or Aptos chains.
+///
+/// This enum wraps chain-specific providers and provides a unified interface
+/// for the facilitator to interact with different blockchain networks.
+///
+/// # Variants
+///
+/// - `Eip155` - Provider for EVM-compatible chains (Ethereum, Base, Polygon, etc.)
+/// - `Solana` - Provider for the Solana blockchain
+/// - `Aptos` - Provider for the Aptos blockchain
+#[derive(Debug, Clone)]
+pub enum ChainProvider {
+    /// EVM chain provider for EIP-155 compatible networks.
+    #[cfg(feature = "chain-eip155")]
+    Eip155(Arc<eip155::Eip155ChainProvider>),
+    /// Solana chain provider.
+    #[cfg(feature = "chain-solana")]
+    Solana(Arc<solana::SolanaChainProvider>),
+    /// Aptos chain provider.
+    #[cfg(feature = "chain-aptos")]
+    Aptos(Arc<aptos::AptosChainProvider>),
+}
+
+/// Creates a new chain provider from configuration.
+///
+/// This factory method inspects the configuration type and creates the appropriate
+/// chain-specific provider (EVM, Solana, or Aptos).
+///
+/// # Errors
+///
+/// Returns an error if:
+/// - RPC connection fails
+/// - Signer configuration is invalid
+/// - Required configuration is missing
+#[async_trait::async_trait]
+impl FromConfig<ChainConfig> for ChainProvider {
+    async fn from_config(chains: &ChainConfig) -> Result<Self, Box<dyn std::error::Error>> {
+        #[allow(unused_variables)] // For when no chain features enabled
+        let provider = match chains {
+            #[cfg(feature = "chain-eip155")]
+            ChainConfig::Eip155(config) => {
+                let provider = eip155::Eip155ChainProvider::from_config(config).await?;
+                ChainProvider::Eip155(Arc::new(provider))
+            }
+            #[cfg(feature = "chain-solana")]
+            ChainConfig::Solana(config) => {
+                let provider = solana::SolanaChainProvider::from_config(config).await?;
+                ChainProvider::Solana(Arc::new(provider))
+            }
+            #[cfg(feature = "chain-aptos")]
+            ChainConfig::Aptos(config) => {
+                let provider = aptos::AptosChainProvider::from_config(config).await?;
+                ChainProvider::Aptos(Arc::new(provider))
+            }
+            #[allow(unreachable_patterns)] // For when no chain features enabled
+            _ => unreachable!("ChainConfig variant not enabled in this build"),
+        };
+        #[allow(unreachable_code)] // For when no chain features enabled
+        Ok(provider)
+    }
+}
+
+impl ChainProviderOps for ChainProvider {
+    fn signer_addresses(&self) -> Vec<String> {
+        match self {
+            #[cfg(feature = "chain-eip155")]
+            ChainProvider::Eip155(provider) => provider.signer_addresses(),
+            #[cfg(feature = "chain-solana")]
+            ChainProvider::Solana(provider) => provider.signer_addresses(),
+            #[cfg(feature = "chain-aptos")]
+            ChainProvider::Aptos(provider) => provider.signer_addresses(),
+            #[allow(unreachable_patterns)] // For when no chain features enabled
+            _ => unreachable!("ChainProvider variant not enabled in this build"),
+        }
+    }
+
+    fn chain_id(&self) -> ChainId {
+        match self {
+            #[cfg(feature = "chain-eip155")]
+            ChainProvider::Eip155(provider) => provider.chain_id(),
+            #[cfg(feature = "chain-solana")]
+            ChainProvider::Solana(provider) => provider.chain_id(),
+            #[cfg(feature = "chain-aptos")]
+            ChainProvider::Aptos(provider) => provider.chain_id(),
+            #[allow(unreachable_patterns)] // For when no chain features enabled
+            _ => unreachable!("ChainProvider variant not enabled in this build"),
+        }
+    }
+}
+
+/// Creates a new chain registry from configuration.
+///
+/// Initializes providers for all configured chains. Each chain configuration
+/// is processed and a corresponding provider is created and stored.
+///
+/// # Errors
+///
+/// Returns an error if any chain provider fails to initialize.
+#[async_trait::async_trait]
+impl FromConfig<ChainsConfig> for ChainRegistry<ChainProvider> {
+    async fn from_config(chains: &ChainsConfig) -> Result<Self, Box<dyn std::error::Error>> {
+        let mut providers = HashMap::new();
+        for chain in chains.iter() {
+            let chain_provider = ChainProvider::from_config(chain).await?;
+            providers.insert(chain_provider.chain_id(), chain_provider);
+        }
+        Ok(Self::new(providers))
+    }
+}
diff --git a/bbt-x402-facilitator/facilitator/src/config.rs b/bbt-x402-facilitator/facilitator/src/config.rs
new file mode 100644
index 0000000..9a26f79
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/config.rs
@@ -0,0 +1,206 @@
+//! Chain-specific configuration types for the x402 facilitator server.
+//!
+//! This module provides chain-specific configuration types that extend the base
+//! [`x402_types::config::Config`] with support for multiple blockchain families
+//! (EVM, Solana, Aptos).
+//!
+//! The core configuration loading logic, environment variable resolution, and CLI
+//! argument parsing are provided by [`x402_types::config`]. This module adds:
+//!
+//! - [`ChainConfig`] - Enum representing chain-specific configuration variants
+//! - [`ChainsConfig`] - Collection of chain configurations with custom serialization
+//! - [`Config`] - Type alias combining base config with chain-specific types
+//!
+//! # Configuration File Format
+//!
+//! See [`x402_types::config`] for the full configuration file format. The `chains`
+//! section uses CAIP-2 chain identifiers as keys:
+//!
+//! ```json
+//! {
+//!   "chains": {
+//!     "eip155:84532": {
+//!       "rpc_url": "https://sepolia.base.org",
+//!       "signer_private_key": "0x..."
+//!     },
+//!     "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
+//!       "rpc_url": "https://api.devnet.solana.com",
+//!       "signer_private_key": "base58..."
+//!     }
+//!   }
+//! }
+//! ```
+
+use serde::{Deserialize, Serialize};
+use std::ops::Deref;
+use x402_types::chain::ChainId;
+
+#[cfg(feature = "chain-aptos")]
+use x402_chain_aptos::chain as aptos;
+#[cfg(feature = "chain-aptos")]
+use x402_chain_aptos::chain::config::{AptosChainConfig, AptosChainConfigInner};
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::chain as eip155;
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::chain::config::{Eip155ChainConfig, Eip155ChainConfigInner};
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::chain as solana;
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::chain::config::{SolanaChainConfig, SolanaChainConfigInner};
+
+/// Server configuration.
+///
+/// Fields use serde defaults that fall back to environment variables,
+/// then to hardcoded defaults.
+pub type Config = x402_types::config::Config<ChainsConfig>;
+
+/// Configuration for a specific chain.
+///
+/// This enum represents chain-specific configuration that varies by chain family
+/// (EVM vs Solana vs Aptos). The chain family is determined by the CAIP-2 prefix of the
+/// chain identifier key (e.g., "eip155:" for EVM, "solana:" for Solana, "aptos:" for Aptos).
+#[derive(Debug, Clone)]
+pub enum ChainConfig {
+    /// EVM chain configuration (for chains with "eip155:" prefix).
+    #[cfg(feature = "chain-eip155")]
+    Eip155(Box<Eip155ChainConfig>),
+    /// Solana chain configuration (for chains with "solana:" prefix).
+    #[cfg(feature = "chain-solana")]
+    Solana(Box<SolanaChainConfig>),
+    /// Aptos chain configuration (for chains with "aptos:" prefix).
+    #[cfg(feature = "chain-aptos")]
+    Aptos(Box<AptosChainConfig>),
+}
+
+/// Configuration for chains.
+///
+/// This is a wrapper around `Vec<ChainConfig>` that provides custom serialization
+/// as a map where keys are CAIP-2 chain identifiers.
+#[derive(Debug, Clone, Default)]
+pub struct ChainsConfig(pub Vec<ChainConfig>);
+
+impl Deref for ChainsConfig {
+    type Target = Vec<ChainConfig>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl Serialize for ChainsConfig {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        use serde::ser::SerializeMap;
+
+        let chains = &self.0;
+        #[allow(unused_mut)] // For when no chain features enabled
+        let mut map = serializer.serialize_map(Some(chains.len()))?;
+        for chain_config in chains {
+            match chain_config {
+                #[cfg(feature = "chain-eip155")]
+                ChainConfig::Eip155(config) => {
+                    let chain_id = config.chain_id();
+                    let inner = &config.inner;
+                    map.serialize_entry(&chain_id, inner)?;
+                }
+                #[cfg(feature = "chain-solana")]
+                ChainConfig::Solana(config) => {
+                    let chain_id = config.chain_id();
+                    let inner = &config.inner;
+                    map.serialize_entry(&chain_id, inner)?;
+                }
+                #[cfg(feature = "chain-aptos")]
+                ChainConfig::Aptos(config) => {
+                    let chain_id = config.chain_id();
+                    let inner = &config.inner;
+                    map.serialize_entry(&chain_id, inner)?;
+                }
+                #[allow(unreachable_patterns)] // For when no chain features enabled
+                _ => unreachable!("ChainConfig variant not enabled in this build"),
+            }
+        }
+        map.end()
+    }
+}
+
+impl<'de> Deserialize<'de> for ChainsConfig {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        use serde::de::{MapAccess, Visitor};
+        use std::fmt;
+
+        struct ChainsVisitor;
+
+        impl<'de> Visitor<'de> for ChainsVisitor {
+            type Value = ChainsConfig;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("a map of chain identifiers to chain configurations")
+            }
+
+            fn visit_map<M>(self, mut access: M) -> Result<Self::Value, M::Error>
+            where
+                M: MapAccess<'de>,
+            {
+                #[allow(unused_mut)] // For when no chain features enabled
+                let mut chains = Vec::with_capacity(access.size_hint().unwrap_or(0));
+
+                while let Some(chain_id) = access.next_key::<ChainId>()? {
+                    let namespace = chain_id.namespace();
+                    #[allow(unused_variables)] // For when no chain features enabled
+                    let config = match namespace {
+                        #[cfg(feature = "chain-eip155")]
+                        eip155::EIP155_NAMESPACE => {
+                            let inner: Eip155ChainConfigInner = access.next_value()?;
+                            let config = Eip155ChainConfig {
+                                chain_reference: chain_id
+                                    .try_into()
+                                    .map_err(|e| serde::de::Error::custom(format!("{}", e)))?,
+                                inner,
+                            };
+                            ChainConfig::Eip155(Box::new(config))
+                        }
+                        #[cfg(feature = "chain-solana")]
+                        solana::SOLANA_NAMESPACE => {
+                            let inner: SolanaChainConfigInner = access.next_value()?;
+                            let config = SolanaChainConfig {
+                                chain_reference: chain_id
+                                    .try_into()
+                                    .map_err(|e| serde::de::Error::custom(format!("{}", e)))?,
+                                inner,
+                            };
+                            ChainConfig::Solana(Box::new(config))
+                        }
+                        #[cfg(feature = "chain-aptos")]
+                        aptos::APTOS_NAMESPACE => {
+                            let inner: AptosChainConfigInner = access.next_value()?;
+                            let config = AptosChainConfig {
+                                chain_reference: chain_id
+                                    .try_into()
+                                    .map_err(|e| serde::de::Error::custom(format!("{}", e)))?,
+                                inner,
+                            };
+                            ChainConfig::Aptos(Box::new(config))
+                        }
+                        _ => {
+                            return Err(serde::de::Error::custom(format!(
+                                "Unexpected namespace: {}",
+                                namespace
+                            )));
+                        }
+                    };
+                    #[allow(unreachable_code)] // For when no chain features enabled
+                    chains.push(config)
+                }
+
+                Ok(ChainsConfig(chains))
+            }
+        }
+
+        deserializer.deserialize_map(ChainsVisitor)
+    }
+}
diff --git a/bbt-x402-facilitator/facilitator/src/lib.rs b/bbt-x402-facilitator/facilitator/src/lib.rs
new file mode 100644
index 0000000..b142ffd
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/lib.rs
@@ -0,0 +1,37 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! x402 Facilitator Server
+//!
+//! A production-ready HTTP server implementing the [x402](https://www.x402.org) payment protocol.
+//!
+//! This crate provides a complete, runnable facilitator that supports multiple blockchain
+//! networks (EVM/EIP-155, Solana, Aptos) and can verify and settle payments on-chain.
+//!
+//! # Modules
+//!
+//! | Module | Description |
+//! |--------|-------------|
+//! | [`chain`] | Blockchain provider abstractions for EVM, Solana, and Aptos |
+//! | [`config`] | Configuration types and loading |
+//! | [`run`] | Main server initialization and runtime |
+//! | [`schemes`] | Scheme builder implementations for supported payment schemes |
+//!
+//! # Running the Server
+//!
+//! ```bash
+//! # Run with default configuration
+//! cargo run --package facilitator
+//!
+//! # Run with telemetry
+//! cargo run --package facilitator --features telemetry
+//!
+//! # Run with custom config
+//! cargo run --package facilitator -- --config /path/to/config.json
+//! ```
+
+pub mod chain;
+pub mod config;
+pub mod run;
+pub mod schemes;
+
+pub use run::run;
diff --git a/bbt-x402-facilitator/facilitator/src/main.rs b/bbt-x402-facilitator/facilitator/src/main.rs
new file mode 100644
index 0000000..8f25682
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/main.rs
@@ -0,0 +1,54 @@
+//! x402 Facilitator HTTP server binary.
+//!
+//! This is the main entry point for the x402 facilitator server, a production-ready
+//! HTTP server that implements the x402 payment protocol for blockchain-based micropayments.
+//!
+//! # Usage
+//!
+//! ```bash
+//! # Run with default configuration (config.json)
+//! cargo run --package facilitator
+//!
+//! # Run with custom configuration
+//! cargo run --package facilitator -- --config /path/to/config.json
+//!
+//! # Run with telemetry enabled
+//! cargo run --package facilitator --features telemetry
+//! ```
+//!
+//! # Configuration
+//!
+//! The server loads configuration from a JSON file. See [`config`](crate::config) module
+//! for the configuration format and environment variables.
+//!
+//! # Supported Blockchains
+//!
+//! - **EIP-155 (EVM)**: Ethereum, Base, Polygon, and other EVM-compatible chains
+//! - **Solana**: Mainnet, Devnet, and custom clusters
+//! - **Aptos**: Mainnet and testnet
+//!
+//! # Architecture
+//!
+//! The binary is organized into modules:
+//! - [`chain`](crate::chain) - Blockchain provider abstractions
+//! - [`config`](crate::config) - Configuration loading and validation
+//! - [`run`](crate::run) - HTTP server initialization and request handling
+//! - [`schemes`](crate::schemes) - Payment scheme registration
+
+mod chain;
+mod config;
+mod run;
+mod schemes;
+
+use std::process;
+
+use crate::run::run;
+
+#[tokio::main]
+async fn main() {
+    let result = run().await;
+    if let Err(e) = result {
+        println!("{e}");
+        process::exit(1)
+    }
+}
diff --git a/bbt-x402-facilitator/facilitator/src/run.rs b/bbt-x402-facilitator/facilitator/src/run.rs
new file mode 100644
index 0000000..50516bd
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/run.rs
@@ -0,0 +1,134 @@
+//! x402 Facilitator HTTP server entrypoint.
+//!
+//! This module initializes and runs the Axum-based HTTP server that exposes the x402 protocol
+//! interface for payment verification and settlement across multiple blockchain networks.
+//!
+//! # Endpoints
+//!
+//! | Method | Path | Description |
+//! |--------|------|-------------|
+//! | `GET` | `/verify` | Get supported verification schema |
+//! | `POST` | `/verify` | Verify a payment payload against requirements |
+//! | `GET` | `/settle` | Get supported settlement schema |
+//! | `POST` | `/settle` | Settle an accepted payment payload on-chain |
+//! | `GET` | `/supported` | List supported payment kinds (version/scheme/network) |
+//! | `GET` | `/health` | Health check endpoint |
+//!
+//! # Features
+//!
+//! - **Multi-chain support**: EIP-155 (EVM), Solana, and Aptos networks
+//! - **OpenTelemetry tracing** (with `telemetry` feature): Distributed tracing and metrics
+//! - **CORS support**: Cross-origin requests for browser-based clients
+//! - **Graceful shutdown**: Signal-based shutdown with cleanup
+//!
+//! # Environment Variables
+//!
+//! - `HOST` - Server bind address (default: `0.0.0.0`)
+//! - `PORT` - Server port (default: `9090`)
+//! - `CONFIG` - Path to configuration file (default: `config.json`)
+//! - `OTEL_*` - OpenTelemetry configuration (when `telemetry` feature enabled)
+
+use axum::Router;
+use axum::http::Method;
+use dotenvy::dotenv;
+use std::net::SocketAddr;
+use std::sync::Arc;
+use tower_http::cors;
+use x402_facilitator_local::util::SigDown;
+use x402_facilitator_local::{FacilitatorLocal, handlers};
+use x402_types::chain::ChainRegistry;
+use x402_types::chain::FromConfig;
+use x402_types::scheme::{SchemeBlueprints, SchemeRegistry};
+
+#[cfg(feature = "chain-aptos")]
+use x402_chain_aptos::V2AptosExact;
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::{V1Eip155Exact, V2Eip155Exact};
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::{V1SolanaExact, V2SolanaExact};
+#[cfg(feature = "telemetry")]
+use x402_facilitator_local::util::Telemetry;
+
+use crate::config::Config;
+
+/// Initializes the x402 facilitator server.
+///
+/// - Loads `.env` variables.
+/// - Initializes OpenTelemetry tracing.
+/// - Connects to Ethereum providers for supported networks.
+/// - Starts an Axum HTTP server with the x402 protocol handlers.
+///
+/// Binds to the address specified by the `HOST` and `PORT` env vars.
+pub async fn run() -> Result<(), Box<dyn std::error::Error>> {
+    // Initialize rustls crypto provider (ring)
+    rustls::crypto::CryptoProvider::install_default(rustls::crypto::ring::default_provider())
+        .expect("Failed to initialize rustls crypto provider");
+
+    // Load .env variables
+    dotenv().ok();
+
+    #[cfg(feature = "telemetry")]
+    let telemetry_layer = {
+        let telemetry = Telemetry::new()
+            .with_name(env!("CARGO_PKG_NAME"))
+            .with_version(env!("CARGO_PKG_VERSION"))
+            .register();
+        telemetry.http_tracing()
+    };
+
+    let config = Config::load()?;
+
+    let chain_registry = ChainRegistry::from_config(config.chains()).await?;
+    let scheme_blueprints = {
+        #[allow(unused_mut)] // For when no chain features enabled
+        let mut scheme_blueprints = SchemeBlueprints::new();
+        #[cfg(feature = "chain-eip155")]
+        {
+            scheme_blueprints.register(V1Eip155Exact);
+            scheme_blueprints.register(V2Eip155Exact);
+        }
+        #[cfg(feature = "chain-solana")]
+        {
+            scheme_blueprints.register(V1SolanaExact);
+            scheme_blueprints.register(V2SolanaExact);
+        }
+        #[cfg(feature = "chain-aptos")]
+        {
+            scheme_blueprints.register(V2AptosExact);
+        }
+        scheme_blueprints
+    };
+    let scheme_registry =
+        SchemeRegistry::build(chain_registry, scheme_blueprints, config.schemes());
+
+    let facilitator = FacilitatorLocal::new(scheme_registry);
+    let axum_state = Arc::new(facilitator);
+
+    let http_endpoints = Router::new().merge(handlers::routes().with_state(axum_state));
+    #[cfg(feature = "telemetry")]
+    let http_endpoints = http_endpoints.layer(telemetry_layer);
+    let http_endpoints = http_endpoints.layer(
+        cors::CorsLayer::new()
+            .allow_origin(cors::Any)
+            .allow_methods([Method::GET, Method::POST])
+            .allow_headers(cors::Any),
+    );
+
+    let addr = SocketAddr::new(config.host(), config.port());
+    #[cfg(feature = "telemetry")]
+    tracing::info!("Starting server at http://{}", addr);
+
+    let listener = tokio::net::TcpListener::bind(addr).await;
+    #[cfg(feature = "telemetry")]
+    let listener = listener.inspect_err(|e| tracing::error!("Failed to bind to {}: {}", addr, e));
+    let listener = listener?;
+
+    let sig_down = SigDown::try_new()?;
+    let axum_cancellation_token = sig_down.cancellation_token();
+    let axum_graceful_shutdown = async move { axum_cancellation_token.cancelled().await };
+    axum::serve(listener, http_endpoints)
+        .with_graceful_shutdown(axum_graceful_shutdown)
+        .await?;
+
+    Ok(())
+}
diff --git a/bbt-x402-facilitator/facilitator/src/schemes.rs b/bbt-x402-facilitator/facilitator/src/schemes.rs
new file mode 100644
index 0000000..e846999
--- /dev/null
+++ b/bbt-x402-facilitator/facilitator/src/schemes.rs
@@ -0,0 +1,128 @@
+//! Scheme builder implementations for the x402 facilitator.
+//!
+//! This module provides [`X402SchemeFacilitatorBuilder`] implementations for all supported
+//! payment schemes. These builders create scheme facilitators from the generic
+//! [`ChainProvider`] enum by extracting the appropriate
+//! chain-specific provider.
+//!
+//! # Supported Schemes
+//!
+//! | Scheme | Chains | Description |
+//! |--------|--------|-------------|
+//! | [`V1Eip155Exact`] | EIP-155 (EVM) | V1 protocol with exact amount on EVM |
+//! | [`V2Eip155Exact`] | EIP-155 (EVM) | V2 protocol with exact amount on EVM |
+//! | [`V1SolanaExact`] | Solana | V1 protocol with exact amount on Solana |
+//! | [`V2SolanaExact`] | Solana | V2 protocol with exact amount on Solana |
+//! | [`V2AptosExact`] | Aptos | V2 protocol with exact amount on Aptos |
+//!
+//! # Example
+//!
+//! ```ignore
+//! use x402_types::scheme::{SchemeBlueprints, X402SchemeFacilitatorBuilder};
+//! use x402_chain_eip155::V2Eip155Exact;
+//! use crate::chain::ChainProvider;
+//!
+//! // Register schemes
+//! let blueprints = SchemeBlueprints::new()
+//!     .and_register(V2Eip155Exact)
+//!     .and_register(V2SolanaExact);
+//! ```
+
+#[allow(unused_imports)] // For when no chain features are enabled
+use crate::chain::ChainProvider;
+#[allow(unused_imports)] // For when no chain features are enabled
+use std::sync::Arc;
+#[allow(unused_imports)] // For when no chain features are enabled
+use x402_types::scheme::{X402SchemeFacilitator, X402SchemeFacilitatorBuilder};
+
+#[cfg(feature = "chain-aptos")]
+use x402_chain_aptos::V2AptosExact;
+#[cfg(feature = "chain-eip155")]
+use x402_chain_eip155::{V1Eip155Exact, V2Eip155Exact};
+#[cfg(feature = "chain-solana")]
+use x402_chain_solana::{V1SolanaExact, V2SolanaExact};
+
+#[cfg(feature = "chain-solana")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V1SolanaExact {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        #[allow(irrefutable_let_patterns)] // For when just chain-aptos is enabled
+        let solana_provider = if let ChainProvider::Solana(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V1SolanaExact::build: provider must be a SolanaChainProvider".into());
+        };
+        self.build(solana_provider, config)
+    }
+}
+
+#[cfg(feature = "chain-solana")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V2SolanaExact {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        #[allow(irrefutable_let_patterns)] // For when just chain-aptos is enabled
+        let solana_provider = if let ChainProvider::Solana(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V2SolanaExact::build: provider must be a SolanaChainProvider".into());
+        };
+        self.build(solana_provider, config)
+    }
+}
+
+#[cfg(feature = "chain-eip155")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V2Eip155Exact {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        #[allow(irrefutable_let_patterns)] // For when just chain-aptos is enabled
+        let eip155_provider = if let ChainProvider::Eip155(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V2Eip155Exact::build: provider must be an Eip155ChainProvider".into());
+        };
+        self.build(eip155_provider, config)
+    }
+}
+
+#[cfg(feature = "chain-aptos")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V2AptosExact {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        #[allow(irrefutable_let_patterns)] // For when just chain-aptos is enabled
+        let aptos_provider = if let ChainProvider::Aptos(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V2AptosExact::build: provider must be an AptosChainProvider".into());
+        };
+        self.build(aptos_provider, config)
+    }
+}
+
+#[cfg(feature = "chain-eip155")]
+impl X402SchemeFacilitatorBuilder<&ChainProvider> for V1Eip155Exact {
+    fn build(
+        &self,
+        provider: &ChainProvider,
+        config: Option<serde_json::Value>,
+    ) -> Result<Box<dyn X402SchemeFacilitator>, Box<dyn std::error::Error>> {
+        #[allow(irrefutable_let_patterns)] // For when just chain-aptos is enabled
+        let eip155_provider = if let ChainProvider::Eip155(provider) = provider {
+            Arc::clone(provider)
+        } else {
+            return Err("V1Eip155Exact::build: provider must be an Eip155ChainProvider".into());
+        };
+        self.build(eip155_provider, config)
+    }
+}
diff --git a/bbt-x402-facilitator/justfile b/bbt-x402-facilitator/justfile
new file mode 100644
index 0000000..d1616ea
--- /dev/null
+++ b/bbt-x402-facilitator/justfile
@@ -0,0 +1,50 @@
+build-all:
+  cd facilitator/ && cargo build
+  cd crates/chains/x402-chain-eip155 && cargo build
+  cd crates/chains/x402-chain-solana && cargo build
+  cd crates/x402-types && cargo build
+  cd crates/x402-axum && cargo build
+  cd crates/x402-reqwest && cargo build
+  cd examples/x402-axum-example && cargo build
+  cd examples/x402-reqwest-example && cargo build
+
+format-all:
+  cd facilitator/ && cargo fmt
+  cd crates/chains/x402-chain-eip155 && cargo fmt
+  cd crates/chains/x402-chain-solana && cargo fmt
+  cd crates/x402-types && cargo fmt
+  cd crates/x402-axum && cargo fmt
+  cd crates/x402-reqwest && cargo fmt
+  cd examples/x402-axum-example && cargo fmt
+  cd examples/x402-reqwest-example && cargo fmt
+
+fmt-all: format-all
+
+clippy-all:
+  cd facilitator/ && cargo clippy
+  cd crates/chains/x402-chain-eip155 && cargo clippy
+  cd crates/chains/x402-chain-solana && cargo clippy
+  cd crates/x402-types && cargo clippy
+  cd crates/x402-axum && cargo clippy
+  cd crates/x402-reqwest && cargo clippy
+  cd examples/x402-axum-example && cargo clippy
+  cd examples/x402-reqwest-example && cargo clippy
+
+check-all:
+  cd facilitator/ && cargo check
+  cd crates/chains/x402-chain-eip155 && cargo check
+  cd crates/chains/x402-chain-solana && cargo check
+  cd crates/x402-types && cargo check
+  cd crates/x402-axum && cargo check
+  cd crates/x402-reqwest && cargo check
+  cd examples/x402-axum-example && cargo check
+  cd examples/x402-reqwest-example && cargo check
+
+test-all:
+  cd facilitator/ && cargo test
+  cd crates/chains/x402-chain-eip155 && cargo test
+  cd crates/chains/x402-chain-solana && cargo test
+  cd crates/x402-axum && cargo test
+  cd crates/x402-reqwest && cargo test
+  cd examples/x402-axum-example && cargo test
+  cd examples/x402-reqwest-example && cargo test
diff --git a/bbt-x402-facilitator/patches/aptos-runtimes/Cargo.toml b/bbt-x402-facilitator/patches/aptos-runtimes/Cargo.toml
new file mode 100644
index 0000000..f479011
--- /dev/null
+++ b/bbt-x402-facilitator/patches/aptos-runtimes/Cargo.toml
@@ -0,0 +1,8 @@
+[package]
+name = "aptos-runtimes"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+rayon = "1.10"
+tokio = { version = "1.35", features = ["rt-multi-thread"] }
diff --git a/bbt-x402-facilitator/patches/aptos-runtimes/src/lib.rs b/bbt-x402-facilitator/patches/aptos-runtimes/src/lib.rs
new file mode 100644
index 0000000..c36c20b
--- /dev/null
+++ b/bbt-x402-facilitator/patches/aptos-runtimes/src/lib.rs
@@ -0,0 +1,94 @@
+// Copyright (c) Aptos Foundation
+// Patched version that removes disable_lifo_slot() call for tokio 1.45+ compatibility
+
+use rayon::{ThreadPool, ThreadPoolBuilder};
+use std::sync::atomic::{AtomicUsize, Ordering};
+use tokio::runtime::{Builder, Runtime};
+
+const MAX_THREAD_NAME_LENGTH: usize = 12;
+
+pub fn spawn_named_runtime(thread_name: String, num_worker_threads: Option<usize>) -> Runtime {
+    spawn_named_runtime_with_start_hook(thread_name, num_worker_threads, || {})
+}
+
+pub fn spawn_named_runtime_with_start_hook<F>(
+    thread_name: String,
+    num_worker_threads: Option<usize>,
+    on_thread_start: F,
+) -> Runtime
+where
+    F: Fn() + Send + Sync + 'static,
+{
+    const MAX_BLOCKING_THREADS: usize = 64;
+
+    if thread_name.len() > MAX_THREAD_NAME_LENGTH {
+        panic!(
+            "The given runtime thread name is too long! Max length: {}, given name: {}",
+            MAX_THREAD_NAME_LENGTH, thread_name
+        );
+    }
+
+    let atomic_id = AtomicUsize::new(0);
+    let thread_name_clone = thread_name.clone();
+    let mut builder = Builder::new_multi_thread();
+    builder
+        .thread_name_fn(move || {
+            let id = atomic_id.fetch_add(1, Ordering::SeqCst);
+            format!("{}-{}", thread_name_clone, id)
+        })
+        .on_thread_start(on_thread_start)
+        // NOTE: disable_lifo_slot() removed for tokio 1.45+ compatibility
+        .max_blocking_threads(MAX_BLOCKING_THREADS)
+        .enable_all();
+    if let Some(num_worker_threads) = num_worker_threads {
+        builder.worker_threads(num_worker_threads);
+    }
+
+    builder.build().unwrap_or_else(|error| {
+        panic!(
+            "Failed to spawn named runtime! Name: {:?}, Error: {:?}",
+            thread_name, error
+        )
+    })
+}
+
+pub fn spawn_rayon_thread_pool(
+    thread_name: String,
+    num_threads: Option<usize>,
+) -> ThreadPool {
+    spawn_rayon_thread_pool_with_start_hook(thread_name, num_threads, || {})
+}
+
+pub fn spawn_rayon_thread_pool_with_start_hook<F>(
+    thread_name: String,
+    num_threads: Option<usize>,
+    start_handler: F,
+) -> ThreadPool
+where
+    F: Fn() + Send + Sync + 'static,
+{
+    if thread_name.len() > MAX_THREAD_NAME_LENGTH {
+        panic!(
+            "The given rayon pool thread name is too long! Max length: {}, given name: {}",
+            MAX_THREAD_NAME_LENGTH, thread_name
+        );
+    }
+
+    let atomic_id = AtomicUsize::new(0);
+    let mut builder = ThreadPoolBuilder::new()
+        .thread_name(move |_| {
+            let id = atomic_id.fetch_add(1, Ordering::SeqCst);
+            format!("{}-{}", thread_name, id)
+        })
+        .start_handler(move |_| start_handler());
+    if let Some(num_threads) = num_threads {
+        builder = builder.num_threads(num_threads);
+    }
+
+    builder.build().unwrap_or_else(|error| {
+        panic!(
+            "Failed to spawn rayon pool! Error: {:?}",
+            error
+        )
+    })
+}
diff --git a/bbt_mvp_client.py b/bbt_mvp_client.py
index 7e393ff..93de3dd 100644
--- a/bbt_mvp_client.py
+++ b/bbt_mvp_client.py
@@ -153,13 +153,19 @@ async def main():
     asset = accept["asset"]
     pay_to = Web3.to_checksum_address(accept["payTo"])
     max_amount = int(accept.get("amount") or accept.get("maxAmountRequired"))
+    network = accept["network"]
 
     token_address = Web3.to_checksum_address(asset.split("erc20:")[-1])
 
+    # With current facilitator code, spender must == payTo
+    # This is a limitation we work around by using payTo as spender
+    spender = pay_to
+    print(f"Permit2 spender (must == payTo for this facilitator): {spender}")
+
     now = int(time.time())
     sig_deadline = now + 3600
     expiration = now + 3600
-    nonce = get_permit2_nonce(w3, account.address, token_address, pay_to)
+    nonce = get_permit2_nonce(w3, account.address, token_address, spender)
 
     print(f"Token: {token_address}")
     print(f"Pay to: {pay_to}")
@@ -170,7 +176,7 @@ async def main():
     signature = sign_permit2_with_domain_separator(
         w3=w3,
         token_address=token_address,
-        spender=pay_to,
+        spender=spender,
         amount=max_amount,
         expiration=expiration,
         nonce=nonce,
@@ -191,7 +197,7 @@ async def main():
                         "expiration": expiration,
                         "nonce": nonce,
                     },
-                    "spender": pay_to,
+                    "spender": spender,
                     "sigDeadline": sig_deadline,
                 },
                 "signature": f"0x{signature}",
diff --git a/bbt_mvp_server.py b/bbt_mvp_server.py
index 50e3355..cd28c26 100644
--- a/bbt_mvp_server.py
+++ b/bbt_mvp_server.py
@@ -10,7 +10,7 @@ from dotenv import load_dotenv
 load_dotenv()
 
 app = FastAPI()
-http_client = httpx.AsyncClient(timeout=30.0)
+http_client = httpx.AsyncClient(timeout=120.0)
 
 FACILITATOR_URL = os.getenv("FACILITATOR_URL", "http://localhost:9090")
 SERVER_WALLET = os.getenv("SERVER_WALLET", "0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F")
@@ -129,9 +129,31 @@ async def weather(request: Request):
                 media_type="application/json",
             )
 
-        tx_hash = settle_data.get("txHash") or settle_data.get("transaction", {}).get(
-            "hash"
-        )
+        tx_hash = None
+        if isinstance(settle_data, dict):
+            tx_hash = settle_data.get("txHash")
+            if not tx_hash:
+                transaction = settle_data.get("transaction")
+                if isinstance(transaction, dict):
+                    tx_hash = transaction.get("hash")
+                elif isinstance(transaction, str):
+                    if transaction.startswith("0x") and len(transaction) == 66:
+                        tx_hash = transaction
+        elif isinstance(settle_data, str):
+            try:
+                parsed = json.loads(settle_data)
+                if isinstance(parsed, dict):
+                    tx_hash = parsed.get("txHash")
+                    if not tx_hash:
+                        transaction = parsed.get("transaction")
+                        if isinstance(transaction, dict):
+                            tx_hash = transaction.get("hash")
+                        elif isinstance(transaction, str):
+                            if transaction.startswith("0x") and len(transaction) == 66:
+                                tx_hash = transaction
+            except json.JSONDecodeError:
+                if settle_data.startswith("0x") and len(settle_data) == 66:
+                    tx_hash = settle_data
 
     except Exception as e:
         print(f"Facilitator error: {e}")
diff --git a/diary.md b/diary.md
index ae32979..b163db0 100644
--- a/diary.md
+++ b/diary.md
@@ -22,12 +22,12 @@ Fixed multiple format issues for facilitator /settle endpoint:
 - Asset must be plain address "0x7EfE..." not CAIP-10 format
 - Nonce must be 32-byte hex "0x..." (64 chars)
 - x402Version must be at TOP level of settle request, not inside paymentRequirements
-4. Hit Fundamental Blocker
-Facilitator returns signature validation error:
-Invalid signature: Address mismatch
-  recovered: 0xBB29d3eAaF085D8D70904D9D91Ae56b66eA4EA7c
-  expected:  0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F
-Root Cause: x402-rs facilitator expects EIP-3009 TransferWithAuthorization signatures, but BBT token only supports EIP-2612 Permit. These have different EIP-712 typed data structures.
+4. Added Permit2 Support and Completed On-Chain Settlement
+- Forked facilitator into /home/tzapac-server/Documents/x402_poc/bbt-x402-facilitator
+- Added Permit2 support (PermitSingle/PermitDetails types, ABI, v1/v2 flows)
+- Ran debug facilitator binary on ub1:9090 (Permit2-enabled)
+- Fixed server response parsing for facilitator JSON/string payloads
+- End-to-end HTTP flow now returns 200 with on-chain tx hash
 ---
 Current State
 What Works âœ…
@@ -41,9 +41,9 @@ What Works âœ…
 What's Blocked âŒ
 | Step | Reason |
 |------|--------|
-| Facilitator signature validation | EIP-3009 vs EIP-2612 mismatch |
-| On-chain token transfer | Blocked by above |
-| Transaction hash proof | Blocked by above |
+| Facilitator signature validation | âœ… Permit2 flow (EIP-712 + Permit2) |
+| On-chain token transfer | âœ… Verified |
+| Transaction hash proof | âœ… Verified |
 ---
 Files We're Working On
 Local: /home/tzapac-server/Documents/x402_poc/
@@ -68,45 +68,36 @@ Network: Etherlink Mainnet
 Chain ID: 42793
 RPC: https://rpc.bubbletez.com
 BBT Token: 0x7EfE4bdd11237610bcFca478937658bE39F8dfd6
-Server Wallet: 0x81C54CB7690016b2b0c3017a4991783964601bd9
-Client Wallet: 0xA6e868Cd44C7643Fb4Ca9E2D0D66B13f403B488F
-Facilitator: http://100.112.150.8:8080
+Server Wallet: 0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9
+Client Wallet: 0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9
+Facilitator (debug Permit2): http://100.112.150.8:9090
+Facilitator (legacy container): http://100.112.150.8:8080
+Latest tx: 0x0476d3bcfccf6a83644d12c5abcaf598a6fc1ac7ee1377bff35fda5b828590e1
 ---
 What To Do Next
-Option A: Find/Deploy EIP-3009 Token (Recommended)
-1. Check if Etherlink USDC (0x796Ea11Fa2dD751eD01b53C372fFDB4AAa8f00F9) supports transferWithAuthorization
-2. If not, deploy a test token with EIP-3009 support
-3. Update mvp_server.py and mvp_client.py to use new token
-4. Re-run payment flow for on-chain proof
-Option B: Modify x402-rs Facilitator
-1. SSH to ub1: ssh ub1
-2. Edit ~/x402_rs/x402-rs/src/facilitator_local.rs
-3. Add EIP-2612 Permit signature verification alongside EIP-3009
-4. Rebuild: docker build -t ukstv/x402-facilitator:etherlink .
-5. Restart container
-Option C: Use Different Network
-Test on Base Sepolia where official USDC with EIP-3009 exists.
+- Decide whether to keep using the debug Permit2 facilitator on 9090 or bake Permit2 into the Docker container.
+- If needed, re-enable a separate payTo address by aligning Permit2 spender vs recipient logic in the facilitator.
 ---
 Key Commands
-# Start MVP server (in tmux session 'storefront')
+# Start MVP server (tmux session 'bbt-server')
 cd /home/tzapac-server/Documents/x402_poc
 source venv/bin/activate
-python mvp_server.py
+python bbt_mvp_server.py
 # Run client test
-python mvp_client.py
+python bbt_mvp_client.py
 # Check facilitator logs
-ssh ub1 "docker logs x402-facilitator-etherlink --tail 20"
+ssh ub1 "tail -200 /tmp/facilitator-debug.log"
 # Rebuild facilitator on ub1
 ssh ub1 "cd ~/x402_rs/x402-rs && docker build -t ukstv/x402-facilitator:etherlink . && docker stop x402-facilitator-etherlink && docker rm x402-facilitator-etherlink && docker run -d --name x402-facilitator-etherlink --env-file .env -p 8080:8080 ukstv/x402-facilitator:etherlink"
 ---
 Continuation Prompt
 Continue x402 POC on Etherlink. Current state:
 - HTTP protocol flow WORKS (402 â†’ payment header â†’ server â†’ facilitator)
-- On-chain settlement BLOCKED: facilitator expects EIP-3009 TransferWithAuthorization signatures, but BBT token only supports EIP-2612 Permit
-Files: /home/tzapac-server/Documents/x402_poc/ (mvp_server.py, mvp_client.py)
-Facilitator: ssh ub1, source at ~/x402_rs/x402-rs/
-Next step options:
-A) Check if Etherlink USDC (0x796Ea11Fa2dD751eD01b53C372fFDB4AAa8f00F9) supports EIP-3009
-B) Modify facilitator to support EIP-2612 Permit
-C) Deploy test EIP-3009 token on Etherlink
-Read AGENTS.md and PROOF_OF_CONCEPT.md for full context.
\ No newline at end of file
+- On-chain settlement VERIFIED via Permit2
+- Facilitator running on 9090 (debug binary) and 8080 (legacy container)
+Files: /home/tzapac-server/Documents/x402_poc/ (bbt_mvp_server.py, bbt_mvp_client.py)
+Facilitator: ssh ub1, debug binary at ~/x402-facilitator-debug
+Next steps:
+- Decide whether to keep 9090 or migrate Permit2 support into Docker image
+- If needed, rework spender/recipient handling for non-self payTo
+Read AGENTS.md and PROOF_OF_CONCEPT.md for full context.
diff --git a/x402_permit2_report.md b/x402_permit2_report.md
index bc1b7be..250b66e 100644
--- a/x402_permit2_report.md
+++ b/x402_permit2_report.md
@@ -2,11 +2,12 @@
 
 ## Summary
 - Facilitator accepted x402 v2 exact scheme and settled a Permit2 transfer.
-- On-chain transaction succeeded for 0.01 BBT.
-- Remaining issue: server response parsing (not settlement).
+- On-chain transactions succeeded for 0.01 BBT.
+- Server response parsing fixed; end-to-end HTTP flow returns 200.
 
 ## Transaction
-- Tx hash: `0xd33f139dce4ec8666756f5aafa061605f5e1041aae7c99809af3f9432b36d04a`
+- Tx hash (latest): `0x0476d3bcfccf6a83644d12c5abcaf598a6fc1ac7ee1377bff35fda5b828590e1`
+- Tx hash (prior): `0xd33f139dce4ec8666756f5aafa061605f5e1041aae7c99809af3f9432b36d04a`
 - Method: `Permit2.transferFrom`
 - Amount: `0.01 BBT`
 - From/To: `0x3E3f637E2C052AD29558684B85a56D8Ee1334Db9`
@@ -39,4 +40,4 @@ Facilitator response (200): {"success": true, "payer": "0x3E3f...", "transaction
 - Facilitator returned success with transaction hash.
 
 ## Notes
-- The settlement is confirmed on-chain; any remaining errors are in server response parsing.
+- The settlement is confirmed on-chain and the server returns 200 with tx hash.
